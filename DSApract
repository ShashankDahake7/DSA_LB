// Reverse Array

class Solution {
public:
    int reverse(int x) {
        int ans=0;
        while(x!=0){
        int digit=x%10;
        if(ans>INT_MAX/10 || ans<INT_MIN/10){
            return 0;
        }
        ans=(ans*10)+digit;
        x=x/10;
        }
        return ans;
    }
};

// Complement of base 10 integer

class Solution {
public:
    int bitwiseComplement(int n) {
        int m=n;
        int mask=0;
        if(n==0){
            return 1;
        }
        while(m!=0){
            mask=(mask<<1)|1;
            m=m>>1;
        }
        int ans=(~n)&mask;
        return ans;
    }
};

// Power of Two

class Solution {
public:
    bool isPowerOfTwo(int n) {
        int ans=1;
        for(int i=0;i<=30;i++){
            if(ans==n){
                return true;
            }
            if(ans<INT_MAX/2){
            ans=ans*2;
            }
        }
        return false;
    }
};

// Unique number

int findUnique(int *arr, int size)
{
    int ans=0;
    for(int i=0;i<size;i++){
        ans=ans^arr[i];
    }
    return ans;
}

// Duplicate number

int findDuplicate(vector<int> &arr) 
{
    int ans=0;
    for(int i=0;i<arr.size();i++){
        ans=ans^arr[i];
    }
    for(int i=0;i<arr.size();i++){
        ans=ans^i;
    }
    return ans;
}

// Array Intersection

#include <bits/stdc++.h> 
vector<int> findArrayIntersection(vector<int> &arr1, int n, vector<int> &arr2, int m)
{
	int i=0,j=0;
	vector<int> ans;
	while(i<n && j<m){
		if(arr1[i]==arr2[j]){
			ans.push_back(arr1[i]);
			i++;
			j++;
		}
		else if(arr1[i]<arr2[j]){
			i++;
		}
		else{
			j++;
		}
	}
	return ans;
}

// Pair Sum

#include <bits/stdc++.h> 
#include <bits/stdc++.h> 
vector<vector<int>> pairSum(vector<int> &arr, int s){
   int n=arr.size();
   vector<vector<int>> ans;
   for(int i=0;i<n;i++){
      for(int j=i+1;j<n;j++){
         if(arr[i]+arr[j]==s){
            vector<int> temp;
            temp.push_back(min(arr[i],arr[j]));
            temp.push_back(max(arr[i],arr[j]));
            ans.push_back(temp);
         }
      }
   }
   sort(ans.begin(),ans.end());
   return ans;
}

// Triplet Sum

#include <bits/stdc++.h>
vector<vector<int>> findTriplets(vector<int> arr, int n, int K) {
  sort(arr.begin(), arr.end());
  set<vector<int>> s;
  vector<vector<int>> ans;
  for (int i = 0; i < n; ++i)
  {
    int j = i + 1;
    int k = n - 1;
    while (j < k)
    {
      int sum = arr[i] + arr[j] + arr[k];
      if (sum == K)
      {
        s.insert({arr[i], arr[j], arr[k]});
        j++;
        k--;
      }
      else if (sum < K)
      {
        j++;
      }
      else
      {
        k--;
      }
    }
  }
  for (auto x : s)
  {
    ans.push_back(x);
  }
  return ans;
}

// Sort 0,1 and 2

#include <bits/stdc++.h>

void swap(int &x,int &y){
   int temp=x;
   x=y;
   y=temp;
}

void sort012(int *arr, int n)
{
   int a0=0,b1=0,c2=n-1;
   while(b1<=c2){
      if(arr[b1]==0){
         swap(arr[a0],arr[b1]);
         a0++;
         b1++;
      }
      else if(arr[b1]==1){
         b1++;
      }
      else{
         swap(arr[b1],arr[c2]);
         c2--;
      }
   }
}

// Unique Number Of Occurences

class Solution {
public:
    bool uniqueOccurrences(vector<int>& arr) {
        int i = 0;
        sort(arr.begin(),arr.end());
        vector<int> ans;
        while (i < arr.size()){
            int count = 1;
            for (int j = i+1; j< arr.size(); j++){
                if (arr[i] == arr[j])
                    count++;
            }
            ans.push_back(count);
            i = i + count;
        }
        sort(ans.begin(),ans.end());
        for (int i = 0; i < ans.size() - 1; i++){
            if (ans[i] == ans [i+1])
                return false;
        }
        return true;
    }
};

// All Duplicates in an Array

class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> ans; 
        sort(nums.begin(),nums.end());
            for(int i=0 ; i<nums.size()-1 ; ){
                if(nums[i]==nums[i+1]){
                    ans.push_back(nums[i]);
                    i=i+2;
                }
                else{
                  i++;  
                } 
            }
        return ans;
    }
};

// Find Pivot Index

class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int sum1=0,sum2=0;
        for(int i=0;i<nums.size();i++){
            sum1+=nums[i];
        }
        for(int i=0;i<nums.size();i++){
            sum1-=nums[i];
            if(sum1==sum2){
                return i;
            }
            sum2+=nums[i];
        }
        return -1;
    }
};

// First and Last Occurence

#include <bits/stdc++.h> 

int FirstOccurence(vector<int>& arr, int n, int k){
    int i=0,j=n-1,mid=i+(j-i)/2;
    int ans=-1;
    while(i<=j){
        if(arr[mid]<k){
            i=mid+1;
        }
        else if(arr[mid]==k){
            ans=mid;
            j=mid-1;
        }
        else{
            j=mid-1;
        }
        mid=i+(j-i)/2;
    }
    return ans;
}

int LastOccurence(vector<int>& arr, int n, int k){
    int i=0,j=n-1,mid=i+(j-i)/2;
    int ans=-1;
    while(i<=j){
        if(arr[mid]<k){
            i=mid+1;
        }
        else if(arr[mid]==k){
            ans=mid;
            i=mid+1;
        }
        else{
            j=mid-1;
        }
        mid=i+(j-i)/2;
    }
    return ans;
}

pair<int, int> firstAndLastPosition(vector<int>& arr, int n, int k)
{
    pair<int,int> p;
    p.first=FirstOccurence(arr,n,k);
    p.second=LastOccurence(arr,n,k);
    return p;
}

// Peak Index in a Mountain Array

class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int n=arr.size();
        int i=0,j=n-1,mid=i+(j-i)/2;
        while(i<j){
            if(arr[mid]<arr[mid+1]){
                i=mid+1;
            }
            else{
                j=mid;
            }
            mid=i+(j-i)/2;
        }
        return i;
    }
};

// Search in Rotated Sorted Array

#include <bits/stdc++.h> 
int pivotIndex(vector<int> arr,int n){
   int start = 0;
   int end = n-1;
   int mid = start + (end-start)/2;
   
   while(start<end){
       if(arr[mid]>=arr[0]){
           start = mid+1;
       }
       else{
           end = mid;
       }
       mid = start + (end-start)/2;
   }
   return start;
}
int binarySearch(vector<int> arr,int start,int end,int key){
   int mid = start + (end-start)/2;
   
   while(start<=end){
       if(arr[mid]==key){
           return mid;
       }
       else if(arr[mid]>key){
           end = mid -1;
       }
       else{
           start = mid+1;
       }
       mid = start+(end-start)/2;
   }
   return -1;
}
int findPosition(vector<int>& arr, int n, int k)
{
   int pivot = pivotIndex(arr,n);
   if(k>=arr[pivot] && k<=arr[n-1]){
       return binarySearch(arr,pivot,n-1,k);
   }
   else{
       return binarySearch(arr,0,pivot-1,k);
   }
}

// Square root of an integer

#include <bits/stdc++.h> 

int sqrtN(long long int N)
{
   if(N < 2) return N;
   long long int s = 0, e = N;
   long long int mid = s + (e - s) / 2;
   long long ans = -1;
   while (s <= e)
   {
       if (mid  == (N/mid)) // same as mid*mid == N, to avoid range overlow
           return mid;
       else if (mid > (N/mid))
           e = mid - 1;
       else
       {
           ans = mid;
           s = mid + 1;
       }
       mid = s + (e - s) / 2;
   }
   return ans;
}

// Allocate Books

#include <bits/stdc++.h>  

bool isPossible(int n, int m, vector<int> time,long long int mid){

   long long int studentCount=1 , chapterSum=0;     
   for(int i=0;i<m;i++){   
      if(chapterSum + time[i] <= mid){  
         chapterSum+= time[i];
       } 
      else  {
           studentCount++;  
           if(studentCount > n || time[i] > mid){
                return false;
           }        
           chapterSum = time[i];
       } 
      if(studentCount>n){  
         return false;  
     }
   }
   return true; 
}
 long long ayushGivesNinjatest(int n, int m, vector<int> time)  {
  
  long long int start=0, sum=0;   
  for(int i=0;i<m;i++){
       sum=sum+time[i];    
  }
  long long int end=sum, ans=-1, mid=start+(end-start)/2;
      while(start<=end){ 
      if(isPossible(n,m,time,mid)){
           ans=mid;
           end=mid-1;
       }
       else {
           start=mid+1;   
        }
       mid=start+(end-start)/2;
   }   
   return ans; 
}

// Aggressive Cows

bool isPossible(vector<int> &stalls, int k, int mid, int n) {
    
    int cowCount = 1;
    int lastPos = stalls[0];
    
    for(int i=0; i<n; i++ ){
        
        if(stalls[i]-lastPos >= mid){
            cowCount++;
            if(cowCount==k)
            {
                return true;
            }
            lastPos = stalls[i];
        }
    }
    return false;
}

int aggressiveCows(vector<int> &stalls, int k)
{
    sort(stalls.begin(), stalls.end());
   	int s = 0;
    int n = stalls.size();
    int e=stalls[n-1];
    int ans = -1;
    int mid = s + (e-s)/2;
    
    while(s<=e) {
        if(isPossible(stalls, k, mid, n)) {
            ans = mid;
            s = mid + 1;
        }
        else
        {
            e = mid - 1;
        }
        mid = s + (e-s)/2;
    }
    return ans;
}

// Painter's Partiton Problem

bool isPossible(vector<int> &boards, int n, int k, int mid) {
  int PainterCount = 1;
  int blockCount = 0;
  for (int i = 0; i < n; ++i) {
    if (blockCount + boards[i] <= mid) {
      blockCount += boards[i];
    } 
    else {
      PainterCount++;
      if (PainterCount > k || boards[i] > mid) {
        return false;
      }
      blockCount = boards[i];
    }
  }
  return true;
}
int findLargestMinDistance(vector<int> &boards, int k) {
  int n = boards.size();
  int s = 0;
  int sum = 0;
  for (int i = 0; i < n; ++i) {
    sum += boards[i];
  }
  int e = sum;
  int ans = -1;
  int mid = s + (e - s) / 2;
  while (s <= e) {
    if (isPossible(boards, n, k, mid)) {
      ans = mid;
      // Left wale bhaag jaenge
      e = mid - 1;
    } 
    else {
      s = mid + 1;
    }
    mid = s + (e - s) / 2;
  }
  return ans;
}

// Reverse an array

#include <bits/stdc++.h> 
void reverseArray(vector<int> &arr , int m)
{
	int n=arr.size();
	int start=m+1,end=n-1;
	while(start<end){
		int temp=arr[start];
		arr[start]=arr[end];
		arr[end]=temp;
		start++;
		end--;
	}
}

// Merge two sorted arrays 

class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        while(nums1.size()>m){
            nums1.pop_back();
        }
        for(int j=0; j<n; j++){
            nums1.push_back(nums2[j]);
        }
        sort(nums1.begin(), nums1.end());
    }
};

// Move zeroes to end

class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int i=0;
        for(int j=0;j<nums.size();j++){
            if(nums[j]!=0){
                swap(nums[j],nums[i]);
                i++;
            }
        }
    }
};

// Rotate the array by k

class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k %= n;
        reverse(nums.begin(), nums.end());
        reverse(nums.begin(), nums.begin()+k);
        reverse(nums.begin()+k, nums.end());
        return;
    }
};

// Check if Array is sorted and rotated

class Solution {
public:
    bool check(vector<int>& nums) {
        int count = 0;
        for(int i=0;i<nums.size()-1;i++)
        {
            if(nums[i]>nums[i+1] )
            count++;
        }
        if(nums[nums.size()-1] > nums[0]){
            count++;
        }
        if(count <= 1){
            return true;
        }
        else{
            return false;
        }
    }
};

// Sum of two arrays

#include <bits/stdc++.h> 

vector<int> reverse(vector<int> v){
	int s=0,e=v.size()-1;
	while(s<e){
		swap(v[s++],v[e--]);
	}
	return v;
}
vector<int> findArraySum(vector<int>&a, int n, vector<int>&b, int m) {
		int i=n-1,j=m-1;
		vector<int> ans;
		int carry=0;
		while(i>=0 && j>=0){
			int value1=a[i];
			int value2=b[j];
			int sum=value1+value2+carry;
			carry=sum/10;
			sum=sum%10;
			ans.push_back(sum);
			i--;
			j--;
		}
		while(i>=0){
			int sum=a[i]+carry;
			carry=sum/10;
			sum=sum%10;
			ans.push_back(sum);
			i--;
		}
		while(j>=0){
			int sum=b[j]+carry;
			carry=sum/10;
			int value=sum%10;
			ans.push_back(value);
			j--;
		}
		while(carry!=0){
			int sum=carry;
			carry=sum/10;
			sum=sum%10;
			ans.push_back(sum);
		}
		return reverse(ans);		
}

// Check if the string is a palindrome

#include <bits/stdc++.h> 

string toLowerCase(string s){
    int i=0,j=s.size()-1;
    string str="";

    while(i<=j){
        if((s[i]>='a' && s[i]<='z') || (s[i]>='0' && s[i]<='9')){
            str+=s[i++];
        }
        else if((s[i]>='A' && s[i]<='Z')){
            str+=s[i++]-'A'+'a';
        }
        else{
            i++;
        }
    }
    return str;
}

bool checkPalindrome(string s)
{
    string str=toLowerCase(s);
    int n=str.size();
    int i=0,j=n-1;
    bool ans=true;
    while(i<=j){
        if(str[i]==str[j]){
            i++;
            j--;
        }
        else{
            ans=false;
            break;
        }
    }
    return ans;
}

// Valid palindrome

class Solution {
public:
    bool isPalindrome(string s) {
        string str="";
        for(int i=0;i<s.size();i++){
            if(isalnum(s[i])) 
                str+=tolower(s[i]);
        }
        string y=str;
        reverse(str.begin(),str.end());
        int i=0,j=0;
        while(i<str.size() && j<y.size()){
            if(str[i]!=y[j]){
                return false;
            }
            else{
                i++;
                j++;
            }
        }
        return true;
    }
};

// Reverse words in a string II

class Solution {
public:
    void reverseWords(vector<char>& s) {
        int i = 0, N = s.size();
        while (i < N) {
            int start = i;
            while (i < N && s[i] != ' ') ++i;
            reverse(begin(s) + start, begin(s) + i);
            ++i;
        }
        reverse(begin(s), end(s));
    }
};

// Maximum occuring character

//{ Driver Code Starts
#include<bits/stdc++.h>
using namespace std;


// } Driver Code Ends


class Solution
{
    public:
    char getMaxOccuringChar(string str)
    {
        int arr[26] = {0};
        for (int i = 0; i < str.length(); i++)
        {
            char ch = str[i];
            int number = 0;
            number = ch - 'a';
            arr[number]++;
        }
        int maxi = -1, ans = 0;
        for (int i = 0; i < 26; i++)
        {
            if (maxi < arr[i])
            {
                ans = i;
                maxi = arr[i];
            }
        }
        return 'a' + ans;
    }

};

//{ Driver Code Starts.

int main()
{
   
    int t;
    cin >> t;
    while(t--)
    {
        string str;
        cin >> str;
    	Solution obj;
        cout<< obj.getMaxOccuringChar(str)<<endl;
    }
}
// } Driver Code Ends

// Remove all occurrences of substring

#include <bits/stdc++.h> 
string replaceSpaces(string &str){
	string ch="@40";
	int i=0;
	while(i<=str.length()){
		if(str[i]==' '){
			str.replace(i,1,ch);
		}
		i++;
	}
	return str;
}

// Remove all adjacent duplicates

class Solution {
public:
    string removeDuplicates(string s) {
        string ans = "";
        for(int i = 0; i < s.length(); i++){
            if(ans == ""){
                ans.push_back(s[i]);
            }
            else if(ans.back()==s[i]){
                ans.pop_back();
            }
            else{
                ans.push_back(s[i]);
            }
        }
        return ans;
    }
};


// String Compression

class Solution {
public:
    int compress(vector<char>& chars) {
        int n=chars.size();
        int i=0,j=0;
        while(j<n){
            int c=0;
            char current_char=chars[j];
            while(j<n && chars[j]==current_char){
                c++;
                j++;
            }
            chars[i++]=current_char;
            if(c>1){
                string count=to_string(c);
                for(auto p:count){
                    chars[i++]=p;
                }
            }

        }
         return i;
    }
};

// Permutation in Strings

class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        int s1_len=s1.size();
        int s2_len=s2.size();
        if(s1_len>s2_len)
        {
            return false;
        }
        sort(s1.begin(),s1.end());
        for(int i=0;i<=(s2_len-s1_len);i++)
        {
            string p=s2.substr(i,s1_len);
            sort(p.begin(),p.end());
            if(p==s1)
            {
                return true;
            }
        }
        return false;
    }
};

// Remove adjacent Duplicates 

class Solution {
public:
    string removeDuplicates(string s) {
        string ans = "";
        for(int i = 0; i < s.length(); i++){
            if(ans == ""){
                ans.push_back(s[i]);
            }
            else if(ans.back()==s[i]){
                ans.pop_back();
            }
            else{
                ans.push_back(s[i]);
            }
        }
        return ans;
    }
};

// Linear Search

#include<iostream>
using namespace std;
int main(){
    int n;
    cin>>n;
    int arr[n];
    for (int i = 0; i < n; i++)
    {
        cin>>arr[i];
    }
    int search;
    cin>>search;
    for (int i = 0; i < n; i++)
    {
        if(arr[i]==search){
            cout<<search<<" element is found"<<" at "<< i <<" index"<<endl;
        }
    }
    return 0;
}

// Row-wise sum

#include<iostream>
using namespace std;
int main(){
    int n,m;
    cin>>n>>m;
    int arr[n][m];
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin>>arr[i][j];
        }
    }
    for (int i = 0; i < n; i++)
    {
        int sum=0;
        for (int j = 0; j < m; j++)
        {
            sum+=arr[i][j];
        } 
        cout<<sum<<" ";
    }
    cout<<endl;
    return 0;
}

// Column-wise sum

#include<iostream>
using namespace std;
int main(){
    int n,m;
    cin>>n>>m;
    int arr[n][m];
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin>>arr[i][j];
        }
    }
    for (int j = 0; j < m; j++)
    {
        int sum=0;
        for (int i = 0; i < n; i++)
        {
            sum+=arr[i][j];
        } 
        cout<<sum<<" ";
    }
    cout<<endl;
    return 0;
}

// Largest Row Sum

#include<iostream>
#include<climits>
using namespace std;
int main(){
    int n,m;
    cin>>n>>m;
    int arr[n][m];
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin>>arr[i][j];
        }
    }
    int max=INT_MIN;
    int RowIndex=-1;
    for (int i = 0; i < n; i++)
    {
        int sum=0;
        for (int j = 0; j < m; j++)
        {
            sum+=arr[i][j];
        }
        if(sum>max){
            max=sum;
            RowIndex=i;
        }
    }
    cout<<max<<endl;
    cout<<RowIndex<<endl;
    return 0;
}

// Wave Print

#include <bits/stdc++.h> 
vector<int> wavePrint(vector<vector<int>> arr, int nRows, int mCols)
{
    vector<int> ans;
    for(int j=0;j<mCols;j++){
        if(j&1){
            for(int i=nRows-1;i>=0;i--)
                ans.push_back(arr[i][j]);
        }
        else{
            for(int i=0;i<nRows;i++)
                ans.push_back(arr[i][j]);
        }
    }
    return ans;
}

// Spiral Matrix

class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> ans;
        int row=matrix.size();
        int col=matrix[0].size();
        int count=0;
        int total=row*col;
        // Indexes
        int startingRow=0;
        int startingCol=0;
        int endingRow=row-1;
        int endingCol=col-1;
        while(count<total){
            for (int index = startingCol; count<total && index <= endingCol ; index++)
            {
                ans.push_back(matrix[startingRow][index]);
                count++;
            }
            startingRow++;
            for (int index = startingRow; count<total && index <= endingRow ; index++)
            {
                ans.push_back(matrix[index][endingCol]);
                count++;
            }
            endingCol--;
            for (int index = endingCol; count<total && index >= startingCol ; index--)
            {
                ans.push_back(matrix[endingRow][index]);
                count++;
            }
            endingRow--;
            for (int index = endingRow; count<total && index >= startingRow ; index--)
            {
                ans.push_back(matrix[index][startingCol]);
                count++;
            }
            startingCol++;
        }
        return ans;
    }
};

// Rotate Image

class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n; i++) {
            for (int j = i+1; j < n; j++) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        for(int k=0;k<n;k++){
            reverse(matrix[k].begin(), matrix[k].end());
        }
    }
};

// Search in a 2D Matrix

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row=matrix.size();
        int col=matrix[0].size();
        int start=0,end=(row*col)-1,mid=start+(end-start)/2;
        while(start<=end){
            int element=matrix[mid/col][mid%col];
            if(element<target){
                start=mid+1;
            }
            else if(element==target){
                return 1;
            }
            else{
                end=mid-1;
            }
            mid=start+(end-start)/2;
        }
        return 0;
    }
};

// Search in a 2D Matrix II

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row=matrix.size();
        int col=matrix[0].size();
        
        int RowIndex=0;
        int ColIndex=col-1;
        
        while(RowIndex<row && ColIndex>=0){
            int element=matrix[RowIndex][ColIndex];
            if(element<target){
                RowIndex++;
            }
            else if(element==target){
                return 1;
            }
            else{
                ColIndex--;
            }
        }
        return 0;
    }
};

// Count prime(Sieve of Eratosthenes)

class Solution {
public:
    int countPrimes(int n) {
        int count=0;
        vector<bool> prime(n+1,true);
        
        prime[0]=prime[1]=false;
        
        for(int i=2;i<n;i++){
            if(prime[i]){
               count++; 
            }
            for(int j=2*i;j<n;j=j+i){
                prime[j]=0;
            }
        }
        return count;
    }
};

// Segmented Sieve

class Solution{
public:
    bool isPrime(long long int n)
    {
        if(n<=1){
           return false;
        }
        for(int i=2 ; i*i<=n ; i++){
            if(n%i == 0){
               return false ;
            }
        }
        return true ;
    }
    long long primeProduct(long long L, long long R){
        long long int ans=1;
        int count=0;
        long long int num=pow(10,9) + 7; 
        for(int i=L; i<=R; i++){
            if(isPrime(i)){
                count++;
                ans=(ans*i)%num;
            }
        }
       if(count==0){
           return 1;
       }
       return ans;
    }
};

// GCD

#include<iostream>
using namespace std;
int gcd(int a,int b){
    if(a==0)
    	return b;
    else if(b==0)
    	return a;
    while(a!=b){
    	if(a>b)
	    a=a-b;
	else   
	    b=b-a;
        }
    return a;
}
int main(){
    int a,b;
    cin>>a>>b;
    cout<<"Gcd of "<<a<<" and "<<b<<" is "<<gcd(a,b);
    return 0;
}

// LCM

#include<iostream>
using namespace std;
int main(){
    int a,b,gcd,temp,lcm;
    cin>>a>>b;
    gcd=a;
    temp=b;
    while(gcd!=lcm){
        if(gcd>temp)
            gcd=gcd-temp;
        else
            temp=temp-gcd;
    }
    lcm=(a*b)/gcd;
    return 0;
}

// Modular Exponentiation

#include <bits/stdc++.h>  
int modularExponentiation(int x, int n, int m) {
	int result=1;
	while(n>0){
		if(n&1){
			result=(1LL*(result)*(x))%m;
		}
		x=(1LL*(x)*(x))%m;
		n=n>>1;
	}
	return result;
}

// Pigeon Hole Principle - If there are n+1 number of pigeons and n number of pigeonholes there is must be atleast one pigeonhole which contain atleast two pigeons.

// Catalan Number - Catalan numbers are defined as a mathematical sequence that consists of positive integers, which can be used to find the number of possibilities of various combinations. Cn = 1/(n+1)(2nCn) = Submission[CiCn-i] , i=0 to n-1

#include <iostream>
using namespace std;
unsigned long int catalan(unsigned int n)
{
    if (n <= 1)
        return 1;
    // catalan(n) is sum of
    // catalan(i)*catalan(n-i-1)
    unsigned long int res = 0;
    for (int i = 0; i < n; i++)
        res += catalan(i) * catalan(n - i - 1);
    return res;
}
int main()
{
    for (int i = 0; i < 10; i++)
        cout << catalan(i) << " ";
    return 0;
}

// Inclusion-Exclusion Principle - 

// Chinese Remainder Theorem -
     We are given two arrays num[0..k-1] and rem[0..k-1]. In num[0..k-1], every pair is coprime (gcd for every pair is 1). We need to find minimum positive number x such that: 
     
     x % num[0]    =  rem[0], 
     x % num[1]    =  rem[1], 
     .......................
     x % num[k-1]  =  rem[k-1]
     
     Basically, we are given k numbers which are pairwise coprime, and given remainders of these numbers when an unknown number x is divided by them. We need to find the minimum possible value of x that produces given remainders.
Examples : 
 

Input:  num[] = {5, 7}, rem[] = {1, 3}
Output: 31
Explanation: 
31 is the smallest number such that:
  (1) When we divide it by 5, we get remainder 1. 
  (2) When we divide it by 7, we get remainder 3.

Input:  num[] = {3, 4, 5}, rem[] = {2, 3, 1}
Output: 11
Explanation: 
11 is the smallest number such that:
  (1) When we divide it by 3, we get remainder 2. 
  (2) When we divide it by 4, we get remainder 3.
  (3) When we divide it by 5, we get remainder 1.

#include<bits/stdc++.h>
using namespace std;
// k is size of num[] and rem[]. Returns the smallest number x such that:
// x % num[0] = rem[0],
// x % num[1] = rem[1],
// ..................
// x % num[k-2] = rem[k-1]
// Assumption: Numbers in num[] are pairwise coprime
// (gcd for every pair is 1)
int findMinX(int num[], int rem[], int k)
{
	int x = 1; // Initialize result
	// As per the Chinese remainder theorem, this loop will always break.
	while (true)
	{
		// Check if remainder of x % num[j] is rem[j] or not (for all j from 0 to k-1)
		int j;
		for (j=0; j<k; j++ )
			if (x%num[j] != rem[j])
			break;
		// If all remainders matched, we found x
		if (j == k)
			return x;
		// Else try next number
		x++;
	}
	return x;
}
int main(void)
{
	int num[] = {3, 4, 5};
	int rem[] = {2, 3, 1};
	int k = sizeof(num)/sizeof(num[0]);
	cout << "x is " << findMinX(num, rem, k);
	return 0;
}
  
// Lucas Theorem
// Fermat's Little Theorem
// Probability Equation

// Factorial of a  Large Number

class Solution {
public:
    vector<int> factorial(int N){
         vector<int> res;
         res.push_back(1);
         
         for(int x=2;x<=N;x++){
             int car=0;
             for(int i=0;i<res.size();i++){
                 int val = res[i]*x+car;
                 res[i]=val %10;
                 car=val/10;
             }
             while(car!=0){
                 res.push_back(car%10);
                 car/=10;
             }
         }
         reverse(res.begin(),res.end());
         return res;
    }
};

// Factorial using recursion

// #include<iostream>
// using namespace std;
// int factorial(int n){
//     if(n==0 || n==1){
//         return 1;
//     }
//     else{
//         return n*factorial(n-1);
//     }
// }
// int main(){
//     int n;
//     cout<<"Enter the number:";
//     cin>>n;
//     cout<<factorial(n);
//     return 0;
// }

// Power of 2 using recursion

// #include<iostream>
// using namespace std;
// int power(int n){
//     if(n==0){
//         return 1;
//     }
//     else{
//         return 2*power(n-1);
//     }
// }
// int main(){
//     int n;
//     cout<<"Enter the number:";
//     cin>>n;
//     cout<<power(n);
//     return 0;
// }

// Print counting using recursion

// #include<iostream>
// using namespace std;
// void Print(int n){
//     if(n==0){
//         return;
//     }
//     Print(n-1);
//     cout<<n<<" ";
// }
// int main(){
//     int n;
//     cout<<"Enter the number:";
//     cin>>n;
//     Print(n);
//     return 0;
// }

// Reach Home using recursion

// #include<iostream>
// using namespace std;
// void target(int src,int dest){
//     cout<<"source "<<src<<" destination "<<dest<<endl;
//     if(src==dest){
//         cout<<"Reached Home"<<endl;
//         return;
//     }
//     src++;
//     target(src,dest);
// }
// int main(){
//     int dest,src=1;
//     cout<<"Enter the destination:";
//     cin>>dest;
//     target(src,dest);
//     return 0;
// }

// Fibonacci Number

// class Solution {
// public:
//     int fib(int n) {
//         if(n==0){
//             return 0;
//         }
//         if(n==1){
//             return 1;
//         }
//         else{
//             return fib(n-1)+fib(n-2);
//         }
//     }
// };

// Count Ways To Reach The N-th Stairs

// #include <bits/stdc++.h>
// #define mod 1000000007
// int countDistinctWays(int nStairs) {
//     int n=nStairs;
//     int prev1=1;
//     int prev2=1;
//     int curr;
//     if(n==1 || n==0)
//         return 1;
//     for(int i=2;i<=n;i++){
//         curr=(prev1+prev2)%mod;
//         prev1=prev2;
//         prev2=curr;
//     }
//     return curr%mod;
// }

// Say digits

// Four One Two
// #include<iostream>
// using namespace std;
// void digit(string arr[],int n){
//     if(n==0){
//         return;
//     }
//     int r=n%10;
//     n=n/10;
//     digit(arr,n);
//     cout<<arr[r]<<" ";
// }
// int main(){
//     int n;
//     cout<<"Enter the number:";
//     cin>>n;
//     string arr[10]={"Zero","One","Two","Three","Four","Five","Six","Seven","Eight","Nine"};
//     digit(arr,n);
// }

// Two One Four
// #include<iostream>
// using namespace std;
// void digit(string arr[],int n){
//     if(n==0){
//         return;
//     }
//     int r=n%10;
//     n=n/10;
//     cout<<arr[r]<<" ";
//     digit(arr,n);
// }
// int main(){
//     int n;
//     cout<<"Enter the number:";
//     cin>>n;
//     string arr[10]={"Zero","One","Two","Three","Four","Five","Six","Seven","Eight","Nine"};
//     digit(arr,n);
// }

// Sorting using recursion

// #include<iostream>
// using namespace std;
// bool Sorted(int arr[],int n){
//     if(n==0 || n==1){
//         return true;
//     }
//     if(arr[0]>arr[1]){
//         return false;
//     }
//     else{
//         bool ans=Sorted(arr+1,n-1);;
//         return ans;
//     }
// }
// int main(){
//     int n;
//     cout<<"Enter the size of the array:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     int ans=Sorted(arr,n);
//     if(ans){
//         cout<<"Array is sorted";
//     }
//     else{
//         cout<<"Array is not sorted";
//     }
//     return 0;
// }

// Sum of array using recursion

// #include<iostream>
// using namespace std;
// int sum(int arr[],int n){
//     if(n==0){
//         return 0;
//     }
//     if(n==1){
//         return arr[0];
//     }
//     else{
//         int leftover=sum(arr+1,n-1);
//         int ans=arr[0]+leftover;
//         return ans;
//     }
// }
// int main(){
//     int n;
//     cout<<"Enter the number:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the size of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     cout<<sum(arr,n);
//     return 0;
// }

// Linear search using recursion

// #include<iostream>
// using namespace std;
// bool LinearSearch(int arr[],int n,int search){
//     if(n==0){
//         return false;
//     }
//     if(arr[0]==search){
//         return true;
//     }
//     else{
//         bool leftover=LinearSearch(arr+1,n-1,search);
//         return leftover;
//     }
// }
// int main(){
//     int n;
//     cout<<"Enter the size of the array:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     int search;
//     cout<<"Enter the element you want to search for:";
//     cin>>search;
//     bool ans=LinearSearch(arr,n,search);
//     if(ans){
//         cout<<"Element "<<search<<" is present in the array";
//     }
//     else{
//         cout<<"Element "<<search<<" is not present in the array";
//     }
//     return 0;
// }

// Binary search using recursion

// #include<iostream>
// using namespace std;
// bool BinarySearch(int arr[],int start,int end,int search){
//     if(start>end){
//         return false;
//     }
//     int mid=start+(end-start)/2;
//     if(arr[mid]==search){
//         return true;
//     }
//     if(arr[mid]<search){
//         return BinarySearch(arr,mid+1,end,search);
//     }
//     else{
//         return BinarySearch(arr,start,mid-1,search);
//     }
// }
// int main(){
//     int n;
//     cout<<"Enter the size of the array:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     int search;
//     cout<<"Enter the element you want to search for:";
//     cin>>search;
//     bool ans=BinarySearch(arr,0,n-1,search);
//     if(ans){
//         cout<<"Element "<<search<<" is present in the array";
//     }
//     else{
//         cout<<"Element "<<search<<" is not present in the array";
//     }
//     return 0;
// }

// BinarySearch using recursion(CS)

// int BinarySearch(int arr[],int s,int e,int k){
//     int mid=s+(e-s)/2;
//     if(s>e){
//         return -1;
//     }
//     if(arr[mid]==k){
//         return mid;
//     }
//     if(arr[mid]<k){
//         return BinarySearch(arr, mid+1, e, k);
//     }
//     else{
//         return BinarySearch(arr,s,mid-1,k);
//     }
// }
// int binarySearch(int *input, int n, int val)
// {
//     int ans=BinarySearch(input, 0, n-1, val);
//     return ans;
// }

// Reverse string using recursion

// #include<iostream>
// #include<algorithm>
// using namespace std;
// void ReverseString(string &str,int s,int e){
//     if(s>e){
//         return;
//     }
//     swap(str[s++],str[e--]);
//     ReverseString(str,s,e);
// }
// int main(){
//     string str;
//     cout<<"Enter the string:";
//     cin>>str;
//     ReverseString(str,0,str.length()-1);
//     cout<<str;
//     return 0;
// }

// #include<iostream>
// #include<algorithm>
// using namespace std;
// void ReverseString(string &str,int s){
//     int l=str.length()-s-1;
//     if(s>=l){
//         return;
//     }
//     swap(str[s++],str[l--]);
//     ReverseString(str,s);
// }
// int main(){
//     string str;
//     cout<<"Enter the string:";
//     cin>>str;
//     ReverseString(str,0);
//     cout<<str;
//     return 0;
// }

// Check Palindrome

// #include<iostream>
// #include<algorithm>
// using namespace std;
// bool CheckPalindrome(string &str,int s,int e){
//     if(s>e){
//         return true;
//     }
//     if(str[s]!=str[e]){
//         return false;
//     }
//     else{
//         return CheckPalindrome(str,s+1,e-1);
//     }
// }
// int main(){
//     string str;
//     cin>>str;
//     bool ans=CheckPalindrome(str,0,str.length()-1);
//     if(ans){
//         cout<<"String is a palindorme";
//     }
//     else{
//         cout<<"String is not a palindrome";
//     }
//     return 0;
// }

// #include<iostream>
// #include<algorithm>
// using namespace std;
// bool CheckPalindrome(string &str,int s){
//     int l=str.length()-s-1;
//     if(s>l){
//         return true;
//     }
//     if(str[s++]==str[l--]){
//          return CheckPalindrome(str,s+1);
//     }
//     else{
//        return false;
//     }
// }
// int main(){
//     string str;
//     cin>>str;
//     bool ans=CheckPalindrome(str,0);
//     if(ans){
//         cout<<"String is a palindorme";
//     }
//     else{
//         cout<<"String is not a palindrome";
//     }
//     return 0;
// }

// Power using recursion

// #include<iostream>
// #include<algorithm>
// using namespace std;
// int power(int b,int e){
//     if(e==0){
//         return 1;
//     }
//     if(e==1){
//         return b;
//     }
//     int ans = power(b,e/2);
//     if(e%2==0){
//         return ans*ans;
//     }
//     else{
//         return b*ans*ans;
//     }
// }
// int main(){
//     int b,e;
//     cout<<"Enter the values of base and exponent:";
//     cin>>b>>e;
//     int ans=power(b,e);
//     cout<<ans;
//     return 0;
// }

// Bubble sort using recursion

// #include<iostream>
// #include<algorithm>
// using namespace std;
// void BubbleSort(int arr[],int n){
//     if(n==0 || n==1){
//         return;
//     }
//     for(int i=0;i<n;i++){
//         if(arr[i]>arr[i+1]){
//             swap(arr[i],arr[i+1]);
//         }
//     }
//     BubbleSort(arr,n-1);
// }
// int main(){
//     int n;
//     cout<<"Enter the size of the array:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     BubbleSort(arr,n);
//     for (int i = 0; i < n; i++)
//     {
//         cout<<arr[i]<<" ";
//     }
//     return 0;
// }

// Selection sort suing recursion

// #include<iostream>
// #include<algorithm>
// using namespace std;
// void SelectionSort(int arr[],int start,int n){
//     if(n<=start){
//         return;
//     }
//     int minIndex=start;
//     for(int i=start;i<n;i++){
//         if(arr[i]<arr[minIndex]){
//             minIndex=i;
//         }
//     }
//     swap(arr[minIndex],arr[start]);
//     SelectionSort(arr,start+1,n);
// }
// int main(){
//     int n;
//     cout<<"Enter the size of the array:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     SelectionSort(arr,0,n);
//     for (int i = 0; i < n; i++)
//     {
//         cout<<arr[i]<<" ";
//     }
//     return 0;
// }

// Insertion Sort using recursion

// #include<iostream>
// #include<algorithm>
// using namespace std;
// void InsertionSort(int arr[],int n){
//     if(n<=1){
//         return;
//     }
//     InsertionSort(arr,n-1);
//     int last=arr[n-1];
//     int j=n-2;
//     while(j>=0 && arr[j]>last){
//         arr[j+1]=arr[j];
//         j--;
//     }
//     arr[j+1]=last;
// }
// int main(){
//     int n;
//     cout<<"Enter the size of the array:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     InsertionSort(arr,n);
//     for (int i = 0; i < n; i++)
//     {
//         cout<<arr[i]<<" ";
//     }
//     return 0;
// }

// Merge Sort

// void merging(vector<int> &arr, int s, int e)
// {
//     int mid = s + (e - s) / 2;
//     int length1 = mid + 1 - s;
//     int length2 = e - mid;
//     int *arr1 = new int[length1];
//     int *arr2 = new int[length2];
//     int mainIndexArray = s;
//     for (int i = 0; i < length1; i++)
//     {
//         arr1[i] = arr[mainIndexArray++];
//     }
//     mainIndexArray = mid + 1;
//     for (int i = 0; i < length2; i++)
//     {
//         arr2[i] = arr[mainIndexArray++];
//     }
//     int index1 = 0;
//     int index2 = 0;
//     mainIndexArray = s;
//     while (index1 < length1 && index2 < length2)
//     {
//         if (arr1[index1] < arr2[index2])
//         {
//             arr[mainIndexArray++] = arr1[index1++];
//         }
//         else
//         {
//             arr[mainIndexArray++] = arr2[index2++];
//         }
//     }
//     while (index1 < length1)
//     {
//         arr[mainIndexArray++] = arr1[index1++];
//     }
//     while (index2 < length2)
//     {
//         arr[mainIndexArray++] = arr2[index2++];
//     }
// }
// void merge(vector<int> &arr, int s, int e)
// {
//     if (s >= e)
//     {
//         return;
//     }
//     int mid = s + (e - s) / 2;
//     merge(arr, s, mid);
//     merge(arr, mid + 1, e);
//     merging(arr, s, e);
// }
// void mergeSort(vector<int> &arr, int n) { merge(arr, 0, n - 1); }

// Quick Sort

// #include<iostream>
// #include<algorithm>
// using namespace std;
// int parts(int arr[],int s,int e){
//     int pivot=arr[s];
//     int count=0;
//     for (int i = s+1; i <= e ; i++)
//     {
//         if(arr[i]<= pivot){
//             count++;
//         }
//     }
//     int pivotIndex=s+count;
//     swap(arr[pivotIndex],arr[s]);
//     int i=s,j=e;
//     while(i<pivotIndex && j>pivotIndex){
//         while(arr[i]<pivot){
//             i++;
//         }
//         while(arr[i]>pivot){
//             j--;
//         }
//         if(i<pivotIndex && j>pivotIndex){
//             swap(arr[i++],arr[j--]);
//         }
//     }
//     return pivotIndex;
// }
// void QuickSort(int arr[],int s,int e){
//     if(s>=e){
//         return;
//     }
//     int p = parts(arr,s,e);
//     QuickSort(arr,s,p-1); 
//     QuickSort(arr,p+1,e); 
// }
// int main()
// {
//     int n;
//     cout << "Enter the size of the array:";
//     cin >> n;
//     int arr[n];
//     cout << "Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin >> arr[i];
//     }
//     QuickSort(arr, 0, n - 1);
//     for (int i = 0; i < n; i++)
//     {
//         cout << arr[i] << " ";
//     }
//     return 0;
// }

// Subsets using recursion

// class Solution {
// public:
//     void solve(vector<int> nums,vector<int> output,int index,vector<vector<int>> &ans){
//         if(index>=nums.size()){
//             ans.push_back(output);
//             return;
//         }
//         solve(nums,output,index+1,ans);
//         int element=nums[index];
//         output.push_back(element);
//         solve(nums,output,index+1,ans);
//     }
//     vector<vector<int>> subsets(vector<int>& nums) {
//         vector<vector<int>> ans;
//         vector<int> output;
//         int index=0;
//         solve(nums,output,index,ans);
//         return ans;
//     }
// };

// Subsets using Bit Manipulation

// #include <bits/stdc++.h>
// using namespace std;
// // Function to find all subsets of given set. Any repeated subset is considered only once in the output
// vector<vector<int> > findPowerSet(vector<int>& nums)
// {
// 	// Size of array to set bit
// 	int bits = nums.size();
// 	// Total number of subsets = pow(2, sizeof(arr))
// 	unsigned int pow_set_size = pow(2, bits);
// 	// Sort to avoid adding permutation of the substring
// 	sort(nums.begin(), nums.end());
// 	vector<vector<int> > ans;
// 	// To store subset as a list toavoid adding exact duplicates
// 	vector<string> list;
// 	// Counter 000..0 to 111..1
// 	for (int counter = 0; counter < pow_set_size;
// 		counter++) {
// 		vector<int> subset;
// 		string temp = "";
// 		// Check for the current bit in the counter
// 		for (int j = 0; j < bits; j++) {
// 			if (counter & (1 << j)) {
// 				subset.push_back(nums[j]);
// 				// Add special character to separate integers
// 				temp += to_string(nums[j]) + '$';
// 			}
// 		}
// 		if (find(list.begin(), list.end(), temp)
// 			== list.end()) {
// 			ans.push_back(subset);
// 			list.push_back(temp);
// 		}
// 	}
// 	return ans;
// }
// int main()
// {
// 	vector<int> arr{ 10, 12, 12 };
// 	vector<vector<int> > power_set = findPowerSet(arr);
// 	for (int i = 0; i < power_set.size(); i++) {
// 		for (int j = 0; j < power_set[i].size(); j++)
// 			cout << power_set[i][j] << " ";
// 		cout << endl;
// 	}
// 	return 0;
// }

// Subsequences of String using Recursion

// #include <bits/stdc++.h>
// using namespace std;
// void solve(string str, string output, int index, vector<string> &ans) {
//   // base case
//   if (index >= str.length()) {
//     if (output.length() > 0) {
//       ans.push_back(output);
//     }
//     return;
//   }
//   // exclude
//   solve(str, output, index + 1, ans);
//   // include
//   char element = str[index];
//   output.push_back(element);
//   solve(str, output, index + 1, ans);
// }
// vector<string> subsequences(string str) {
//   // Write your code here
//   vector<string> ans;
//   string output = "";
//   int index = 0;
//   solve(str, output, index, ans);
//   return ans;
// }

// Subsequences of String using Bit Manipulation

// #include<bits/stdc++.h>
// using namespace std;
// string print(string s , int i){
// 	int j = 0;
// 	string sub;
// 	//finding where the bit is set
// 	while(i>0){
// 		if(i & 1){
// 			sub.push_back(s[j]); //pushing only when bit is set
// 		}
// 		j++; //always incrementing the index pointer
// 		i = i >> 1;
// 	}	
// 	return sub;
// }
// vector<string> createsubsets(string& s){	
// 	vector <string> res;
// 	for(int i = 1 ; i <= ((1 << s.size()) - 1) ; i++){
// 		//each time we create a subsequence for corresponding binary representation
// 		res.push_back(print(s,i));
// 	}
// 	return res;
// }
// int main(){
// 	string s = "abc";
// 	//vector of strings to store all sub-sequences
// 	vector <string> print = createsubsets(s);	
// 	//print function
// 	for(int i = 0 ; i < print.size() ; i++){
// 		for (int j = 0; j < print[i].size(); j++){
// 			cout << print[i][j]<<" ";
// 		}
// 		cout << endl;
// 	}
// 	return 0;
// }

// Letter Combinations of a Phone Number(Phone Keypad Problem)

// class Solution {
// public:
//     void solve(string digits,string output,int index,vector<string> &ans,string mapping[]){
//         if(index>=digits.length()){
//             ans.push_back(output);
//             return;
//         }
//         int number=digits[index]-'0';
//         string value=mapping[number];
//         for(int i=0;i<value.length();i++){
//             output.push_back(value[i]);
//             solve(digits,output,index+1,ans,mapping);
//             output.pop_back();
//         }
//     }
//     vector<string> letterCombinations(string digits) {
//         vector<string> ans;
//         if(digits.length()==0){
//             return ans;
//         }
//         string output="";
//         int index=0;
//         string mapping[10]={""," ","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
//         solve(digits,output,index,ans,mapping);
//         return ans;
//     }
// };

// Permutations of a string

// class Solution {
// public:
//     void solve(vector<int>& nums,vector<vector<int>> &ans,int index){
//         if(index>=nums.size()){
//             ans.push_back(nums);
//             return;
//         }
//         for(int i=index;i<nums.size();i++){
//             swap(nums[i],nums[index]);
//             solve(nums,ans,index+1);
//             swap(nums[i],nums[index]);
//         }
//     }
//     vector<vector<int>> permute(vector<int>& nums) {
//         vector<vector<int>> ans;
//         int index=0;
//         solve(nums,ans,index);
//         return ans;
//     }
// };

// Rat in a Maze Problem - I

class Solution{
    private:
    bool safe(int x ,int y , int n , vector<vector<int>> visited ,vector<vector<int>> &m ){
        if( ( x >= 0 && x < n ) && ( y >= 0 && y < n ) && visited[x][y] == 0 && m[x][y] == 1){
            return true; 
        }
        else{
            return false;
        }
    }
    void solve(vector<vector<int>> &m , int n ,vector<string>& ans , int x , int y ,vector<vector<int>> visited , string path){
        //base case
        if( x == n - 1 && y == n - 1 ){
            ans.push_back(path);
            return ;
        }
        //when you cover that index
        visited[x][y] = 1;
        // their are  choices     
        // 1st is Down
        int newx = x + 1;
        int newy = y;
        if( safe( newx , newy , n ,visited , m)){
            path.push_back('D');
            solve( m , n , ans , newx , newy , visited , path);
            path.pop_back();
        }
        // 1st is Left
         newx = x;
         newy = y - 1;
        if( safe( newx , newy , n ,visited , m)){
            path.push_back('L');
            solve( m , n , ans , newx , newy , visited , path);
            path.pop_back();
        }
        // 1st is Right
        newx = x;
        newy = y + 1;
        if( safe( newx , newy , n ,visited , m)){
            path.push_back('R');
            solve( m , n , ans , newx , newy , visited , path);
            path.pop_back();
        }
        // 1st is Up
         newx = x - 1;
         newy = y;
        if( safe( newx , newy , n ,visited , m)){
            path.push_back('U');
            solve( m , n , ans , newx , newy , visited , path);
            path.pop_back();
        }
        visited[x][y] = 0;
    }
    public:
    vector<string> findPath(vector<vector<int>> &m, int n) {
        vector<string>ans ;
        if( m [0][0] == 0){
            return ans;
        }
        int srcx = 0;
        int srcy = 0;
        // Make a visited 2D vector
        vector<vector<int>> visited = m;
        // make it default by all indeces by 0
        for( int i = 0; i < n; i++){
            for( int j = 0; j < n; j++){
                visited [i][j] = 0;
            }
        }
        string path = "";
        solve( m , n , ans , srcx , srcy , visited , path);
        sort(ans.begin() , ans.end());
        return ans;
    }
};
    
/************************************************************

    Following is the linked list node structure.
    
    class Node 
    {
        public:
        int data;
        Node* next;

        Node(int data) 
        {
            this->data = data;
            this->next = NULL;
        }
    };
    
************************************************************/    
    
// Reverse a Linked List

LinkedListNode<int> *reverseLinkedList(LinkedListNode<int> *head) 
{
    if(head == NULL || head->next == NULL){
        return head;
    }
    LinkedListNode<int>* prev=NULL;
    LinkedListNode<int>* curr=head;
    LinkedListNode<int>* forw=NULL;
    while(curr!=NULL){
        forw=curr->next;
        curr->next=prev;
        prev=curr;
        curr=forw;
    }
    return prev;
}

// Reverse a Linked List(Recursively)

LinkedListNode<int> *rev(LinkedListNode<int> *head) {
	  if (head == NULL || head->next == NULL){
	    return head;
	  }
LinkedListNode<int> *chotaHead = rev(head->next);
	  head->next->next = head;
	  head->next = NULL;
	  return chotaHead;
}
LinkedListNode<int> *reverseLinkedList(LinkedListNode<int> *head) {
    return rev(head);
}

// Reverse a Doubly Linked List

Node* reverseDLL(Node * head){
    Node *prev = NULL;
    Node *curr = head;
    Node *temp=NULL;
    while(curr!=NULL){
        temp = curr->prev;
        curr->prev = curr->next;
        curr->next = temp;
        prev = curr;
        curr = curr->prev;
    }
    return prev;
}

// Middle of a Linked List

int getLength(Node *head){
    int ans=0;
    while(head){
        ans++;
        head=head->next;
    }
    return ans;
}
Node *findMiddle(Node *head) {
    int n=getLength(head);
    int t=n/2;
    Node *ans=head;
    while(t--){
        ans=ans->next;
    }
    return ans;
}

// Reverse Nodes In K-Group

Node *krevgroup(Node *head, int n, int b[], int i)
{
    if (n<1 || head == NULL || head->next == NULL){
        return head;
    }
    Node *prev = NULL;
    Node *curr = head;
    Node *nxt = NULL;
    int cnt = 0;
    while(b[i] == 0 && i < n){ 
    	i++;
    }
    while (curr != NULL && cnt < b[i] && i < n  ){
        nxt = curr->next;
         curr->next = prev;
        prev = curr;
        curr = nxt;
        cnt++;
    }
    if (i >= n && curr != NULL){
        return head;
    }
    if (curr != NULL)
        head->next = krevgroup(nxt, n, b, i + 1);
    return prev;
}
Node *getListAfterReverseOperation(Node *head, int n, int b[]){
	return krevgroup(head,n,b,0);
}

// Circularly LinkedList

// Method-1
bool isCircularList(Node *head){
    //empty list
    if(head==NULL){
    	return head;
    }
    Node *temp=head->next;
    while(temp!=NULL && temp!=head){
          temp=temp->next;
    }
    if(temp==head){
          return true;
    }
    return false;
}

// Method-2
bool isCircular(Node* head){
    if(head==NULL){
        return 1;
    }
    Node* slow=head;
    Node* fast=head;
    while(fast!=NULL && fast->next!=NULL){
        slow=slow->next;
        fast=fast->next->next;
        if(slow==fast){
            if(slow==head){
                return 1;
            }
            else{
                return 0;
            }
        }
    }
    return 0;
}

// Method-3
bool hasCycle(ListNode *head){
	unordered_map<ListNode*,bool>map;
	ListNode *temp=head;
	while(temp!=NULL){
		if(map.find(temp)!=map.end())
			return ttrue;
		map[temp]=true;
		temp=temp->next;
	}
	return false;
}

// Detect and Remove Loop

// Method-1 for detection of loop
bool detectLoop(Node *head){
	if(head==NULL) return false;
	map<Noode*,bool> visited;
	Node *temp=head;
	while(temp!=NULL){
		if(visited[temp]==true){
			return true;
		}
		visited[temp]=true;
		temp=temp->next;
	}
	return false;
}

//this is to find cycle in the loop
Node* floydCycle(Node* head)
{
    if(head == NULL){
        return NULL;
    }
    Node* slow = head;
    Node* fast = head;
    while(slow!=NULL && fast!=NULL){
        fast = fast->next;
        if(fast!=NULL){
            fast = fast->next;
        }
        slow = slow->next;
        if(slow == fast){
            return slow;
        }
    }
    return NULL;
}
//this is to find first element from where loop started 
Node* loopFind(Node* head){
    if(head == NULL){
        return NULL;
    }
    Node* meet = floydCycle(head);
    if(meet == NULL){
        return NULL;
    }
    Node* slow = head;
    while(slow!= meet){
        slow = slow->next;
        meet = meet->next;
    }
    return slow;
}
//this is to remove the loop
Node *removeLoop(Node *head){
    if(head == NULL){
        return NULL;
    }
    Node* startLoop = loopFind(head);
    if(startLoop == NULL){
        return head;
    }
    Node* temp = startLoop;
    while(temp->next!= startLoop){
        temp = temp->next;
    }
    temp->next = NULL;
    return head;
}

// Remove Duplicates From a Sorted Linked List

Node * uniqueSortedList(Node * head) {
    if(head==NULL) return NULL;
    Node* curr=head;
    while(curr!=NULL){
        if(curr->next!=NULL && curr->data==curr->next->data){
            Node* next_next=curr->next->next;
            Node* nodeToDelete=curr->next;
            delete(nodeToDelete);
            curr->next= next_next;
        }
        else{
            curr=curr->next; 
        }
    }
    return head;
}

// Remove Duplicates from a Unsorted Linked List

// Method-1[Brute Force(T.C --> O(n^2),S.C --> O(1))]
Node *removeDuplicates(Node *head)
{
    if(head == NULL) return NULL;
    Node* curr = head;
    while(curr != NULL) {
        Node* temp = curr;
        while(temp -> next != NULL) {
            if(curr -> data == temp -> next -> data){
                Node* next_next = temp -> next -> next;
                Node* nodeToDelete = temp -> next;
                nodeToDelete -> next = NULL;
                delete nodeToDelete;
                temp -> next = next_next;
            }
            else
                temp = temp -> next;
        }
        curr = curr -> next;
    }
    return head;
}

// Method-2
Node *removeDuplicates(Node *head)
{
    if( head == NULL){
        return NULL;
    }
    unordered_map< int, bool> visited;
    Node *curr = head;
    while( curr -> next != NULL){
        visited[curr -> data ] = true;
        if( visited[curr -> next -> data] == true){
            curr -> next = curr -> next -> next;
        }
        else{
            curr = curr -> next;
        }
    }
    return head;
}

// Method-3(sort then use above question approach)

// Split LinkedList in two halves

void splitList(Node *head, Node **head1_ref, Node **head2_ref)
{
    // using two pointer approach fast and slow which is used to calculate middle node
    Node *fast=head->next;
    Node *slow = head;
    
    while(fast->next!=head){
        fast=fast->next;
        if(fast->next!=head){
            fast=fast->next;
        }
        slow=slow->next;
    }
    Node* temp=slow->next;
    slow->next=head;
    fast->next=temp;
    *head1_ref=head;
    *head2_ref=temp;
}

// Split Linked List in parts
		
class Solution {
public:
    vector<ListNode*> splitListToParts(ListNode* head, int k) {
        vector<ListNode*> ans;
        int len=0;
        ListNode *temp=head;
        while(temp!=NULL)
        {
            len++;
            temp=temp->next;
        }
        int size=len/k;
        int rem=len%k;
        temp=head;
        for(int i=0;i<k;i++)
        {
            ListNode *end=temp;
            if(rem>0)
            {
                int c=size;
                while(c--)
                {
                    end=end->next;
                }
                ListNode *x=end->next;
                end->next=NULL;
                ans.push_back(temp);
                temp=x;
                rem--;
            }
            else
            {
                if(size==0)
                {
                    ans.push_back(NULL);    
                }
                else
                {
                    int c=size-1;
                    while(c--)
                    {
                        end=end->next;
                    }
                    ListNode*x=end->next;
                    end->next=NULL;
                    ans.push_back(temp);
                    temp=x;
                }
            }
        }
        return ans;
    }
};	

// Sort 0s,1s and 2s in Linked List

// Method 1
class Solution
{
    public:
    //Function to sort a linked list of 0s, 1s and 2s.
    Node* segregate(Node *head) {
        int zeroCount=0,oneCount=0,twoCount=0;
        Node *temp=head;
        while(temp!=NULL){
            if(temp->data==0) zeroCount++;
            else if(temp->data==1) oneCount++;
            else if(temp->data==2) twoCount++;
            temp=temp->next;
        }
        temp=head;
        while(temp!=NULL){
            if(zeroCount!=0){
                temp->data=0;
                zeroCount--;
            }
            else if(oneCount!=0){
                temp->data=1;
                oneCount--;
            }
            else if(twoCount!=0){
                temp->data=2;
                twoCount--;
            }
            temp=temp->next;
        }
        return head;
    }
};

// Method 2
class Solution
{
    public:
    void insertAtTail(Node *&tail,Node *curr){
        tail->next=curr;
        tail=curr;
    }
    Node* segregate(Node *head) {
        Node *zeroHead=new Node(-1);
        Node *zeroTail=zeroHead;
        Node *oneHead=new Node(-1);
        Node *oneTail=oneHead;
        Node *twoHead=new Node(-1);
        Node *twoTail=twoHead;
        Node *curr=head;
        // created seperate list of 0s,1s and 2s
        while(curr!=NULL){
            int val=curr->data;
            if(val==0) insertAtTail(zeroTail,curr);
            else if(val==1) insertAtTail(oneTail,curr);
            else if(val==2) insertAtTail(twoTail,curr);
            curr=curr->next;
        }
        // merging above list
        if(oneHead->next!=NULL){
            zeroTail->next=oneHead->next;
        }
        else{
            zeroTail->next=twoHead->next;   
        }
        oneTail->next=twoHead->next;
        twoTail->next=NULL;
        // setup head
        head=zeroHead->next;
        // delete dummy nodes
        delete zeroHead;
        delete oneHead;
        delete twoHead;
        return head;
    }
};

// Merge two sorted arrays in a Linked List

Node<int>* solve( Node<int>* first , Node<int>* second){

    if( first -> next == NULL){
        first -> next = second;
        return first;
    }
    Node<int>* curr1 = first;
    Node<int>* next1 = curr1 -> next;
    Node<int>* curr2 = second;
    Node<int>* next2 = curr2 -> next;
    while( next1 != NULL and curr2 != NULL){
        if( (curr2 -> data >= curr1 -> data) and (curr2 -> data <= next1 -> data)){
            curr1 -> next = curr2;
            next2 = curr2 -> next;
            curr2 -> next = next1;
            curr1 = curr2;
            curr2 = next2;
        }
        else{
            curr1 = next1;
            next1 =  next1 -> next;

            if( next1 == NULL){
                curr1 -> next = curr2;
                return first;
            }
        }
    }
    return first;
}

Node<int>* sortTwoLists(Node<int>* first, Node<int>* second)
{
    if(first == NULL){
        return second;
    }
    if(second == NULL){
        return first;
    }

    if( first -> data <= second -> data){
        return solve( first , second );
    }
    else{
        return solve( second , first );
    }
}

// using recursion
Node<int>* sortTwoLists(Node<int>* first, Node<int>* second)
{
    if(first==NULL){
        return second;
    }
    if (second=NULL) {
        return first;
    }
    if(first->data<=second->data){
        first->next=sortTwoLists(first->next,second);
        return first;
    }
    else{
        second->next=sortTwoLists(first,second->next);
        return second;
    }
}

// Linked List is Palindrome or not

// Method 1
#include<vector>
class Solution{
  public:
    bool checkPalindrome(vector<int> arr){
        int n=arr.size();
        int s=0,e=n-1;
        while(s<=e){
            if(arr[s]!=arr[e]){
                return 0;
            }
            s++;
            e--;
        }
        return 1;
    }
    bool isPalindrome(Node *head)
    {
        vector<int> arr;
        Node *temp=head;
        while(temp!=NULL){
            arr.push_back(temp->data);
            temp=temp->next;
        }
        return checkPalindrome(arr);
    }
};

// Method 2
class Solution{
  public:
    Node *getMid(Node *head){
        Node *slow=head;
        Node *fast=head->next;
        while(fast!=NULL && fast->next!=NULL){
            fast=fast->next->next;
            slow=slow->next;
        }
        return slow;
    }
    Node *reverse(Node *head){
        Node *curr=head;
        Node *prev=NULL;
        Node *forward=NULL;
        while(curr!=NULL){
            forward=curr->next;
            curr->next=prev;
            prev=curr;
            curr=forward;
        }
        return prev;
    }
    bool isPalindrome(Node *head)
    {
        if(head->next==NULL){
            return true;    
        } 
        // find mid
        Node *mid=getMid(head);
        // reverse list after mid
        Node *temp=mid->next;
        mid->next=reverse(temp);
        // compare both halves
        Node *head1=head;
        Node *head2=mid->next;
        while(head2!=NULL){
            if(head1->data!=head2->data){
                return false;
            }
            head1=head1->next;
            head2=head2->next;
        }
        // form the same linkedlist given 
        temp=mid->next;
        mid->next=reverse(temp);
        return true;
    }
};

// Add two Numbers in a linked list

// Method-1
class Solution
{
    public:
    struct Node *reverse(Node *head){
        Node *curr=head;
        Node *prev=NULL;
        Node *forward=NULL;
        while(curr!=NULL){
            forward=curr->next;
            curr->next=prev;
            prev=curr;
            curr=forward;
        }
        return prev;
    }
    void insertAtTail(struct Node* &head, struct Node* &tail,int val){
        Node *temp=new Node(val);
        // empty list
        if(head==NULL){
            head=temp;
            tail=temp;
            return;
        }
        // non-empty list
        else{
            tail->next=temp;
            tail=temp;
        }
    }
    struct Node *add(struct Node* first, struct Node* second){
        Node *ansHead=NULL;
        Node *ansTail=NULL;
        int carry=0;
        while(first!=NULL && second!=NULL){
            int sum=carry+first->data+second->data;
            int digit=sum%10;
            // create node and add in answer linked list
            insertAtTail(ansHead,ansTail,digit);
            carry=sum/10;
            first=first->next;
            second=second->next;
        }
        while(first!=NULL){
            int sum=carry+first->data;
            int digit=sum%10;
            // create node and add in answer linked list
            insertAtTail(ansHead,ansTail,digit);
            carry=sum/10;
            first=first->next;
        }
        while(second!=NULL){
            int sum=carry+second->data;
            int digit=sum%10;
            // create node and add in answer linked list
            insertAtTail(ansHead,ansTail,digit);
            carry=sum/10;
            second=second->next;
        }
        while(carry!=0){
            int sum=carry;
            int digit=sum%10;
            // create node and add in answer linked list
            insertAtTail(ansHead,ansTail,digit);
            carry=sum/10;
        }
        return ansHead;
    }
    struct Node* addTwoLists(struct Node* first, struct Node* second)
    {
        // reverse the linked lists which are to be added
        first=reverse(first);
        second=reverse(second);
        // perform addition
        Node *ans=add(first,second);
        // reverse the answer linked list
        ans=reverse(ans);
        return ans;
    }
};

// Method-2(same method but less complicated)
class Solution
{
    public:
    struct Node *reverse(Node *head){
        Node *curr=head;
        Node *prev=NULL;
        Node *forward=NULL;
        while(curr!=NULL){
            forward=curr->next;
            curr->next=prev;
            prev=curr;
            curr=forward;
        }
        return prev;
    }
    void insertAtTail(struct Node* &head, struct Node* &tail,int val){
        Node *temp=new Node(val);
        // empty list
        if(head==NULL){
            head=temp;
            tail=temp;
            return;
        }
        // non-empty list
        else{
            tail->next=temp;
            tail=temp;
        }
    }
    struct Node *add(struct Node* first, struct Node* second){
        Node *ansHead=NULL;
        Node *ansTail=NULL;
        int carry=0;
        while(first!=NULL || second!=NULL || carry!=0){
            int val1=0;
            if(first!=NULL){
                val1=first->data;
            }
            int val2=0;
            if(second!=NULL){
                val2=second->data;
            }
            int sum=carry+val1+val2;
            int digit=sum%10;
            // create node and add in answer linked list
            insertAtTail(ansHead,ansTail,digit);
            carry=sum/10;
            if(first!=NULL){
                first=first->next;
            }
            if(second!=NULL){
                second=second->next;
            }
        }
        return ansHead;
    }
    struct Node* addTwoLists(struct Node* first, struct Node* second)
    {
        // reverse the linked lists which are to be added
        first=reverse(first);
        second=reverse(second);
        // perform addition
        Node *ans=add(first,second);
        // reverse the answer linked list
        ans=reverse(ans);
        return ans;
    }
};

// Add one to the number(Linked List)

// Method-1
class Solution
{
    public:
    Node* reverse(Node* head)
    {
        if(!head || !head->next)
            return head;
        Node* curr = head;
        Node* prev = NULL;
        Node* Next = head->next;
        while(curr->next!=NULL)
        {
            curr->next = prev;
            prev = curr;
            curr = Next;
            Next = Next->next;
        }
        curr->next = prev;
        return curr;
    }
    Node* addOne(Node *head) 
    {
        Node* newHead = reverse(head);
        Node* temp = newHead;
        while(temp->next != NULL && temp->data == 9)
        {
            temp->data = 0;
            temp = temp->next;
        }
        if(temp->data != 9)
            temp->data += 1;
        else if(temp->next == NULL && temp->data == 9)
        {
            temp->data = 0;
            temp->next = new Node(1);
        }
        return reverse(newHead);
    }
};

// Method-2
class Solution
{
    int recursiveAddition(Node*head)
    {
        if(head == NULL)
        {
            return 1;
        }
        int carry = recursiveAddition(head->next);
        int sum = head->data + carry;
        carry = sum / 10;
        sum = sum % 10;
        head->data = sum;
        return carry;
    }
    public:
    Node* addOne(Node *head) 
    {
        // return head of list after adding one
        int carry = recursiveAddition(head);
        if(carry == 0)
        {
            return head;
        }
        Node*temp = new Node(carry);
        temp->next = head;
        head = temp;
        return head;
    }
};

// Clone a Linked List with next and random pointers

// Method-1
class Solution
{
    public:
    Node *copyList(Node *head)
    {
        Node* temp = head;
        unordered_map <Node*, Node*> map;
        vector <Node*> vec;
        while(temp){
            Node* n = new Node(temp->data);
            vec.push_back(n);
            map[temp] = n;
            temp = temp->next;
        }
        for(int i=0; i<vec.size()-1; i++){
            vec[i]->next = vec[i+1];
        }
        vec[vec.size()-1] = NULL;
        temp = head;
        while(temp){
            map[temp]->arb = map[temp->arb];
            temp = temp->next;
        }
        return map[head];   
    }
};

// Method-2
class Solution
{
    public:
    Node *copyList(Node *head)
    {
        Node*current=head;
        while(current!=NULL){
        Node* temp = current->next;
        current->next = new Node(current->data);
        current->next->next = temp;
        current = temp;
        }
        current=head;
        
        //Setting random pointers to new nodes
    
        while(current!=NULL){
            
            current->next->arb = (current->arb) ? current->arb->next: current->arb;
            current = current->next->next;
        }
        
        // Separating both the linked lists
    
        Node* original = head;
        Node *copy  = head->next;
        Node* temp = copy;
        
        while(original!=NULL && copy!=NULL){
            original->next = original->next->next;
            copy->next = (copy->next!= NULL)?copy->next->next:copy->next;
            original = original->next;
            copy = copy->next;
        }
        return temp;
    }
};

// Merge Sort in Linked List

class Solution{
  public:
    //Function to sort the given linked list using Merge Sort.
    Node *middle(Node *head)
    {
        Node* slow=head;
        Node* fast=head->next;
        while(fast!=NULL && fast->next!=NULL)
        {
            slow=slow->next;
            fast=fast->next->next;
        }
        return slow;
    }
    Node *merge(Node* left,Node* right)
    {
        Node *curr=new Node(-1);
        Node *temp=curr;
        if(left==NULL)
        return right;
        if(right==NULL)
        return left;
        while(left!=NULL && right !=NULL)
        {
            if(left->data<right->data)
            {
                temp->next=left;
                temp=temp->next;
                left=left->next;
            }
            else
            {
                 temp->next=right;
                temp=temp->next;
                right=right->next;
            }
        }
        while(left!=NULL)
        {
             temp->next=left;
                temp=temp->next;
                left=left->next;
        }
        while(right!=NULL)
        {
             temp->next=right;
                temp=temp->next;
                right=right->next;
        }
        return curr->next;
    }
    Node* mergeSort(Node* head) {
        // your code here
        if(head==NULL || head->next==NULL)
        {
            return head;
        }
        Node *curr=head;
        Node *left=NULL;
        Node *right=NULL;
        Node* mid=middle(curr);
        left=head;
        right=mid->next;
        mid->next=NULL;
        left=mergeSort(left);
        right=mergeSort(right);
        Node *ans=merge(left,right);
        return ans;
    }
};

// Flatten a Linked List

void insert(Node *head,Node* val){
    Node* curr = head->bottom;
    Node* prev = head;
    while(prev){
        if(!curr or val->data < curr->data){
            prev->bottom = val;
            val->bottom = curr;
            return;
        }
        prev = curr;
        curr = curr->bottom;
    }
}
Node *flatten(Node *root)
{
    Node* head = root,*ans = root;
    root = root->next;
    while(root){
        Node* curr = root;
        while(curr){
            Node* next = curr->bottom;
            curr->bottom = nullptr;
            insert(head,curr);
            curr = next;
        }
        root = root->next;
    }
    return ans;
}

// Two Stacks

#include <bits/stdc++.h> 
class TwoStack {
public:
    int *arr;
    int top1;
    int top2;
    int size;
    // Initialize TwoStack.
    TwoStack(int s) {
        this->size=s;
        arr=new int[s];
        top1=-1;
        top2=s;
    }
    // Push in stack 1.
    void push1(int num) {
        if(top2-top1>1){
            top1++;
            arr[top1]=num;
        }
    }
    // Push in stack 2.
    void push2(int num) {
        if(top2-top1>1){
            top2--;
            arr[top2]=num;
        }
    }
    // Pop from stack 1 and return popped element.
    int pop1() {
        if(top1>=0){
            int ans=arr[top1];
            top1--;
            return ans;
        }
        else{
            return -1;
        }
    }
    // Pop from stack 2 and return popped element.
    int pop2() {
        if(top2<size){
            int ans=arr[top2];
            top2++;
            return ans;
        }
        else{
            return -1;
        }
    }
};

// Reverse a string using Stack

char* reverse(char *S, int len){
    stack<char> st;
    for(int i = 0;i<len;i++){
        st.push(S[i]);
    }
    int i = 0;
    while(!st.empty()){
        S[i++] = st.top();
        st.pop();
    }
    return S;
}

// Reverse a stack

class Solution{
    public:
    void Reverse(stack<int> &St){
       vector<int> s1;
       while(!St.empty()){
           int num=St.top();
           St.pop();
           s1.push_back(num);
       }
       for(int i=0;i<s1.size();i++){
           St.push(s1[i]);
       }
    }
};

// Delete middle element from stack

#include <bits/stdc++.h> 
void solve(stack<int>&inputStack,int count, int size){
    if(count==size/2){
        inputStack.pop();
        return;
    }
    int num=inputStack.top();
    inputStack.pop();
    solve(inputStack,count+1,size);
    inputStack.push(num);
}
void deleteMiddle(stack<int>&inputStack, int N){
	int count=0;
    solve(inputStack,count,N);
}

// Valid Parantheses

bool isValidParenthesis(string expression)
{
    stack<char> s;
    for (int i = 0; i < expression.length(); i++)
    {
        char ch = expression[i];
        if (ch == '(' || ch == '{' || ch == '[')
        {
            s.push(ch);
        }
        else
        {
            if (!s.empty())
            {
                char top = s.top();
            if ((ch == ')' && top=='(') || (ch == '}' && top== '{') || (ch==']' && top=='[')){
                    s.pop();
            }
            else{
                    return false;
            }
            }
            else
            {
            return false;
            }
        }
    }
    if (s.empty())
    {
        return true;
    }
    else
    {
        return false;
    }
}

// Insert an element at its bottom in the given stack

#include <bits/stdc++.h>
void solve(stack<int> &s,int x){
    if(s.empty()){
        s.push(x);
        return;
    }
    int num=s.top();
    s.pop();
    solve(s,x);
    s.push(num);
} 
stack<int> pushAtBottom(stack<int>& myStack, int x) {
    solve(myStack,x);
    return myStack;    
}

// Reverse a stack using recurison

void insertAtBottom(stack<int> &s,int element){
    if(s.empty()){
        s.push(element);
        return;
    }
    int num=s.top();
    s.pop();
    insertAtBottom(s, element);
    s.push(num);
}
void reverseStack(stack<int> &stack) {
    if(stack.empty()){
        return;
    }
    int num=stack.top();
    stack.pop();
    reverseStack(stack);
    insertAtBottom(stack,num);
}

// Sort a Stack

#include <bits/stdc++.h> 
void sortedInserted(stack<int> &stack,int num){
	if(stack.empty() || (!stack.empty() && stack.top()<num)){
		stack.push(num);
		return;
	}
	int n=stack.top();
	stack.pop();
	sortedInserted(stack, num);
	stack.push(n);
}
void sortStack(stack<int> &stack)
{
	if(stack.empty()){
		return;
	}
	int num=stack.top();
	stack.pop();
	sortStack(stack);
	sortedInserted(stack,num);
}

// Redundant brackets

#include <bits/stdc++.h> 
bool findRedundantBrackets(string &s)
{
    stack<char> st;
    for(int i=0;i<s.length();i++){
        char ch=s[i];
        if(ch=='(' || ch=='+' || ch=='-' || ch=='*' || ch=='/' ){
            st.push(ch);
        }
        else{
            if(ch==')'){
                bool isRedundant=true;
                while(st.top()!='('){
                    char top=st.top();
                    if(top=='+' || top=='-' || top=='*' || top=='/' ){
                        isRedundant=false;
                    }
                    st.pop();
                }
                if(isRedundant==true){
                    return true;
                }
                st.pop();
            }
        }
    }
    return false;
}

// Minimum cost to make string valid

#include <bits/stdc++.h> 
int findMinimumCost(string str) {
    //odd condition
    if(str.length()%2 == 1) {
        return -1;
    }
    stack<char> s;
    for(int i=0; i<str.length(); i++) {
        char ch = str[i];
        if (ch == '{') {
          s.push(ch);
        } 
        else {
          // ch is closed brace
          if (!s.empty() && s.top() == '{') {
            s.pop();
          } 
          else {
            s.push(ch);
          }
        }
    }
    //stack contains invalid expression
    int a = 0, b = 0;
    while(!s.empty()) {
      if(s.top() == '{') {
        b++;
      }
      else{
        a++;
      }
      s.pop();
    }    
    int ans = (a+1)/2 + (b+1)/2;
    return ans;
}

// Next smaller element

#include<stack>
vector<int> nextSmallerElement(vector<int> &arr, int n){
    stack<int> s;
    s.push(-1);
    vector<int> ans(n);
    for(int i=n-1;i>=0;i--){
        int curr = arr[i];
        while (s.top() >= curr) {
            s.pop();
        }
        ans[i] = s.top();
        s.push(curr);
    }
    return ans;
}

// Previous Smaller element

#include<stack>
vector<int> nextSmallerElement(vector<int> &arr, int n){
    stack<int> s;
    s.push(-1);
    vector<int> ans(n);
    for(int i=0;i<n;i++){
        int curr = arr[i];
        while (s.top() >= curr) {
            s.pop();
        }
        ans[i] = s.top();
        s.push(curr);
    }
    return ans;
}

// Largest Rectangular Area in a histogram

// Method-1 : Brute Force
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n=heights.size(),prev,next;
        long long maxi=0;
        for(int i=0;i<n;i++)
        {
            int c=1;
            prev=i-1;
            next=i+1;
            while(prev>=0 && heights[i]<=heights[prev]) //if prev>=current
            {
                c++;
                prev--;
            }
            while(next<n && heights[i]<=heights[next]) //if next>=current
            {
                c++;
                next++;
            }
            long long area=heights[i]*c;
            maxi=max(maxi,area);
            int t=heights[i];
            while(i<n && heights[i]==t) //for same heights
            {
                i++;          
            }
            i--;
            
        }
        return maxi;
    }
};

// Method-2 
#include <stack>
#include <climits>
vector<int> nextSmaller(vector<int> &arr, int n)
{
    stack<int> st;
    st.push(-1);
    vector<int> ans(n);
    for (int i = n - 1; i >= 0; i--)
    {
        int curr = arr[i];
        while (st.top() != -1 && arr[st.top()] >= curr)
        {
            st.pop();
        }
        ans[i] = st.top();
        st.push(i);
    }
    return ans;
}
vector<int> prevSmaller(vector<int>&arr,int n){
    stack<int> st;
    st.push(-1);
    vector<int> ans(n);
    for (int i = 0; i < n; i++)
    {
        int curr = arr[i];
        while (st.top() != -1 && arr[st.top()] >= curr)
        {
            st.pop();
        }
        ans[i] = st.top();
        st.push(i);
    }
    return ans;
 }
 int largestRectangle(vector < int > & heights) {
    int n = heights.size();
    vector<int> next(n);
    next = nextSmaller(heights, n);
    vector<int> prev(n);
    prev = prevSmaller(heights, n);
    int area = INT_MIN;
    for (int i = 0; i < n; i++)
    {
        int l = heights[i];
        if (next[i] == -1)
        {
            next[i] = n;
        }
        int b = next[i] - prev[i] - 1;
        int newArea = l * b;
        area = max(area, newArea);
    }
    return area;
 }

// Celebrity Problem

// Method-1 : Brute Force


// Method-2
#include <bits/stdc++.h> 
/*
    This is signature of helper function 'knows'.
    You should not implement it, or speculate about its implementation.
    bool knows(int A, int B); 
    Function 'knows(A, B)' will returns "true" if the person having
    id 'A' know the person having id 'B' in the party, "false" otherwise.
*/
int findCelebrity(int n) {
     stack<int>st;
     for(int i=0;i<n;i++)
     {
         st.push(i);
     }
     while(st.size() > 1)
     {
         int a = st.top();
         st.pop();
         int b = st.top();
         st.pop();
         if(knows(a,b))
         {
             st.push(b);
         }
         else
         {
             st.push(a);
         }
     }
     int candi = st.top();
     int celeb = 0;
     for(int i=0;i<n;i++)
     {
         if(knows(candi,i))
         celeb++;
     }
     if(celeb!=0)
     {
         return -1;
     }
     int people = 0;
     for(int i=0;i<n;i++)
     {
         if(knows(i,candi))
         people++;
     }
     if(people!= n-1)//all element should be 1 other than diagonal
     {
         return -1;
     }
     return candi;
}

// Max rectangle in binary matrix with all  1's

// Method-1
class Solution{
  public:
    int largestArea(vector<int>& arr)
    {
        int n = arr.size();
        stack<int> stk;
        stk.push(-1);
        int max_area=0;
        for(int i=0;i<n;i++)
        {
            while(stk.top()!=-1 && arr[stk.top()]>=arr[i])
            {
                int height = arr[stk.top()];
                stk.pop();
                int ls = stk.top();
                int rs = i;
                int width = rs-ls-1;
                max_area = max(max_area,width*height);
            }
            stk.push(i);
        }
        while(stk.top()!=-1)
        {
            int height = arr[stk.top()];
            stk.pop();
            int ls = stk.top();
            int rs = n;
            int width = rs-ls-1;
            max_area = max(max_area,width*height);
        }
        
        return max_area;
    }
    int maxArea(int M[MAX][MAX], int n, int m) {
        vector<int> arr(m,0);
        int ans=largestArea(arr);
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                if(M[i][j]==1) arr[j]++;
                else arr[j]=0;
            }
            ans = max(ans,largestArea(arr));
        }
        return ans;
    }
};

// Method-2
class Solution{
  private:
  vector<int> nextSmallerElement(int *arr, int n) {
        stack<int> s;
        s.push(-1);
        vector<int> ans(n);
        for(int i=n-1; i>=0 ; i--) {
            int curr = arr[i];
            while(s.top() != -1 && arr[s.top()] >= curr)
            {
                s.pop();
            }
            //ans is stack ka top
            ans[i] = s.top();
            s.push(i);
        }
        return ans;
    }
    vector<int> prevSmallerElement(int* arr, int n) {
        stack<int> s;
        s.push(-1);
        vector<int> ans(n);

        for(int i=0; i<n; i++) {
            int curr = arr[i];
            while(s.top() != -1 && arr[s.top()] >= curr)
            {
                s.pop();
            }
            //ans is stack ka top
            ans[i] = s.top();
            s.push(i);
        }
        return ans; 
    }    
  int largestRectangleArea(int* heights, int n) {
        //int n= heights.size();
        vector<int> next(n);
        next = nextSmallerElement(heights, n);
        vector<int> prev(n);
        prev = prevSmallerElement(heights, n);
        int area = INT_MIN;
        for(int i=0; i<n; i++) {
            int l = heights[i];
            
            if(next[i] == -1) {
                next[i] = n;
            }
             int b = next[i] - prev[i] - 1;
            int newArea = l*b;
            area = max(area, newArea);
        }
        return area;
    }
  public:
    int maxArea(int M[MAX][MAX], int n, int m) {
        //compute area for first row
        int area = largestRectangleArea(M[0], m);
        for(int i = 1; i<n; i++) {
            for(int j = 0; j<m; j++) {   
                //row udpate: by adding previous row's value
                if(M[i][j] != 0)
                    M[i][j] = M[i][j] + M[i-1][j];
                else
                    M[i][j] = 0;
            }
            //entire row is updated now
            area = max(area, largestRectangleArea(M[i],m));
            
        }
        return area;
    }
};

// N stacks

#include <bits/stdc++.h> 
class NStack
{
    int *arr;
    int *top;
    int *next;
    int n, s;
    int freespot;
public:
    // Initialize your data structure.
    NStack(int N, int S)
    {
        n = N;
        s = S;
        arr = new int[s];
        top = new int[n];
        next = new int[s];
        //top initialise
        for(int i=0; i<n; i++) {
            top[i] = -1;
        }
        //next initialise
        for (int i = 0; i < s; i++) {
          next[i] = i + 1;
        }
        // update last index value to -1
        next[s - 1] = -1;
        // initialise freespot
        freespot = 0;
    }
    // Pushes 'X' into the Mth stack. Returns true if it gets pushed into the stack, and false otherwise.
    bool push(int x, int m)
    {
        //check for overflow
        if(freespot == -1) {
            return false;
        }   
        //find index
        int index = freespot;
        //insert element into array
        arr[index] = x;
        //update freespot
        freespot = next[index];
        //update next;
        next[index] = top[m-1];
        //update top
        top[m-1] = index;
        return true;
    }
    // Pops top element from Mth Stack. Returns -1 if the stack is empty, otherwise returns the popped element.
    int pop(int m)
    {
        //check underflow condition
        if(top[m-1] == -1) {
            return -1;
        }   
        int index= top[m-1];
        top[m-1] = next[index];
        next[index] = freespot;
        freespot = index;
        return arr[index];
    }
};

// Get minimum element from the stack

#include<stack>
#include<limits.h>
class SpecialStack {
    stack<int> s;
    int mini = INT_MAX;
    public:  
    void push(int data) {
        //for first element
        if(s.empty()) {
            s.push(data);
            mini = data;
        }
        else
        {
         	if(data < mini) {
                s.push(2*data - mini);
                mini = data;
            }   
            else
            {
                s.push(data);
            }
        }
    }
    int pop() {
        if(s.empty()){
            return -1;
        }
        int curr = s.top();
        s.pop();
        if(curr > mini) {
            return curr;
        }
        else
        {
            int prevMin = mini;
            int val = 2*mini - curr;
            mini = val;
            return prevMin;
        }
    }
    int top() {
        if(s.empty())
            return -1;
        
        int curr = s.top();
        if(curr < mini) {
            return mini;
        }
        else
        {
            return curr;
        }
    }
    bool isEmpty() {
        return s.empty();
    }
    int getMin() {
        if(s.empty())
            return -1;
        
        return mini;
    }  
};

// Implementation of queue using STL

// #include<iostream>
// #include<queue>
// using namespace std;
// int main(){
//     queue<int> q;   
//     q.push(10);
//     cout<<"Front of queue is: "<<q.front()<<endl;;
//     q.push(7);
//     q.push(3);
//     cout<<"Size of the queue is: "<<q.size()<<endl;
//     q.pop();
//     cout<<"Front of queue is: "<<q.front()<<endl;
//     cout<<"Size of the queue is: "<<q.size()<<endl;
//     if(q.empty()){
//         cout<<"Queue is empty "<<endl;
//     }
//     else{
//         cout<<"Queue is not empty "<<endl;
//     }
//     return 0;
// }

// Implementation of queue using arrays

// #include <bits/stdc++.h> 
// class Queue {
//     int* arr;
//     int qfront;
//     int rear;
//     int size;
// public:
//     Queue() {
//         size = 100001;
//         arr = new int[size];
//         qfront = 0;
//         rear = 0;
//     }
//     bool isEmpty() {
//         if(qfront == rear){
//             return true;
//         }
//         else{
//           return false;
//         }
//     }
//     void enqueue(int data) {
//         if(rear == size){
//            cout<< "Queue is Full"<<endl;
//         }
//         else{
//             arr[rear]=data;
//             rear++;
//         }
//     }
//     int dequeue() {
//         if(qfront ==rear){
//             return -1;
//         }
//         else{
//             int ans = arr[qfront];
//             arr[qfront]= -1;
//             qfront++;
//               if(qfront ==rear){
//                 qfront = 0;
//                 rear = 0;
//             }
//             return ans;
//         }
//     }
//     int front() {
//        if(qfront ==rear){
//            return -1; 
//        }
//        else{
//            return arr[qfront];
//        }
//     }
// };

// Implementation of queue using linked list

// #include <bits/stdc++.h>
// using namespace std;
// struct QNode {
//     int data;
//     QNode* next;
//     QNode(int d){
//         data = d;
//         next = NULL;
//     }
// };
// struct Queue {
//     QNode *front, *rear;
//     Queue() { front = rear = NULL; }
//     void enQueue(int x){
//         // Create a new LL node
//         QNode* temp = new QNode(x);
//         // If queue is empty, then new node is front and rear both
//         if (rear == NULL) {
//             front = rear = temp;
//             return;
//         }
//         // Add the new node at the end of queue and change rear
//         rear->next = temp;
//         rear = temp;
//     }
//     // Function to remove a key from given queue q
//     void deQueue(){
//         // If queue is empty, return NULL.
//         if (front == NULL)
//             return;
//         // Store previous front and move front one node ahead
//         QNode* temp = front;
//         front = front->next;
//         // If front becomes NULL, then change rear also as NULL
//         if (front == NULL)
//             rear = NULL;
//         delete (temp);
//     }
// };
// int main(){
//     Queue q;
//     q.enQueue(10);
//     q.enQueue(20);
//     q.deQueue();
//     q.deQueue();
//     q.enQueue(30);
//     q.enQueue(40);
//     q.enQueue(50);
//     q.deQueue();
//     cout << "Queue Front : " << ((q.front != NULL) ? (q.front)->data : -1)<< endl;
//     cout << "Queue Rear : " << ((q.rear != NULL) ? (q.rear)->data : -1);
// }

// Circular Queue using array

#include <bits/stdc++.h> 
class CircularQueue{
    int size;
    int front;
    int rear;
    int *arr;
    public:
    CircularQueue(int n){
        size = n;
        arr = new int[size];
        front = -1;
        rear  =  -1;
    }
    // Enqueues 'X' into the queue. Returns true if it gets pushed into the stack, and false otherwise.
    bool enqueue(int value){
        if((front==0 && rear==size-1) || (rear == (front-1)%(size-1))){
            return false;
        }
        else if(front==-1){
            front=0; 
            rear=0;
        }
        else if(rear==size-1 && front!=0){
            rear = 0;
        }
        else{
            rear++;
        }
        arr[rear] = value;
        return true;
    }
    // Dequeues top element from queue. Returns -1 if the stack is empty, otherwise returns the popped element.
    int dequeue(){
        if(front==-1){
            return -1;
        }
        int ans=arr[front];
        arr[front]=-1;
        if(front==rear){
            front=-1;
            rear=-1;
        }
        else if(front==size-1){
            front=0;
        }
        else{
            front++;
        }
        return ans;
    }
};

// Circular queue using linked list

class MyCircularQueue {
public:
    int head, tail, size;
    vector<int> q;
    
    MyCircularQueue(int k) : head(-1), tail(-1), size(k), q(k) {}
    
    bool enQueue(int value) {
        if (isFull()) return false;
        if (tail == -1) head = tail = 0;
        else tail = (tail+1) % size;
        q[tail] = value;
        return true;
    }
    
    bool deQueue() {
        if (isEmpty()) return false;
        if (head == tail) head = tail = -1;
        else head = (head+1) % size;
        return true;
    }
    
    int Front() {
        return (isEmpty()) ? -1 : q[head];
    }
    
    int Rear() {
        return (isEmpty()) ? -1 : q[tail];
    }
    
    bool isEmpty() {
        return (head == -1);
    }
    
    bool isFull() {
        return ((head == 0 && tail == size-1) || (tail == head-1)); 
    }
};

// Input restricted queue

#include <iostream>
using namespace std;
// Maximum size of array or Input Restricted Queue
#define MAX 100

// A structure to represent a Input Restricted Queue
class Deque{
    int arr[MAX];
    int front;
    int rear;
    int size;
public:
    Deque(int size){
        front = -1;
        rear = 0;
        this->size = size;
    }
    // Operations on Input Restricted Queue
    void insertrear(int key);
    void deletefront();
    void deleterear();
    bool isFull();
    bool isEmpty();
    int getFront();
    int getRear();
};
// Checks whether Input Restricted Queue is full or not.
bool Deque::isFull()
{
    return ((front == 0 && rear == size - 1) || front == rear + 1);
}
// Checks whether Input Restricted Queue is empty or not.
bool Deque::isEmpty() { 
    return (front == -1); 
}
// function to inset element at rear end of Input Restricted Queue
void Deque::insertrear(int key)
{
    if (isFull())
    {
        cout << " Overflow\n " << endl;
        return;
    }
    // If queue is initially empty
    if (front == -1)
    {
        front = 0;
        rear = 0;
    }
    // Rear is at last position of queue
    else if (rear == size - 1)
        rear = 0;
    // Increment rear end by '1'
    else
        rear = rear + 1;
    // Insert current element into Deque
    arr[rear] = key;
}
// Deletes element at front end of Input Restricted Queue
void Deque::deletefront()
{
    // Check whether Deque is empty or not
    if (isEmpty())
    {
        cout << "Queue Underflow\n"
             << endl;
        return;
    }
    // Deque has only one element
    if (front == rear)
    {
        front = -1;
        rear = -1;
    }
    else
        // Back to initial position
        if (front == size - 1)
            front = 0;
        else
            // Increment front by '1' to remove current front value from Deque
            front = front + 1;
}
// Delete element at rear end of Input Restricted Queue
void Deque::deleterear()
{
    if (isEmpty())
    {
        cout << " Underflow\n"
             << endl;
        return;
    }
    // Deque has only one element
    if (front == rear)
    {
        front = -1;
        rear = -1;
    }
    else if (rear == 0)
        rear = size - 1;
    else
        rear = rear - 1;
}
// Returns front element of Input Restricted Queue
int Deque::getFront()
{
    // Check whether Deque is empty or not
    if (isEmpty())
    {
        cout << " Underflow\n"
             << endl;
        return -1;
    }
    return arr[front];
}
// Function return rear element of Input Restricted Queue
int Deque::getRear()
{
    // Check whether Deque is empty or not
    if (isEmpty() || rear < 0)
    {
        cout << " Underflow\n"
             << endl;
        return -1;
    }
    return arr[rear];
}
int main()
{
    Deque dq(5);
    // Function calls
    cout << "Insert element at rear end : 5 \n";
    dq.insertrear(5);
    cout << "insert element at rear end : 10 \n";
    dq.insertrear(10);
    cout << "insert element at rear end : 15 \n";
    dq.insertrear(15);
    cout << "Get rear element : "
         << " " << dq.getRear() << endl;
    dq.deleterear();
    cout << "After delete rear element new rear"
         << " become : " << dq.getRear() << endl;
    cout << "Get front element : " << dq.getFront() << endl;
    dq.deletefront();
    cout << "After delete front element new "
         << "front become : " << dq.getFront() << endl;
    return 0;
}

// Output restricted queue

#include <iostream>
using namespace std;
// Maximum size of array or Output Restricted Queue
#define MAX 100
// A structure to represent a Output Restricted Queue
class Deque
{
    int arr[MAX];
    int front;
    int rear;
    int size;
public:
    Deque(int size)
    {
        front = -1;
        rear = 0;
        this->size = size;
    }
    // Operations on Output Restricted Queue
    void insertfront(int key);
    void insertrear(int key);
    void deletefront();
    bool isFull();
    bool isEmpty();
    int getFront();
    int getRear();
};
// Checks whether Output Restricted Queue is full or not.
bool Deque::isFull()
{
    return ((front == 0 && rear == size - 1) || front == rear + 1);
}
// Checks whether Output Restricted Queue is empty or not.
bool Deque::isEmpty()
{
    return (front == -1);
}
// Function to insert element at front end of Output Restricted Queue
void Deque::insertfront(int key)
{
    // Check whether Deque if full or not
    if (isFull())
    {
        cout << "Overflow\n"
             << endl;
        return;
    }
    // If queue is initially empty
    if (front == -1)
    {
        front = 0;
        rear = 0;
    }
    // Front is at first position of queue
    else if (front == 0)
        front = size - 1;
    else
        // Decrement front end by '1'
        front = front - 1;
    // Insert current element into Deque
    arr[front] = key;
}
// Function to insert element at rear end of Output Restricted Queue
void Deque::insertrear(int key)
{
    if (isFull())
    {
        cout << " Overflow\n " << endl;
        return;
    }
    // If queue is initially empty
    if (front == -1)
    {
        front = 0;
        rear = 0;
    }
    // Rear is at last position of queue
    else if (rear == size - 1)
        rear = 0;
    // Increment rear end by '1'
    else
        rear = rear + 1;
    // Insert current element into Deque
    arr[rear] = key;
}
// Deletes element at front end of Output Restricted Queue
void Deque::deletefront()
{
    // Check whether Deque is empty or not
    if (isEmpty())
    {
        cout << "Queue Underflow\n"
             << endl;
        return;
    }
    // Deque has only one element
    if (front == rear)
    {
        front = -1;
        rear = -1;
    }
    else
        // Back to initial position
        if (front == size - 1)
            front = 0;
        else
            // Increment front by '1' to remove current front value from Deque
            front = front + 1;
}
// Returns front element of Output Restricted Queue
int Deque::getFront()
{
    // Check whether Deque is empty or not
    if (isEmpty())
    {
        cout << " Underflow\n"
             << endl;
        return -1;
    }
    return arr[front];
}
// Function to return rear element of Output Restricted Queue
int Deque::getRear()
{
    // Check whether Deque is empty or not
    if (isEmpty() || rear < 0)
    {
        cout << " Underflow\n"
             << endl;
        return -1;
    }
    return arr[rear];
}
int main()
{
    Deque dq(5);
    // Function calls
    cout << "Inserted element at rear end : 10 \n";
    dq.insertrear(10);
    cout << "Inserted element at rear end : 15 \n";
    dq.insertrear(15);
    cout << "Inserted element at front end : 5 \n";
    dq.insertfront(5);
    cout << "Get rear element : "
         << " " << dq.getRear() << endl;
    cout << "Get front element : " << dq.getFront() << endl;
    dq.deletefront();
    cout << "After delete front element new "
         << "front become : " << dq.getFront() << endl;
    return 0;
}

// Doubly Ended Queue (Deque)

#include <bits/stdc++.h>
class Deque
{
public:
    int *arr;
    int front;
    int rear;
    int size;
    // Initialize your data structure.
    Deque(int n)
    {
        size = n;
        front = -1;
        rear = -1;
        arr = new int[n];
    }
    // Pushes 'X' in the front of the deque. Returns true if it gets pushed into the deque, and false otherwise.
    bool pushFront(int x)
    {
        if (isFull())
        {
            // if full queue || if rear is just before the front
            return false;
        }
        else if (isEmpty()) // if insert first element
        {
            front = rear = 0;
        }
        else if (front == 0 && rear != size - 1)
        {
            front = size - 1;
        }
        else
        {
            front--;
        }
        arr[front] = x;
        return true;
    }
    // Pushes 'X' in the back of the deque. Returns true if it gets pushed into the deque, and false otherwise.
    bool pushRear(int x)
    {
        if (isFull())
        {
            // if full queue || if rear is just before the front
            return false;
        }
        else if (isEmpty()) // if insert first element
        {
            front = rear = 0;
        }
        else if (rear == size - 1 && front != 0)
        {
            rear = 0;
        }
        else
        {
            rear++;
        }
        arr[rear] = x;
        return true;
    }
    // Pops an element from the front of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.
    int popFront()
    {
        if (isEmpty())
        {
            return -1;
        }
        int ans = arr[front];
        arr[front] = -1;
        if (front == rear)
        {
            front = -1;
            rear = -1;
        }
        else if (front == size - 1)
        {
            front = 0;
        }
        else
            front++;
        return ans;
    }
    // Pops an element from the back of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.
    int popRear()
    {
        if (isEmpty())
            return -1;
        int ans = arr[rear];
        arr[rear] = -1;
        if (front == rear)
        {
            front = -1;
            rear = -1;
        }
        else if (rear == 0)
        {
            rear = size - 1;
        }
        else
            rear--;
        return ans;
    }
    // Returns the first element of the deque. If the deque is empty, it returns -1.
    int getFront()
    {
        if (isEmpty())
        {
            return -1;
        }
        return arr[front];
    }
    // Returns the last element of the deque. If the deque is empty, it returns -1.
    int getRear()
    {
        if (isEmpty())
        {
            return -1;
        }
        return arr[rear];
    }
    // Returns true if the deque is empty. Otherwise returns false.
    bool isEmpty()
    {
        if (front == -1)
            return true;
        return false;
    }
    // Returns true if the deque is full. Otherwise returns false.
    bool isFull(){
        if ((front == 0 && rear == size - 1) || (front != 0 && rear == (front - 1) % (size - 1)))
            return true;
        return false;
    }
};

// Queue Reversal 

// Method-1
queue<int> rev(queue<int> q)
{
    stack<int> s;
    while(!q.empty()){
        int element=q.front();
        q.pop();
        s.push(element);
    }
    while(!s.empty()){
        int element=s.top();
        s.pop();
        q.push(element);
    }
    return q;
}

// Method-2
void sol(queue<int>& q,queue<int>& s)
{
    if(q.empty())
        return ;
    int val = q.front();
    q.pop();
    sol(q,s);
    s.push(val);  
}
queue<int> rev(queue<int> q)
{
    queue<int> s;
    sol(q,s);
    return s;
}

// First negative integer in every window of size k

vector<long long> printFirstNegativeInteger(long long int A[], long long int N, long long int K) {
         deque<long long int> dq;
         vector<long long> ans;
         int negative = -1;  
         //process first window
         for(int i=0; i<K; i++) {
             if(A[i] < 0) {
                 dq.push_back(i);
             }
         }    
         //push ans for FIRST window
         if(dq.size() > 0) {
             ans.push_back(A[dq.front()]);
         }
         else
         {
             ans.push_back(0);
         }
         //now process for remaining windows
         for(int i = K; i<N; i++) {
             //first pop out of window element
             if(!dq.empty() && (i - dq.front())>=K ) {
                 dq.pop_front();
             }
             //then push current element
             if(A[i] < 0)
                dq.push_back(i);
            // put in ans
            if(dq.size() > 0) {
                 ans.push_back(A[dq.front()]);
            }
            else
            {
                ans.push_back(0);
            }
         }
         return ans;
 }
 
 // Reverse First K elements of Queue
 
queue<int> modifyQueue(queue<int> q, int k) {
    //algo:
    //first k element stack me daaldo  and queue se hatado
    // k element stack se nikalke wapas queue me daalde 
    // fer queue k (n-k) starting k elements, wapas queue me daalde
    stack<int> s;
    for(int i = 0; i<k; i++) {
        int val = q.front();
        q.pop();
        s.push(val);
    }
    while(!s.empty()) {
        int val = s.top();
        s.pop();
        q.push(val);
    }
    int t = q.size()-k;
    while(t--) {
        int val = q.front();
        q.pop();
        q.push(val);
    }
    return q;
}

// First non-repeating character in a stream

class Solution {
	public:
		string FirstNonRepeating(string A){
           unordered_map<char,int> mp;
           queue<char> q;
           string ans = "";
           
           for(int i = 0; i < A.length(); i++)
           {
               char ch = A[i];
               mp[ch]++;
               q.push(ch);
               
               while(!q.empty())
               {
                   if(mp[q.front()] > 1)
                        q.pop();
                    else{
                        ans.push_back(q.front());
                        break;
                    }
               }
               
               if(q.empty())
                    ans.push_back('#');
           }
           return ans;
        }
};
 
// Circular tour

class Solution{
public:
    //Function to find starting point where the truck can start to get through
    //the complete circle without exhausting its petrol in between.
    int tour(petrolPump p[],int n)
    {
       int deficit = 0;
       int balance = 0;
       int start = 0;
       for(int i=0; i<n; i++) {
           balance += p[i].petrol - p[i].distance;
           if(balance < 0) {
               start = i+1;
               deficit += balance;
               balance = 0;
           }
       }
       if(balance + deficit >=0) 
            return start;
        return -1;
    }
};

// Interleave the firt half of the queue with the second half

// Method-1
#include <bits/stdc++.h> 
void interLeaveQueue(queue < int > & q) {
    queue<int> newq;
    int n=q.size()/2;
    while(n--){
        newq.push(q.front());
        q.pop();
    }
    while(!newq.empty()){
        q.push(newq.front());
        newq.pop();
        int ele=q.front();
        q.pop();
        q.push(ele);
    }
}

// Method-2
#include <bits/stdc++.h> 
void interLeaveQueue(queue < int > & q) {
    stack<int> s;
    int n=q.size()/2;
    int count=0;
    while(count<n){
        s.push(q.front());
        q.pop();
        count++;
    }
    while(!s.empty()){
        q.push(s.top());
        s.pop();
    }
    count=0;
    while(count<n){
        int ele=q.front();
        q.push(ele);
        q.pop();
        count++;
    }
    count=0;
    while(count<n){
        s.push(q.front());
        q.pop();
        count++;
    }
    while(!s.empty()){
        int stackele=s.top();
        s.pop();
        q.push(stackele);
        int qele= q.front();
        q.pop();
        q.push(qele);
    }

}

// How to efficiently implement k Queues in a single array?

https://www.geeksforgeeks.org/efficiently-implement-k-queues-single-array/
#include <iostream>
#include <queue>
using namespace std;
class kQueue
{
public:
    int n;
    int k;
    int *arr;
    int *front;
    int *rear;
    int freespot;
    int *next;

public:
    kQueue(int n, int k)
    {
        this->n = n;
        this->k = k;
        front = new int[k];
        rear = new int[k];
        for (int i = 0; i < k; i++)
        {
            front[i] = -1;
            rear[i] = -1;
        }
        next = new int[n];
        for (int i = 0; i < n; i++)
        {
            next[i] = i + 1;
        }
        next[n - 1] = -1;
        arr = new int[n];
        freespot = 0;
    }
    void enqueue(int data,int qn){
        // overflow
        if(freespot==-1){
            cout<<"No empty space is present "<<endl;
            return;
        }
        // find first free index
        int index=freespot;
        // update freespot
        freespot=next[index];
        // check whether first element
        if(front[qn-1]==-1){
            front[qn-1]=index;
        }
        // link new element to the previous element
        else{
            next[rear[qn-1]]=index;
        } 
        // update next
        next[index]=-1;
        // update rear
        rear[qn-1]=index;
        // push element
        arr[index]=data;
    }
    int dequeue(int qn){
        // underflow
        if(front[qn-1]==-1){
            cout<<"Queue underflow"<<endl;
            return -1;
        }
        // find index to pop
        int index=front[qn-1];
        // front ko aage badhao
        front[qn-1]=next[index];
        // freeslots ko manage karo
        next[index]=freespot;
        freespot=index;
        return arr[index];
    }
};
int main()
{
    kQueue q(10,3);
    q.enqueue(10,1);
    q.enqueue(15,1);
    q.enqueue(20,2);
    q.enqueue(25,1);
    // cout<<q.dequeue(1)<<endl;
    // cout<<q.dequeue(2)<<endl;
    // cout<<q.dequeue(1)<<endl;
    // cout<<q.dequeue(1)<<endl; // output -> 10 20 15 25
    cout<<q.dequeue(1)<<endl;
    cout<<q.dequeue(2)<<endl;
    cout<<q.dequeue(1)<<endl;
    cout<<q.dequeue(1)<<endl;
    cout<<q.dequeue(1)<<endl; // output -> 10 20 15 25 Queue underflow -1
    return 0;
}

// Sum of minimum and maximum elements of all subarrays of size k.

#include<iostream>
#include<queue>
using namespace std;
int solve(int *arr, int n, int k) {
    deque<int> maxi(k);
    deque<int> mini(k);
    //Addition of first k size window
    for(int i=0; i<k; i++) {
        while(!maxi.empty() && arr[maxi.back()] <= arr[i])
            maxi.pop_back();
        while(!mini.empty() && arr[mini.back()] >= arr[i])
            mini.pop_back();
        maxi.push_back(i);
        mini.push_back(i);
    }
    int ans = 0;
    ans += arr[maxi.front()] + arr[mini.front()];
    //remaining windows ko process karlo
    for(int i=k; i<n; i++) {
        //next window
        //removal
        while(!maxi.empty() && i - maxi.front() >=k) {
            maxi.pop_front();
        }
        while(!mini.empty() && i - mini.front() >=k) {
            mini.pop_front();
        }
        //addition
        while(!maxi.empty() && arr[maxi.back()] <= arr[i])
            maxi.pop_back();
        while(!mini.empty() && arr[mini.back()] >= arr[i])
            mini.pop_back();
        maxi.push_back(i);
        mini.push_back(i);    
        ans += arr[maxi.front()] + arr[mini.front()];
    }
    return ans;
}

// Level Order Traversal in Binary Tree

#include <iostream>
#include <queue>
#include <stack>
using namespace std;
class node
{
public:
    int data;
    node *left;
    node *right;
    node(int d)
    {
        this->data = d;
        this->left = NULL;
        this->right = NULL;
    }
};
node *buildTree(node *root)
{
    int data;
    cout << "Enter the data:" << endl;
    cin >> data;
    root = new node(data);
    if (data == -1)
    {
        return NULL;
    }
    cout << "Enter the data for inserting in left of " << data << endl;
    root->left = buildTree(root->left);
    cout << "Enter the data for inserting in right of " << data << endl;
    root->right = buildTree(root->right);
    return root;
}
node *levelOrderTraversal(node *root)
{
    queue<node *> q;
    q.push(root);
    q.push(NULL);
    while (!q.empty())
    {
        node *temp = q.front();
        q.pop();
        if (temp == NULL)
        { // purana level complete traverse ho chuka hai
            cout << endl;
            if (!q.empty())
            { // queue still has some child nodes
                q.push(NULL);
            }
        }
        else
        {
            cout << temp->data << " ";
            if (temp->left)
            {
                q.push(temp->left);
            }
            if (temp->right)
            {
                q.push(temp->right);
            }
        }
    }
}
int main()
{
    node *root = NULL;
    // creating a tree
    root = buildTree(root);
    // level order
    cout << "Printing the level order traversal output " << endl;
    levelOrderTraversal(root);
    return 0;
}

// Reverse Level Order Traversal in Binary Tree

#include <iostream>
#include <queue>
#include <stack>
using namespace std;
class node
{
public:
    int data;
    node *left;
    node *right;
    node(int d)
    {
        this->data = d;
        this->left = NULL;
        this->right = NULL;
    }
};
node *buildTree(node *root)
{
    int data;
    cout << "Enter the data:" << endl;
    cin >> data;
    root = new node(data);
    if (data == -1)
    {
        return NULL;
    }
    cout << "Enter the data for inserting in left of " << data << endl;
    root->left = buildTree(root->left);
    cout << "Enter the data for inserting in right of " << data << endl;
    root->right = buildTree(root->right);
    return root;
}
void reverseLevelTraversal(node *root)
{
    queue<node *> q;
    q.push(root);
    q.push(NULL);
    // q.push(NULL);
    stack<node *> s;
    while (!q.empty())
    {
        node *temp = q.front();
        s.push(temp);
        q.pop();
        if (temp == NULL)
        {
            if (!q.empty())
            {
                q.push(NULL);
            }
        }
        else
        {
            if (temp->right)
            {
                q.push(temp->right);
            }
            if (temp->left)
            {
                q.push(temp->left);
            }
        }
    }
    while (!s.empty())
    {
        node *temp = s.top();
        s.pop();
        if (temp == NULL)
        {
            cout << endl;
        }
        else
        {
            cout << temp->data << " ";
        }
    }
}
int main()
{
    node *root = NULL;
    // creating a tree
    root = buildTree(root);
    // reverse level order
    cout << "Printing the reverse level order traversal output " << endl;
    reverseLevelTraversal(root);
    return 0;
}

// Inorder Level Traversal in Binary Tree (Left Node Right [LNR] )

// Method-1 ( Recursively )
#include <iostream>
#include <queue>
#include <stack>
using namespace std;
class node
{
public:
    int data;
    node *left;
    node *right;
    node(int d)
    {
        this->data = d;
        this->left = NULL;
        this->right = NULL;
    }
};
node *buildTree(node *root)
{
    int data;
    cout << "Enter the data:" << endl;
    cin >> data;
    root = new node(data);
    if (data == -1)
    {
        return NULL;
    }
    cout << "Enter the data for inserting in left of " << data << endl;
    root->left = buildTree(root->left);
    cout << "Enter the data for inserting in right of " << data << endl;
    root->right = buildTree(root->right);
    return root;
}
void inOrderTraversal(node *root){
    if(root==NULL){
        return;
    }
    inOrderTraversal(root->left);
    cout<<root->data<<" ";
    inOrderTraversal(root->right);
}
int main()
{
    node *root = NULL;
    // creating a tree
    root = buildTree(root);
    // inorder traversal
    inOrderTraversal(root);
    return 0;
}

// Method-2 ( Iteratively )
#include <iostream>
#include <queue>
#include <stack>
using namespace std;
class node
{
public:
    int data;
    node *left;
    node *right;
    node(int d)
    {
        this->data = d;
        this->left = NULL;
        this->right = NULL;
    }
};
node *buildTree(node *root)
{
    int data;
    cout << "Enter the data:" << endl;
    cin >> data;
    root = new node(data);
    if (data == -1)
    {
        return NULL;
    }
    cout << "Enter the data for inserting in left of " << data << endl;
    root->left = buildTree(root->left);
    cout << "Enter the data for inserting in right of " << data << endl;
    root->right = buildTree(root->right);
    return root;
}
void inOrderTraversal(node *root)
{
    stack<node *> s;
    node *curr = root;
    while (curr != NULL || s.empty() == false)
    {
        // Reach the leftmost node of the curr node
        while (curr != NULL)
        {
            // place pointer to a tree node on the stack before traversing the node's left subtree
            s.push(curr);
            curr = curr->left;
        }
        // curr must be NULL at this point
        curr = s.top();
        s.pop();
        cout << curr->data << " ";
        // we have visited the node and ist left subtree. Now, its right subtree turn
        curr = curr->right;
    }
}
int main()
{
    node *root = NULL;
    // creating a tree
    root = buildTree(root);
    // inorder traversal
    inOrderTraversal(root);
    return 0;
}

// Preorder Level Traversal in Binary Tree ( Node Left Right [NLR] )

// Method-1 ( Recursively )
#include <iostream>
#include <queue>
#include <stack>
using namespace std;
class node
{
public:
    int data;
    node *left;
    node *right;
    node(int d)
    {
        this->data = d;
        this->left = NULL;
        this->right = NULL;
    }
};
node *buildTree(node *root)
{
    int data;
    cout << "Enter the data:" << endl;
    cin >> data;
    root = new node(data);
    if (data == -1)
    {
        return NULL;
    }
    cout << "Enter the data for inserting in left of " << data << endl;
    root->left = buildTree(root->left);
    cout << "Enter the data for inserting in right of " << data << endl;
    root->right = buildTree(root->right);
    return root;
}
void PreOrderTraversal(node *root){
    if(root==NULL){
        return;
    }
    cout<<root->data<<" ";
    PreOrderTraversal(root->left);
    PreOrderTraversal(root->right);
}
int main()
{
    node *root = NULL;
    // creating a tree
    root = buildTree(root);
    // preorder traversal
    PreOrderTraversal(root);
    return 0;
}

// Method-2 ( Iteratively )
#include <iostream>
#include <queue>
#include <stack>
using namespace std;
class node
{
public:
    int data;
    node *left;
    node *right;
    node(int d)
    {
        this->data = d;
        this->left = NULL;
        this->right = NULL;
    }
};
node *buildTree(node *root)
{
    int data;
    cout << "Enter the data:" << endl;
    cin >> data;
    root = new node(data);
    if (data == -1)
    {
        return NULL;
    }
    cout << "Enter the data for inserting in left of " << data << endl;
    root->left = buildTree(root->left);
    cout << "Enter the data for inserting in right of " << data << endl;
    root->right = buildTree(root->right);
    return root;
}
void PreOrderTraversal(node *root)
{
    if (root == NULL)
        return;
    stack<node *> st;
    // start from root node (set current node to root node)
    node *curr = root;
    // run till stack is not empty or current is not NULL
    while (!st.empty() || curr != NULL)
    {
        // Print left children while exist and keep pushing right into the stack.
        while (curr != NULL)
        {
            cout << curr->data << " ";

            if (curr->right)
            {
                st.push(curr->right);
            }
            curr = curr->left;
        }
        // We reach when curr is NULL, so We take out a right child from stack
        if (st.empty() == false)
        {
            curr = st.top();
            st.pop();
        }
    }
}
int main()
{
    node *root = NULL;
    // creating a tree
    root = buildTree(root);
    // preorder traversal
    PreOrderTraversal(root);
    return 0;
}

// Postorder Level Traversal in Binary Tree ( Left Right Node [LRN] )

// Method-1 ( Recursively )
#include <iostream>
#include <queue>
#include <stack>
using namespace std;
class node
{
public:
    int data;
    node *left;
    node *right;
    node(int d)
    {
        this->data = d;
        this->left = NULL;
        this->right = NULL;
    }
};
node *buildTree(node *root)
{
    int data;
    cout << "Enter the data:" << endl;
    cin >> data;
    root = new node(data);
    if (data == -1)
    {
        return NULL;
    }
    cout << "Enter the data for inserting in left of " << data << endl;
    root->left = buildTree(root->left);
    cout << "Enter the data for inserting in right of " << data << endl;
    root->right = buildTree(root->right);
    return root;
}
void PostOrderTraversal(node *root){
    if(root==NULL){
        return;
    }
    PostOrderTraversal(root->left);
    PostOrderTraversal(root->right);
    cout<<root->data<<" ";
}
int main()
{
    node *root = NULL;
    // creating a tree
    root = buildTree(root);
    // postorder traversal
    PostOrderTraversal(root);
    return 0;
}

// Method-2 ( Iteratively )
#include <iostream>
#include <queue>
#include <stack>
using namespace std;
class node
{
public:
    int data;
    node *left;
    node *right;
    node(int d)
    {
        this->data = d;
        this->left = NULL;
        this->right = NULL;
    }
};
node *buildTree(node *root)
{
    int data;
    cout << "Enter the data:" << endl;
    cin >> data;
    root = new node(data);
    if (data == -1)
    {
        return NULL;
    }
    cout << "Enter the data for inserting in left of " << data << endl;
    root->left = buildTree(root->left);
    cout << "Enter the data for inserting in right of " << data << endl;
    root->right = buildTree(root->right);
    return root;
}
void PostOrderTraversal(node *root)
{
    if (root == NULL)
        return;
    // Create two stacks
    stack<node *> s1, s2;
    // push root to first stack
    s1.push(root);
    node *curr;
    // Run while first stack is not empty
    while (!s1.empty())
    {
        // Pop an item from s1 and push it to s2
        curr = s1.top();
        s1.pop();
        s2.push(curr);
        // Push left and right children of removed item to s1
        if (curr->left)
            s1.push(curr->left);
        if (curr->right)
            s1.push(curr->right);
    }
    // Print all elements of second stack
    while (!s2.empty())
    {
        curr = s2.top();
        s2.pop();
        cout << curr->data << " ";
    }
}
int main()
{
    node *root = NULL;
    // creating a tree
    root = buildTree(root);
    // postorder traversal
    PostOrderTraversal(root);
    return 0;
}

// Build a tree

#include <iostream>
#include <queue>
#include <stack>
using namespace std;
class node
{
public:
    int data;
    node *left;
    node *right;
    node(int d)
    {
        this->data = d;
        this->left = NULL;
        this->right = NULL;
    }
};
node *buildTree(node *root)
{
    int data;
    cout << "Enter the data:" << endl;
    cin >> data;
    root = new node(data);
    if (data == -1)
    {
        return NULL;
    }
    cout << "Enter the data for inserting in left of " << data << endl;
    root->left = buildTree(root->left);
    cout << "Enter the data for inserting in right of " << data << endl;
    root->right = buildTree(root->right);
    return root;
}
node *levelOrderTraversal(node *root)
{
    queue<node *> q;
    q.push(root);
    q.push(NULL);
    while (!q.empty())
    {
        node *temp = q.front();
        q.pop();
        if (temp == NULL)
        { // purana level complete traverse ho chuka hai
            cout << endl;
            if (!q.empty())
            { // queue still has some child nodes
                q.push(NULL);
            }
        }
        else
        {
            cout << temp->data << " ";
            if (temp->left)
            {
                q.push(temp->left);
            }
            if (temp->right)
            {
                q.push(temp->right);
            }
        }
    }
}
void buildFromLevelOrder(node *&root)
{
    queue<node *> q;
    cout << "Enter data for root:" << endl;
    int data;
    cin >> data;
    root = new node(data);
    q.push(root);
    while (!q.empty())
    {
        node *temp = q.front();
        q.pop();
        cout << "Enter left node for " << temp->data << endl;
        int leftData;
        cin >> leftData;
        if (leftData != -1)
        {
            temp->left = new node(leftData);
            q.push(temp->left);
        }
        cout << "Enter right node for " << temp->data << endl;
        int rightData;
        cin >> rightData;
        if (rightData != -1)
        {
            temp->right = new node(rightData);
            q.push(temp->right);
        }
    }
}
int main()
{
    node *root = NULL;
    buildFromLevelOrder(root);
    levelOrderTraversal(root);
    return 0;
}

// Count leaf nodes

void inOrderTraversal(BinaryTreeNode<int> *root, int &count) {
  // base case
  if (root == NULL) {
    return;
  }
  // leaf node
  inOrderTraversal(root->left, count);
  if (root->left == NULL && root->right == NULL) {
    count++;
  }
  inOrderTraversal(root->right, count);
}
int noOfLeafNodes(BinaryTreeNode<int> *root) {
  int count = 0;
  inOrderTraversal(root, count);
  return count;
}

// Height of binary tree ( Max depth of binary tree )

class Solution{
    public:
    int height(struct Node* node){
        //base case
        if(node==NULL){
            return 0;
        }
        int left=height(node->left);
        int right=height(node->right);
        int ans=max(left,right)+1;
        return ans;
    }
};

// Diameter of binary tree

// Method-1
class Solution{
    public:
    int height(Node*root)
    {   
    	 if(root==NULL)
         {
         return 0;
         }
         int h1=height(root->left);
         int h2=height(root->right);
         return (max(h1,h2)+1);
     }
    int diameter(Node* root) {
        if(root==NULL)
        {
            return 0;
        }
        int h1=height(root->left);
        int h2=height(root->right);
        int op1=h1+h2+1;
        int op2=diameter(root->left);
        int op3=diameter(root->right);
        return (max(op1,(max(op2,op3))));
    }
};

// Method-2
class Solution
{
public:
    pair<int,int> diameterFast(Node *root){
        if(root == NULL){
            pair<int,int>p = make_pair(0,0);
            return p;
        }
        pair<int,int> left = diameterFast(root->left);
        pair<int,int> right = diameterFast(root->right);
        
        int op1 = left.first;
        int op2 = right.first;
        int op3 = left.second + right.second + 1;
        
        pair<int,int>ans;
        ans.first = max(op1,max(op2,op3));
        ans.second = max(left.second, right.second)+1;
        return ans;
    }
    int diameter(Node* root) {
        
        return diameterFast(root).first;
    }
};

// Check for balanced tree

// Method-1
class Solution
{
public:
    int height(struct Node *node)
    {
        if (node == NULL)
        {
            return 0;
        }
        int left = height(node->left);
        int right = height(node->right);
        int ans = max(left, right) + 1;
        return ans;
    }
    bool isBalanced(Node *root)
    {
        if (root == NULL)
        {
            return 1;
        }
        bool left = isBalanced(root->left);
        bool right = isBalanced(root->right);
        bool diff = abs(height(root->left) - height(root->right)) <= 1;
        if (left && right && diff)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
};

// Method-2
class Solution
{
public:
    class Solution {
public:
    pair<bool,int> isBalancedFast(TreeNode *root){
        if(root == NULL){
            pair<bool,int> p = make_pair(true,0);
            return p;
        }
        pair<int,int> left = isBalancedFast(root->left);
        pair<int,int> right = isBalancedFast(root->right);
        
        bool leftAns=left.first;
        bool rightAns=right.first;
        
        bool diff = abs(left.second - right.second) <= 1;
        
        pair<bool,int> ans;
        ans.second=max(left.second,right.second)+1;
        
        if (leftAns && rightAns && diff)
        {
            ans.first=1;
        }
        else
        {
            ans.first=0;
        }
        
        return ans;
    }
    bool isBalanced(TreeNode* root) {
        return isBalancedFast(root).first;
    }
};

// Determine if two trees are identical or not

class Solution
{
    public:
    bool isIdentical(Node *r1, Node *r2)
    {
        if(r1==NULL && r2==NULL){
            return true;
        }
        if(r1==NULL && r2!=NULL){ 
            return false;
        }
        if(r1!=NULL && r2==NULL){ 
            return false;
        }
        if(r1->data!=r2->data){
            return false;
        }
        else{
            return (isIdentical(r1->left,r2->left) && isIdentical(r1->right,r2->right));
        }
    }
};

// Sum tree

// Method-1
int sumTree(TreeNode<int> *root) {
    if(root == NULL) return 0;
    return root->val + sumTree(root->left) + sumTree(root->right);
} 
bool isSumTree(TreeNode<int> *root)
{
    if(root == NULL) return true;
    if(root->left == NULL && root->right == NULL) return true;
    if(isSumTree(root->left) && isSumTree(root->right)) {
        int l = sumTree(root->left);
        int r = sumTree(root->right);
        if(root->val == (l+r)) return true;
        return false;
    }
    return false;
}

// Method-2
class Solution
{
    public:
    pair<bool,int> solve(Node* root){
        if(root==NULL){
            pair<bool,int>p=make_pair(true,0);
            return p;
        }
        if(root->left==NULL && root->right==NULL){
        pair<bool,int>p=make_pair(true,root->data);
        return p;
        }
        pair<bool,int> leftans=solve(root->left);
        pair<bool,int> rightans=solve(root->right);
        bool l=leftans.first;
        bool r=rightans.first;
        bool condn=root->data==leftans.second+ rightans.second;
        pair<bool,int> ans;
        if(l&&r&&condn){
            ans.first=true;
            ans.second=2*root->data;
        }
        else{
            ans.first=false;
        }
        return ans;   
    }
    bool isSumTree(Node* root)
    {
         return solve(root).first;
    }
};

// Zig-Zag Traversal Of Binary Tree

class Solution
{
public:
    vector<int> zigZagTraversal(Node *root)
    {
        vector<int> result;
        if (root == NULL)
        {
            return result;
        }
        queue<Node *> q;
        q.push(root);
        bool leftToRight = true;
        while (!q.empty())
        {
            int size = q.size();
            vector<int> ans(size);
            // level process
            for (int i = 0; i < size; i++)
            {
                Node *frontNode = q.front();
                q.pop();
                // normal insert or revrse insert
                int index = leftToRight ? i : size - i - 1;
                ans[index] = frontNode->data;
                if (frontNode->left)
                {
                    q.push(frontNode->left);
                }
                if (frontNode->right)
                {
                    q.push(frontNode->right);
                }
            }
            // direction change karni hai
            leftToRight = !leftToRight;
            for (auto i : ans)
            {
                result.push_back(i);
            }
        }
        return result;
    }
};

// Boundary Traversal Of Binary Tree

class Solution {
public:
    void traverseLeft(Node* root, vector<int> &ans) {
        //base case
        if( (root == NULL) || (root->left == NULL && root->right == NULL) )
            return ;
            
        ans.push_back(root->data);
        if(root->left)
            traverseLeft(root->left, ans);
        else
            traverseLeft(root->right, ans);
            
    }
    
    void traverseLeaf(Node* root, vector<int> &ans) {
        //base case
        if(root == NULL)
            return ;
            
        if(root->left == NULL && root->right == NULL) {
            ans.push_back(root->data);
            return;
        }
        
        traverseLeaf(root->left, ans);
        traverseLeaf(root->right, ans);
        
    }
    
    void traverseRight(Node* root, vector<int> &ans) {
        //base case
        if( (root == NULL) || (root->left == NULL && root->right == NULL) )
            return ;
        
        if(root->right)
            traverseRight(root->right, ans);
        else
            traverseRight(root->left, ans);
            
        //wapas aagye
        ans.push_back(root->data);
            
    }
    
    vector <int> boundary(Node *root)
    {
        vector<int> ans;
        if(root == NULL)
            return ans;
            
        ans.push_back(root->data);
        
        //left part print/store
        traverseLeft(root->left, ans);
        
        //traverse Leaf Nodes
        
        //left subtree
        traverseLeaf(root->left, ans);
        //right subtree
        traverseLeaf(root->right, ans);
        
        //traverse right part
        traverseRight(root->right, ans);
        
        return ans;
    }
};

// Vertical Order Traversal Of Binary Tree

class Solution
{
    public:
    vector<int> verticalOrder(Node *root)
    {
        map<int, map<int,vector<int> > > nodes;
        queue< pair<Node*, pair<int,int> > > q;
        vector<int> ans;
        
        if(root == NULL)
            return ans;
            
        q.push(make_pair(root, make_pair(0,0)));
        
        while(!q.empty()) {
            pair<Node*, pair<int,int> > temp = q.front();
            q.pop();
            Node* frontNode = temp.first;
            int hd = temp.second.first;
            int lvl = temp.second.second;
            
            nodes[hd][lvl].push_back(frontNode->data);
            
            if(frontNode->left)
                q.push(make_pair(frontNode->left, make_pair(hd-1, lvl+1) ));
                
            if(frontNode->right)
                q.push(make_pair(frontNode->right, make_pair(hd+1, lvl+1)));
        }
        
        for(auto i: nodes) {
            
            for(auto j:i.second) {
                
                for(auto k:j.second)
                {
                    ans.push_back(k);
                }
            }
        }
        return ans;
    }
};

// Top View of the Binary Tree

class Solution
{
    public:
    //Function to return a list of nodes visible from the top view 
    //from left to right in Binary Tree.
    vector<int> topView(Node *root)
    {
        vector<int> ans;
        if(root == NULL) 
        {
            return ans;
        }
        
        map<int,int> topNode;
        queue<pair<Node*, int> > q;
        
        q.push(make_pair(root, 0));
        
        while(!q.empty()) {
            pair<Node*, int> temp = q.front();
            q.pop();
            Node* frontNode = temp.first;
            int hd = temp.second;
            
            //if one value is present for a HD, then do nothing
            if(topNode.find(hd) == topNode.end())
                topNode[hd] = frontNode -> data;
                
            if(frontNode->left)
                q.push(make_pair(frontNode->left, hd-1));
            if(frontNode->right)
                q.push(make_pair(frontNode->right, hd+1));
        }
        
        for(auto i:topNode) 
        {
            ans.push_back(i.second);
        }
        return ans;
    }
};

// Bottom View of the Binary Tree

class Solution {
  public:
    vector <int> bottomView(Node *root) {
         vector<int> ans;
        if(root == NULL) 
        {
            return ans;
        }
        
        map<int,int> topNode;
        queue<pair<Node*, int> > q;
        
        q.push(make_pair(root, 0));
        
        while(!q.empty()) {
            pair<Node*, int> temp = q.front();
            q.pop();
            Node* frontNode = temp.first;
            int hd = temp.second;
            
            topNode[hd] = frontNode -> data;
                
            if(frontNode->left)
                q.push(make_pair(frontNode->left, hd-1));
            if(frontNode->right)
                q.push(make_pair(frontNode->right, hd+1));
        }
        
        for(auto i:topNode) 
        {
            ans.push_back(i.second);
        }
        return ans;
    }
};

// Left View of the Binary Tree

void solve(Node *root, vector<int> &ans, int level)
{
    // base case
    if (root == NULL)
    {
        return;
    }
    // we entered into a new level
    if (level == ans.size())
    {
        ans.push_back(root->data);
    }
    solve(root->left, ans, level + 1);
    solve(root->right, ans, level + 1);
}
vector<int> leftView(Node *root)
{
    vector<int> ans;
    solve(root, ans, 0);
    return ans;
}

// Right View of the Binary Tree

class Solution
{
    public:
    void solve(Node *root, vector<int> &ans, int level)
    {
        // base case
        if (root == NULL)
        {
            return;
        }
        // we entered into a new level
        if (level == ans.size())
        {
            ans.push_back(root->data);
        }
        solve(root->right, ans, level + 1);
        solve(root->left, ans, level + 1);
    }
    vector<int> rightView(Node *root)
    {
        vector<int> ans;
        solve(root, ans, 0);
        return ans;
    }
};

// Diagonal Traversal in Binary tree

vector<int> diagonal(Node *root)
{
   vector<int>ans;
   if(root==NULL)
   {
       return ans;
   }  
   queue<Node*>q;
   q.push(root);
   while(!q.empty())
   {
       Node* temp=q.front();
       q.pop();
       ans.push_back(temp->data);
       if(temp->left)
       {
           q.push(temp->left);
       }
       while(temp->right!=NULL)
       {
           temp=temp->right;
           ans.push_back(temp->data);
           if(temp->left)
           {
               q.push(temp->left);
           }
       }
   }
   return ans;
}

// Sum of the Longest Bloodline of a Tree (Sum of nodes on the longest path from root to leaf node)

class Solution
{
public:
    void solve(Node *root,int sum,int &maxSum,int len,int &maxLen){
        // base case
        if(root==NULL){
            if(len>maxLen){
                maxLen=len;
                maxSum=sum;
            }
            else if(len==maxLen){
                maxSum=max(sum,maxSum);
            }
            return;
        }
        sum=sum+root->data;
        solve(root->left,sum,maxSum,len+1,maxLen);
        solve(root->right,sum,maxSum,len+1,maxLen);
    }
    int sumOfLongRootToLeafPath(Node *root)
    {
        int len=0,maxLen=0,sum=0,maxSum=INT_MIN;
        solve(root,sum,maxSum,len,maxLen);
        return maxSum;
    }
};

// Lowest Common Ancestor in a Binary Tree

class Solution
{
    public:
    //Function to return the lowest common ancestor in a Binary Tree.
    Node* lca(Node* root ,int n1 ,int n2 )
    {
        // base case
        if(root==NULL){
            return NULL;
        }
        if(root->data==n1 || root->data==n2){
            return root;
        }
        Node *leftAns=lca(root->left,n1,n2);
        Node *rightAns=lca(root->right,n1,n2);
        if(leftAns!=NULL && rightAns!=NULL){
            return root;
        }
        else if(leftAns!=NULL && rightAns==NULL){
            return leftAns;
        }
        else if(leftAns==NULL && rightAns!=NULL){
            return rightAns;
        }
        else{
            return NULL;
        }
    }
};

// K sum paths

class Solution{
    public:
    void check(Node *root, int k, int &count, int sum, unordered_map<int, int> &mp) {
        if(root == NULL) 
            return;
        sum += root->data;
        count += mp[sum-k];
        if(sum == k)
            count++;
        mp[sum]++;
        check(root->left, k, count, sum, mp);
        check(root->right, k, count, sum, mp);   
        mp[sum]--;
    }
    int sumK(Node *root,int k)
    { 
        int count = 0;
        unordered_map<int, int> mp;
        check(root, k, count, 0, mp);
        return count;
    }
};

// Kth ancestor in a binary tree 

// Method-1
bool solve(Node *root,int &k, int node,int &ans){
    if(root == NULL) return false;
    
    if(root->data == node) return true;
    bool left = solve(root->left,k,node,ans);
    bool right = solve(root->right, k,node,ans);
    
    if(left||right){
        k--;
        if(k==0) ans = root->data;
        return true;
    }
    return false;
}
int kthAncestor(Node *root, int k, int node)
{
    int ans;
    solve(root,k,node,ans);
    if(k>0) return -1;         // If k is greater than required distance b/w nodes.
    return ans;
}

// Method-2
Node* solve(Node* root,int &k,int node){
    if(root==NULL){
        return NULL;
    }
    if(root->data==node){
        return root;
    }
    Node *leftAns=solve(root->left,k,node);
    Node *rightAns=solve(root->right,k,node);
    if(leftAns!=NULL && rightAns==NULL){
        k--;
        if(k==0){
            k=INT_MAX;
            return root;
        }
        return leftAns;
    }
    if(leftAns==NULL && rightAns!=NULL){
        k--;
        if(k==0){
            k=INT_MAX;
            return root;
        }
        return rightAns;
    }
    return NULL;
}
int kthAncestor(Node *root, int k, int node)
{
    Node* ans=solve(root,k,node);
    if((ans==NULL) || (ans->data==node)){
        return -1;   
    }
    else{
        return ans->data;
    }
}

// Maximum sum of non-adjacent nodes

class Solution{
  public:
    pair<int,int> solve(Node *root){
        if(root==NULL){
            pair<int,int> p=make_pair(0,0);
            return p;
        }
        pair<int,int> left=solve(root->left);
        pair<int,int> right=solve(root->right);
        pair<int,int> res;
        res.first=root->data+left.second+right.second;
        res.second=max(left.first,left.second)+max(right.first,right.second);
        return res;
    }
    int getMaxSum(Node *root) 
    {
        pair<int,int> ans=solve(root);
        return max(ans.first,ans.second);
    }
};

// Construct Tree from given Inorder and Preorder traversals

// Method-1
class Solution{
    public:
    int findposition(int in[],int element,int start,int end)
    {
        for(int i=start;i<=end;i++)
        {
            if(in[i]==element)
            return i;
        }
        return -1;
    }
    Node* solve(int in[],int pre[],int &index,int inorderstart,int inorderend,int n)
    {
        if(index>=n || inorderstart >inorderend){
            return NULL;
        }
        
        int element = pre[index++];
        Node* root = new Node(element);
        int position = findposition(in,element,inorderstart,inorderend);
        
        root->left=solve(in,pre,index,inorderstart,position-1,n);
        root->right=solve(in,pre,index,position+1,inorderend,n);
        
        return root;
    }
    Node* buildTree(int in[],int pre[], int n)
    {
        int preorderindex=0;
        Node* ans = solve(in,pre,preorderindex,0,n-1,n);
        return ans;
    }
};

// Method-2
class Solution{
    public:
    Node* solve(int in[], int pre[], int n, int &index, int s, int e, unordered_map<int, vector<int>> &m){
        if(index>=n || s>e)
            return NULL;
            
            int element = pre[index++];
            Node* root = new Node(element);
            int pos = -1;
            if(m[element][0] == INT_MIN){
                 pos = m[element][1];
                m[element][1] = INT_MIN;
            }
            else{
                pos = m[element][0];
                m[element][0] = INT_MIN;
            }
                
            root->left = solve(in, pre, n, index, s, pos-1, m);
            root->right = solve(in, pre, n, index, pos+1, e, m);
            
            return root;
    }
    
    Node* buildTree(int in[],int pre[], int n)
    {
        unordered_map<int, vector<int>>index;
        for(int i= 0; i<n; i++)
            index[in[i]].push_back(i);
            
            int preindex = 0;
            return solve(in, pre, n, preindex, 0, n-1, index);
    }
};

// Construct Tree from given Inorder and Postorder traversals

// Method-1
Node* solve(int in[], int post[], int inStart, int inEnd, int postStart, int postEnd) {
    if(inStart > inEnd){
        return NULL;
    }
    Node* root = new Node(post[postEnd]);
    int i = inStart;
    for(; i<= inEnd; i++) {
        if(in[i] == root->data)
            break;
    }
    int leftSize  = i - inStart;
    int rightSize = inEnd - i;
    root->left  = solve(in, post, inStart, i-1, postStart, postStart + leftSize - 1);
    root->right = solve(in, post, i+1, inEnd, postEnd - rightSize, postEnd-1);
    return root;
}
Node *buildTree(int in[], int post[], int n) {
    return solve(in, post, 0, n-1, 0, n-1);
}

// Method-2
Node*solve(int in[], int post[], int &index,int s,int e,int n,unordered_map<int,int>&mp)
{
    if(index<0 || s>e){
        return NULL;
    }
    int element=post[index--];
    Node*root=new Node(element);
    int pos=mp[element];
    root->right=solve(in,post,index,pos+1,e,n,mp);
    root->left=solve(in,post,index,s,pos-1,n,mp);
    return root;
}
Node *buildTree(int in[], int post[], int n) {
    unordered_map<int,int>mp;
    for(int i=0;i<n;i++)
    {
        mp[in[i]]=i;
    }
    int index=n-1;
    return solve(in,post,index,0,n-1,n,mp);
}

// Minimum Time To Burn A Tree

class Solution {
  public:
    // create mapping and return target node
    Node* createParentMapping(Node* root, int target,map<Node*,Node*> &nodeToParent){
        Node* res=NULL;
        queue<Node*> q;
        q.push(root);
        nodeToParent[root]=NULL;
        while(!q.empty()){
            Node* front=q.front();
            q.pop();
            if(front->data==target){
                res=front;
            }
            if(front->left){
                nodeToParent[front->left]=front;
                q.push(front->left);
            }
            if(front->right){
                nodeToParent[front->right]=front;
                q.push(front->right);
            }
        }
        return res;
    }
    int burnTree(Node* root,map<Node*,Node*> &nodeToParent){
        map<Node*,bool> visited;
        queue<Node*> q;
        q.push(root);
        visited[root]=true;
        int ans=0;
        while(!q.empty()){
            bool flag=0;
            int size=q.size();
            for(int i=0;i<size;i++){
                // processing neighbouring nodes
                Node* front=q.front();
                q.pop();
                if(front->left && !visited[front->left]){
                    flag=true;
                    q.push(front->left);
                    visited[front->left]=1;
                }
                if(front->right && !visited[front->right]){
                    flag=true;
                    q.push(front->right);
                    visited[front->right]=1;
                }
                if(nodeToParent[front] && !visited[nodeToParent[front]]){
                    flag=true;
                    q.push(nodeToParent[front]);
                    visited[nodeToParent[front]]=1;
                }
            }
            if(flag==1){
                ans++;
            }
        }
        return ans;
    }
    int minTime(Node* root, int target) 
    {
        map<Node*,Node*> nodeToParent;
        Node* targetNode=createParentMapping(root,target,nodeToParent);
        int ans=burnTree(targetNode,nodeToParent);
        return ans;
    }
};

// Morris Traversal ( T.C. => O(n) , S.C. => O(1) )

// Morris traversal for inorder traversal

#include <iostream>
using namespace std;
/* Node Structure in a threaded binary tree */
struct Node
{
    int value;
    struct Node *left;
    struct Node *right;
};
/* Function to traverse the binary tree without using any additional space */
void Morris(struct Node *root)
{
    struct Node *current, *prev;
    if (root == NULL)
        return;
    current = root;
    while (current != NULL)
    {
        if (current->left == NULL)
        {
            cout << current->value << "\t";
            current = current->right;
        }
        else
        {
            /* Find the previous node of the current node */
            prev = current->left;
            while (prev->right != NULL && prev->right != current)
                prev = prev->right;
            /* Make current node as the right child of its previous node */
            if (prev->right == NULL)
            {
                prev->right = current;
                current = current->left;
            }
            /* fix the right child of previous */
            else
            {
                prev->right = NULL;
                cout << current->value << "\t";
                current = current->right;
            }
        }
    }
}
/* Function allocates a new Node with the given value and the left and right pointers to NULL. */
struct Node *add_node(int value)
{
    struct Node *node = new Node;
    node->value = value;
    node->left = NULL;
    node->right = NULL;

    return (node);
}
int main()
{
    struct Node *root = add_node(20);
    root->left = add_node(40);
    root->right = add_node(60);
    root->left->left = add_node(80);
    root->left->right = add_node(100);
    Morris(root);
    return 0;
}

// Morris traversal for Preorder traversal
#include <bits/stdc++.h>
using namespace std;
class node
{
	public:
	int data;
	node *left, *right;
};
// Helper function that allocates a new node with the given data and NULL left and right pointers. 
node* newNode(int data)
{
	node* temp = new node();
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}
// Preorder traversal without recursion and without stack
void morrisTraversalPreorder(node* root)
{
	while (root)
	{
		// If left child is null, print the current node data. Move to right child.
		if (root->left == NULL)
		{
			cout<<root->data<<" ";
			root = root->right;
		}
		else
		{
			// Find inorder predecessor
			node* current = root->left;
			while (current->right && current->right != root)
				current = current->right;
			// If the right child of inorder predecessor already points to this node
			if (current->right == root)
			{
				current->right = NULL;
				root = root->right;
			}
			// If right child doesn't point to this node, then print this node and make right child point to this node
			else
			{
				cout<<root->data<<" ";
				current->right = root;
				root = root->left;
			}
		}
	}
}
// Function for Standard preorder traversal
void preorder(node* root)
{
	if (root)
	{
		cout<<root->data<<" ";
		preorder(root->left);
		preorder(root->right);
	}
}
int main()
{
	node* root = NULL;
	root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->left->left->left = newNode(8);
	root->left->left->right = newNode(9);
	root->left->right->left = newNode(10);
	root->left->right->right = newNode(11);
	morrisTraversalPreorder(root);
	cout<<endl;
	preorder(root);
	return 0;
}

// Morris traversal for Postorder traversal

#include <bits/stdc++.h>
using namespace std;
struct TreeNode {
	int key;
	TreeNode* left;
	TreeNode* right;
	TreeNode(int data)
	{
		key = data;
		left = NULL;
		right = NULL;
	}
};
// Function to print vector
void print(vector<int>& ans)
{
	// Print the vector elements
	for (auto x : ans) {
		cout << x << " ";
	}
}
// Postorder traversal Without recursion and without stack
vector<int> postorderTraversal(TreeNode* root)
{
	vector<int> res;
	TreeNode* current = root;
	while (current != NULL) {
		// If right child is null, put the current node data in res. Move to left child.
		if (current->right == NULL) {
			res.push_back(current->key);
			current = current->left;
		}
		else {
			TreeNode* predecessor = current->right;
			while (predecessor->left != NULL
				&& predecessor->left != current) {
				predecessor = predecessor->left;
			}
			// If left child doesn't point to this node, then put in res this node and make left child point to this node
			if (predecessor->left == NULL) {
				res.push_back(current->key);
				predecessor->left = current;
				current = current->right;
			}
			// If the left child of inorder predecessor already points to this node
			else {
				predecessor->left = NULL;
				current = current->left;
			}
		}
	}
	// reverse the res
	reverse(res.begin(), res.end());
	return res;
}
int main()
{
	TreeNode* root = new TreeNode(10);
	root->left = new TreeNode(20);
	root->right = new TreeNode(30);
	root->right->left = new TreeNode(40);
	root->right->right = new TreeNode(50);
	cout << "Morris(postorder) Traversal: ";
	vector<int> ans = postorderTraversal(root);
	print(ans);
	return 0;
}

// Flatten a binary tree to Linked List

class Solution
{
    public:
    void flatten(Node *root)
    {
        Node* curr=root;
        while(curr!=NULL)
        {
            if(curr->left)
            {
                Node* pred=curr->left;
                while(pred->right){
                    pred=pred->right;
                }
                pred->right=curr->right;
                curr->right=curr->left;
                curr->left=NULL;
            }
            curr=curr->right;
        }   
    }
};

// Insertion in Binary Search Tree ( LevelOrder, ReverseLevelOrder, Inorder, Preorder, Postorder Traversals )

#include<iostream>
#include<queue>
#include<stack>
using namespace std;
class Node{
    public:
        int data;
        Node* left;
        Node* right;
    Node(int d){
        this->data=d;
        this->left=NULL;
        this->right=NULL;
    }
};
Node* levelOrderTraversal(Node *root)
{
    queue<Node *> q;
    q.push(root);
    q.push(NULL);
    while (!q.empty())
    {
        Node *temp = q.front();
        q.pop();
        if (temp == NULL)
        { // purana level complete traverse ho chuka hai
            cout << endl;
            if (!q.empty())
            { // queue still has some child nodes
                q.push(NULL);
            }
        }
        else
        {
            cout << temp->data << " ";
            if (temp->left)
            {
                q.push(temp->left);
            }
            if (temp->right)
            {
                q.push(temp->right);
            }
        }
    }
}
void reverseLevelTraversal(Node *root)
{
    queue<Node*> q;
    q.push(root);
    q.push(NULL);
    // q.push(NULL);
    stack<Node *> s;
    while (!q.empty())
    {
        Node *temp = q.front();
        s.push(temp);
        q.pop();
        if (temp == NULL)
        {
            if (!q.empty())
            {
                q.push(NULL);
            }
        }
        else
        {
            if (temp->right)
            {
                q.push(temp->right);
            }
            if (temp->left)
            {
                q.push(temp->left);
            }
        }
    }
    while (!s.empty())
    {
        Node *temp = s.top();
        s.pop();
        if (temp == NULL)
        {
            cout << endl;
        }
        else
        {
            cout << temp->data << " ";
        }
    }
}
void inOrderTraversal(Node *root){
    if(root==NULL){
        return;
    }
    inOrderTraversal(root->left);
    cout<<root->data<<" ";
    inOrderTraversal(root->right);
}
void PreOrderTraversal(Node *root){
    if(root==NULL){
        return;
    }
    cout<<root->data<<" ";
    PreOrderTraversal(root->left);
    PreOrderTraversal(root->right);
}
void PostOrderTraversal(Node *root){
    if(root==NULL){
        return;
    }
    PostOrderTraversal(root->left);
    PostOrderTraversal(root->right);
    cout<<root->data<<" ";
}
Node* insertIntoBST(Node* root,int d){
    if(root==NULL){
        root=new Node(d);
        return root;
    }
    if(d>root->data){
        // right part me insert karna hai
        root->right=insertIntoBST(root->right,d);
    }
    else{
        // left part me insert karna hai
        root->left=insertIntoBST(root->left,d);
    }
    return root;
}
void takeInput(Node* &root){
    int data;
    cin>>data;
    while(data!=-1){
        root=insertIntoBST(root,data);
        cin>>data;
    }
}
int main(){
    Node* root=NULL;
    cout<<"Enter data to create BST"<<endl;
    takeInput(root);
    cout<<"Level Order Traversal"<<endl;
    levelOrderTraversal(root);
    cout<<"Reverse Level Order Traversal "<<endl;
    reverseLevelTraversal(root);
    cout<<endl;
    cout<<"InOrder Traversal ";
    inOrderTraversal(root);
    cout<<endl;
    cout<<"PreOrder Traversal ";
    PreOrderTraversal(root);
    cout<<endl;
    cout<<"PostOrder Traversal ";
    PostOrderTraversal(root);
    cout<<endl;
    return 0;
}

// Search In BST

// Method-1
bool searchInBST(BinaryTreeNode<int> *root, int x) {
    if(root==NULL){
    	return false;
    }
    if(root->data==x){
    	return true;
    }
    if(root->data < x){
    	return searchInBST(root->right,x);
    }
    else{
    	return searchInBST(root->left,x);
    }
}

// Method-2
bool searchInBST(BinaryTreeNode<int> *root, int x) {
    BinaryTreeNode<int> *temp=root;
    while(temp!=NULL){
        if(temp->data==x){
            return true;
        }
        if(x > temp->data){
            temp=temp->right;
        } 
        else {
            temp=temp->left;
        }
    }
    return false;
}

// Maximum and Minimum element

#include<iostream>
#include<queue>
#include<stack>
using namespace std;
class Node{
    public:
        int data;
        Node* left;
        Node* right;
    Node(int d){
        this->data=d;
        this->left=NULL;
        this->right=NULL;
    }
};
Node* levelOrderTraversal(Node *root)
{
    queue<Node *> q;
    q.push(root);
    q.push(NULL);
    while (!q.empty())
    {
        Node *temp = q.front();
        q.pop();
        if (temp == NULL)
        { // purana level complete traverse ho chuka hai
            cout << endl;
            if (!q.empty())
            { // queue still has some child nodes
                q.push(NULL);
            }
        }
        else
        {
            cout << temp->data << " ";
            if (temp->left)
            {
                q.push(temp->left);
            }
            if (temp->right)
            {
                q.push(temp->right);
            }
        }
    }
}
void reverseLevelTraversal(Node *root)
{
    queue<Node*> q;
    q.push(root);
    q.push(NULL);
    // q.push(NULL);
    stack<Node *> s;
    while (!q.empty())
    {
        Node *temp = q.front();
        s.push(temp);
        q.pop();
        if (temp == NULL)
        {
            if (!q.empty())
            {
                q.push(NULL);
            }
        }
        else
        {
            if (temp->right)
            {
                q.push(temp->right);
            }
            if (temp->left)
            {
                q.push(temp->left);
            }
        }
    }
    while (!s.empty())
    {
        Node *temp = s.top();
        s.pop();
        if (temp == NULL)
        {
            cout << endl;
        }
        else
        {
            cout << temp->data << " ";
        }
    }
}
void inOrderTraversal(Node *root){
    if(root==NULL){
        return;
    }
    inOrderTraversal(root->left);
    cout<<root->data<<" ";
    inOrderTraversal(root->right);
}
void PreOrderTraversal(Node *root){
    if(root==NULL){
        return;
    }
    cout<<root->data<<" ";
    PreOrderTraversal(root->left);
    PreOrderTraversal(root->right);
}
void PostOrderTraversal(Node *root){
    if(root==NULL){
        return;
    }
    PostOrderTraversal(root->left);
    PostOrderTraversal(root->right);
    cout<<root->data<<" ";
}
Node* minVal(Node* root){
    Node* temp=root;
    while(temp->left!=NULL){
        temp=temp->left;
    }
    return temp;
}
Node* maxVal(Node* root){
    Node* temp=root;
    while(temp->right!=NULL){
        temp=temp->right;
    }
    return temp;
}
Node* insertIntoBST(Node* root,int d){
    if(root==NULL){
        root=new Node(d);
        return root;
    }
    if(d>root->data){
        // right part me insert karna hai
        root->right=insertIntoBST(root->right,d);
    }
    else{
        // left part me insert karna hai
        root->left=insertIntoBST(root->left,d);
    }
    return root;
}
void takeInput(Node* &root){
    int data;
    cin>>data;
    while(data!=-1){
        root=insertIntoBST(root,data);
        cin>>data;
    }
}
int main(){
    Node* root=NULL;
    cout<<"Enter data to create BST"<<endl;
    takeInput(root);
    cout<<"Level Order Traversal"<<endl;
    levelOrderTraversal(root);
    cout<<"Reverse Level Order Traversal "<<endl;
    reverseLevelTraversal(root);
    cout<<endl;
    cout<<"InOrder Traversal ";
    inOrderTraversal(root);
    cout<<endl;
    cout<<"PreOrder Traversal ";
    PreOrderTraversal(root);
    cout<<endl;
    cout<<"PostOrder Traversal ";
    PostOrderTraversal(root);
    cout<<endl;
    cout<<"Maximum Element: " << maxVal(root)->data <<endl;
    cout<<"Minimum Element: " << minVal(root)->data <<endl;
    return 0;
}

// Predecessor and Successor

// Find predecessor and successor in a BST

#include <iostream>
using namespace std;
// BST Node
struct Node
{
	int key;
	struct Node *left;
	struct Node *right;
	
	Node(int x){
	    key = x;
	    left = NULL;
	    right = NULL;
	}
};
int key=0;
// This function finds predecessor and successor of key in BST.
// It sets pre and suc as predecessor and successor respectively
void findPreSuc(Node* root, Node*& pre, Node*& suc, int key);
 void insert(struct Node *root,int n1,int n2,char lr)
 {
     if(root==NULL)
        return;
     if(root->key==n1)
     {
         switch(lr)
         {
          case 'L': root->left=new Node(n2);
                    break;
          case 'R': root->right=new Node(n2);
                    break;
         }
     }
     else
     {
         insert(root->left,n1,n2,lr);
         insert(root->right,n1,n2,lr);
     }
 }
// Driver program to test above functions
int main()
{
    /* Let us construct the tree shown in above diagram */
    int t,k;
    cin>>t;
    while(t--)
    {
    int n;
    cin>>n;
    struct Node *root=NULL;
    Node *pre=NULL;
    Node *suc=NULL;
    while(n--)
    {
        char lr;
        int n1,n2;
        cin>>n1>>n2;
        cin>>lr;
        if(root==NULL)
        {
            root=new Node(n1);
            switch(lr){
                    case 'L': root->left=new Node(n2);
                    break;
                    case 'R': root->right=new Node(n2);
                    break;
                    }
        }
        else
        {
            insert(root,n1,n2,lr);
        }
    }
   // Inorder(root);
    //Node * target =ptr;
    //printkdistanceNode(root, target, k);
    //cout<<endl;
    cin>>key;
    findPreSuc(root, pre, suc, key);
	if (pre != NULL)
	cout << pre->key;
	else
	cout << "-1";

	if (suc != NULL)
	cout <<" "<<suc->key<<endl;
	else
	cout << " "<<"-1"<<endl;
    }
	return 0;
}
// BST Node
struct Node
{
	int key;
	struct Node *left, *right;
};

Node *successor(Node *root, int key){
    Node *suc = NULL;
    while(root != NULL){
        if(key >= root->key){
            root = root->right;
        }
        else{
            suc = root;
            root = root->left;
        }
    }
    return suc;
}
Node *precessor(Node *root, int key){
    Node *pre = NULL;
    while(root != NULL){
        if(key <= root->key){
            root = root->left;
        }
        else{
            pre = root;
            root = root->right;
        }
    }
    return pre;
 }
// It sets pre and suc as predecessor and successor respectively
void findPreSuc(Node* root, Node*& pre, Node*& suc, int key)
{
    suc = successor(root,key);
    pre = precessor(root,key);
}

// Deletion in BST

#include<iostream>
#include<queue>
#include<stack>
using namespace std;
class Node{
    public:
        int data;
        Node* left;
        Node* right;
    Node(int d){
        this->data=d;
        this->left=NULL;
        this->right=NULL;
    }
};
Node* levelOrderTraversal(Node *root)
{
    queue<Node *> q;
    q.push(root);
    q.push(NULL);
    while (!q.empty())
    {
        Node *temp = q.front();
        q.pop();
        if (temp == NULL)
        { // purana level complete traverse ho chuka hai
            cout << endl;
            if (!q.empty())
            { // queue still has some child nodes
                q.push(NULL);
            }
        }
        else
        {
            cout << temp->data << " ";
            if (temp->left)
            {
                q.push(temp->left);
            }
            if (temp->right)
            {
                q.push(temp->right);
            }
        }
    }
}
void reverseLevelTraversal(Node *root)
{
    queue<Node*> q;
    q.push(root);
    q.push(NULL);
    // q.push(NULL);
    stack<Node *> s;
    while (!q.empty())
    {
        Node *temp = q.front();
        s.push(temp);
        q.pop();
        if (temp == NULL)
        {
            if (!q.empty())
            {
                q.push(NULL);
            }
        }
        else
        {
            if (temp->right)
            {
                q.push(temp->right);
            }
            if (temp->left)
            {
                q.push(temp->left);
            }
        }
    }
    while (!s.empty())
    {
        Node *temp = s.top();
        s.pop();
        if (temp == NULL)
        {
            cout << endl;
        }
        else
        {
            cout << temp->data << " ";
        }
    }
}
void inOrderTraversal(Node *root){
    if(root==NULL){
        return;
    }
    inOrderTraversal(root->left);
    cout<<root->data<<" ";
    inOrderTraversal(root->right);
}
void PreOrderTraversal(Node *root){
    if(root==NULL){
        return;
    }
    cout<<root->data<<" ";
    PreOrderTraversal(root->left);
    PreOrderTraversal(root->right);
}
void PostOrderTraversal(Node *root){
    if(root==NULL){
        return;
    }
    PostOrderTraversal(root->left);
    PostOrderTraversal(root->right);
    cout<<root->data<<" ";
}
Node* minVal(Node* root){
    Node* temp=root;
    while(temp->left!=NULL){
        temp=temp->left;
    }
    return temp;
}
Node* maxVal(Node* root){
    Node* temp=root;
    while(temp->right!=NULL){
        temp=temp->right;
    }
    return temp;
}
Node* deleteFromBST(Node* root,int val){
    if(root==NULL){
        return root;
    }
    if(root->data==val){
        // 0 child
        if(root->right==NULL && root->left==NULL){
            delete root;
            return NULL;
        }
        //1 child
        
        // left child
        if(root->left!=NULL && root->right==NULL){
            Node* temp=root->left;
            delete root;
            return temp;
        }
        // right child
        if(root->left==NULL && root->right!=NULL){
            Node* temp=root->right;
            delete root;
            return temp;
        }
        // 2 child
        if(root->left!=NULL && root->right!=NULL){
            int mini=minVal(root->right)->data;
            root->data=mini;
            root->right=deleteFromBST(root->right,mini);
            return root;
        }
    }
    else if(root->data > val){
        // left part me jana hai
        root->left=deleteFromBST(root->left,val);
    }
    else{
        // right part me jana hai
        root->right=deleteFromBST(root->right,val);
    }
}
Node* insertIntoBST(Node* root,int d){
    if(root==NULL){
        root=new Node(d);
        return root;
    }
    if(d>root->data){
        // right part me insert karna hai
        root->right=insertIntoBST(root->right,d);
    }
    else{
        // left part me insert karna hai
        root->left=insertIntoBST(root->left,d);
    }
    return root;
}
void takeInput(Node* &root){
    int data;
    cin>>data;
    while(data!=-1){
        root=insertIntoBST(root,data);
        cin>>data;
    }
}
int main(){
    Node* root=NULL;
    cout<<"Enter data to create BST"<<endl;
    takeInput(root);
    cout<<"Level Order Traversal"<<endl;
    levelOrderTraversal(root);
    cout<<"Reverse Level Order Traversal "<<endl;
    reverseLevelTraversal(root);
    cout<<endl;
    cout<<"InOrder Traversal ";
    inOrderTraversal(root);
    cout<<endl;
    cout<<"PreOrder Traversal ";
    PreOrderTraversal(root);
    cout<<endl;
    cout<<"PostOrder Traversal ";
    PostOrderTraversal(root);
    cout<<endl;
    cout<<"Maximum Element: " << maxVal(root)->data <<endl;
    cout<<"Minimum Element: " << minVal(root)->data <<endl;
    return 0;
}

// Check BST or not

// Method-1
bool isBST(BinaryTreeNode<int> *root, int min, int max){
    if(root==NULL){
        return true;
    }
    if(root->data>=min && root->data<=max){
        bool left=isBST(root->left, min, root->data);
        bool right=isBST(root->right, root->data, max);
        return left && right;
    }
    else{
        return false;
    }
}
bool validateBST(BinaryTreeNode<int> *root) {
    return isBST(root, INT_MIN, INT_MAX);
}

// Method-2
void inorder(BinaryTreeNode<int> *root, vector<int>& ans){
    if(root==NULL){
        return;
    }
    inorder(root->left, ans);
    ans.push_back(root->data);
    inorder(root->right, ans);
}
bool validateBST(BinaryTreeNode<int> *root) {
    vector<int> ans;
    int c=0;
    inorder(root, ans);
    if(is_sorted(ans.begin(), ans.end()))
        return true;
     else
        return false;
}

// Predecessor and Successor in BST

void helper(binaryTreeNode *root, int key,int &suc,int &pre) {
	if(root==NULL) {
		return;
	}
	if(root->data > key) {
		suc=root->data;
		helper(root->left,key,suc,pre);
	}
	else if(root->data < key) {
		pre=root->data;
		helper(root->right,key,suc,pre);
	}
	else {
		binaryTreeNode *tmp=root->right;
		while(tmp && tmp->left) {
			tmp=tmp->left;
		}
		if(tmp) {
			suc=tmp->data;
		}
		tmp=root->left;
		while(tmp && tmp->right) {
			tmp=tmp->right;
		}
		if(tmp) {
			pre=tmp->data;
		}
		return;
	}
}
vector<int> findPreSuc(binaryTreeNode *root, int key) {
	int pre=-1,suc=-1;
	helper(root,key,suc,pre);
	return {pre,suc};
}

// Find K-th smallest Element in BST

// Method-1
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        int i=0, ans=0;
        TreeNode *prev, *curr;

        //NULL check
        if(root == NULL){
            return -1;
        }
        curr = root;
        while(curr){
            if(curr->left == NULL){
                i++;
                if(i == k){
                    ans = curr->val; 
                }
                curr = curr->right;
            }
            else{
                prev = curr->left;
                while(prev->right != NULL && prev->right != curr){
                    prev = prev->right;
                }

                if(prev->right == NULL){
                    prev->right = curr;
                    curr = curr->left;
                }
                else{
                    prev->right = NULL;
                    i++;
                    if(i == k){
                        ans = curr->val;
                    }
                    curr = curr->right;
                }
            }
        }
        return ans;        
    }
};

// Method-2
int solve(BinaryTreeNode<int>* root, int &i, int k){
    //base case
    if(root == NULL){
        return -1;
    }//Inorder - LNR since it is sorted, we increment i when a node is found
    // Left
    int left = solve(root->left, i,k);
    if(left != -1){
        return left;
    }
    // Node
    i++;
    if (i == k) {
        return root->data;
    }
    // Right
    return solve(root->right, i,k);    
}
int kthSmallest(BinaryTreeNode<int>* root, int k) {
    int i =0;
    int ans = solve(root, i, k);
    return ans;
}

// Find K-th Largest Element in BST

int solve(TreeNode<int>* root,int &i,int k){
    //base case
        if(root == NULL){
            return -1;
        }//Inorder - LNR since it is sorted, we increment i when a node is found
        // Right
        int right = solve(root->right, i,k);
        if(right != -1){
            return right;
        }
        // Node
        i++;
        if (i == k) {
            return root->data;
        }
        // Left
        return solve(root->left, i,k);
}
int KthLargestNumber(TreeNode<int>* root, int k) 
{
    int i=0;
    int ans=solve(root,i,k);
    return ans;
}

// LCA of two nodes in a BST

TreeNode<int>* LCAinaBST(TreeNode<int>* root, TreeNode<int>* P, TreeNode<int>* Q)
{
	while(root != NULL){
        if(root->data < P->data && root->data < Q->data){
            root = root->right;
        }
        else if(root->data > P->data && root->data > Q->data){
            root = root->left;
        }
        else{ 
            return root;
        }
    }
}

// Two Sum in a BST

// Method-1
void inorder(BinaryTreeNode<int>* root,vector<int>&ans){
   if(root==NULL)
       return ;
   inorder(root->left,ans);
   ans.push_back(root->data);
   inorder(root->right,ans);
}
bool twoSumInBST(BinaryTreeNode<int>* root, int target) {
   vector<int> ans;
   inorder(root,ans);
   int size=ans.size();
   int start=0,end=size-1;
   while(start<end){
       if(ans[start]+ans[end] == target)
           return true;
       else if(ans[start]+ans[end] > target)
           end--;
       else
           start++;
   }
   return false;
}

// Flatten BST to a sorted List

void inorder(TreeNode<int>* root, vector<int> &in){
    if(root == NULL)
        return;
    inorder(root->left, in);
    in.push_back(root->data);
    inorder(root->right, in);
}
TreeNode<int>* flatten(TreeNode<int>* root)
{
    vector<int> in;
    inorder(root, in);
    int n = in.size();
    TreeNode<int>* newRoot = new TreeNode<int>(in[0]);
    TreeNode<int>* curr = newRoot;
    for(int i = 1; i < n; i++){
        TreeNode<int>* temp = new TreeNode<int>(in[i]);
        curr->right = NULL;
        curr->left = temp;
        curr = temp;
    }
    curr->left = NULL;
    curr->right = NULL;
    return newRoot;
}

// Normal BST to Balanced BST

void inorder(TreeNode<int>* root, vector<int> &inorderVal){
    if(root == NULL){
        return;
    }
    inorder(root->left, inorderVal);
    inorderVal.push_back(root->data);
    inorder(root->right, inorderVal);
}
TreeNode<int>* inorderToBST(int s, int e, vector<int> inorderVal){
    if(s > e){
        return NULL;
    }
    int mid = (s+e)/2;
    TreeNode<int>* root = new TreeNode<int>(inorderVal[mid]);
    root->left = inorderToBST(s, mid-1, inorderVal);
    root->right = inorderToBST(mid+1, e, inorderVal);
    return root;
}
TreeNode<int>* balancedBst(TreeNode<int>* root) {
    vector<int> inorderVal;
    inorder(root, inorderVal);
    return inorderToBST(0, inorderVal.size()-1, inorderVal);
}

// Preorder traversal of a BST

// Method-1
BinaryTreeNode<int>* inorderToBST(int s, int e, vector<int> &inorder)
{
    if(s>e)
    {
        return NULL;
    }
    int mid=(s+e)/2;
    BinaryTreeNode<int>* newRoot= new BinaryTreeNode<int>(inorder[mid]);
    newRoot->left=inorderToBST(s, mid-1, inorder);
    newRoot->right=inorderToBST(mid+1, e, inorder);
    return newRoot;
}
BinaryTreeNode<int>* preorderToBST(vector<int> &preorder) {
    sort(preorder.begin(), preorder.end());
    return inorderToBST(0,preorder.size()-1, preorder);
}

// Method-2
BinaryTreeNode<int>* solve(vector<int> &preorder, int mini, int maxi, int &i){
    if(i >= preorder.size()){
        return NULL;
    }
    if(preorder[i] < mini || preorder[i] > maxi){
        return NULL;
    }

    BinaryTreeNode<int>* root = new BinaryTreeNode<int>(preorder[i++]);
    root->left = solve(preorder, mini, root->data, i);
    root->right = solve(preorder, root->data, maxi, i);

    return root;
}
BinaryTreeNode<int>* preorderToBST(vector<int> &preorder) {
    // Write your code here.
    int mini = INT_MIN;
    int maxi = INT_MAX;

    int i = 0;
    return solve(preorder, mini, maxi, i);
}

// Method-3
BinaryTreeNode<int>* solve(vector<int> &preorder, int maxi, int &i){
    if(i == preorder.size() || preorder[i] > maxi){
        return NULL;
    }
    BinaryTreeNode<int>* root = new BinaryTreeNode<int>(preorder[i++]);
    root->left = solve(preorder, root->data, i);
    root->right = solve(preorder, maxi, i);

    return root;
}
BinaryTreeNode<int>* preorderToBST(vector<int> &preorder) {
    int maxi = INT_MAX;
    int i = 0;
    return solve(preorder, maxi, i);
}

// Merge two BST

// Method-1
void inorder(TreeNode<int>*root,vector<TreeNode<int>*>&v) {
    if(!root) {
        return;
    }
    inorder(root->left,v);
    v.push_back(root);
    inorder(root->right,v);
}

// The following function merges the inorder traversal of two trees
void merge(vector<TreeNode<int>*>&v1,vector<TreeNode<int>*>&v2,vector<TreeNode<int>*>&ans) {
    int i=0,j=0,k=0;
    while(i<v1.size() && j<v2.size()) {
        if(v1[i]->data<v2[j]->data) {
            ans[k]=v1[i++];
        }
        else {
            ans[k]=v2[j++];
        }
        ans[k]->left=NULL;
        ans[k]->right=NULL;
        k++;
    }
    while(i<v1.size()) {
        ans[k]=v1[i++];
        ans[k]->left=NULL;
        ans[k]->right=NULL;
        k++;
    }
    while(j<v2.size()) {
        ans[k]=v2[j++];
        ans[k]->left=NULL;
        ans[k]->right=NULL;
        k++;
    }
}
// The following function builds the merged tree from the merged inorder traversal 
TreeNode<int>*helper(vector<TreeNode<int>*>&ans,int start,int end) {
    if(start>end) {
        return NULL;
    }
    int mid=start+(end-start)/2;
    TreeNode<int> *root= ans[mid];
    if(start==end) {
        return root;
    }
    root->left=helper(ans,start,mid-1);
    root->right=helper(ans,mid+1,end);
    return root;
}
TreeNode<int> *mergeBST(TreeNode<int> *root1, TreeNode<int> *root2) {
    vector<TreeNode<int>*>v1,v2;
    inorder(root1,v1);
    inorder(root2,v2);
    vector<TreeNode<int>*>ans(v1.size()+v2.size());
    merge(v1,v2,ans);
    return helper(ans,0,ans.size()-1);
}

// Method-2
// function to convert BST to Doubly Linked List
void convertTOList(TreeNode<int>*root, TreeNode<int>*&head){
    if(!root)
        return;
    convertTOList(root->right, head);
    root->right=head;
    if(head){
        head->left=root;
    }
    head=root;
    convertTOList(root->left, head);
}
// merge two sorted Linked lists
TreeNode<int>* mergedList(TreeNode<int>*head1,TreeNode<int>*head2){
    TreeNode<int>* head=NULL;
    TreeNode<int>* tail =NULL;
    while(head1 && head2){
        if(head1->data<head2->data){
            if(head==NULL){
                head=head1;
                tail=head1;
                head1=head1->right;
            }
            else{
                tail->right=head1;
                head1->left=tail;
                tail=head1;
                head1=head1->right;
            }
        }
        else{
            if(head==NULL){
                head=head2;
                tail=head2;
                head2=head2->right;
            }
            else{
                tail->right=head2;
                head2->left=tail;
                tail=head2;
                head2=head2->right;
            }
        }
    }
    while(head1){
        tail->right=head1;
        head1->left=tail;
        tail=head1;
        head1=head1->right;
    }
    while(head2){
        tail->right=head2;
        head2->left=tail;
        tail=head2;
        head2=head2->right;
    }
    return head;
}
int count_nodes(TreeNode<int>*head){
    TreeNode<int>*temp=head;
    int count=0;
    while(temp){
        count++;
        temp=temp->right;
    }
    return count;
}
TreeNode<int>*lltoBST(TreeNode<int>*&head,int n){
    if(n<=0  || head==NULL)
        return NULL;
    TreeNode<int>*left =lltoBST(head,  n/2);
    TreeNode<int>*root =head;
    root->left=left;
    head=head->right;
    root->right =lltoBST(head, n-n/2-1);
    return root;
}
TreeNode<int> *mergeBST(TreeNode<int> *root1, TreeNode<int> *root2){
    // Convert BST TO Doubly
    TreeNode<int>* head1=NULL;
    convertTOList(root1, head1);
    head1->left=NULL;
    TreeNode<int>* head2=NULL;
    convertTOList(root2, head2);
    head2->left=NULL;
    // Merge the two Linked Lists
    TreeNode<int>*mergedHead = mergedList(head1, head2);
    // merge the two BST's
    return lltoBST(mergedHead, count_nodes(mergedHead)); 
}

// Largest BST in binary tree

void func(TreeNode<int>* root,int &size,int &max_num, int &min_num){
    if(root == NULL){
        size = 0;
        max_num = -100000;
        min_num = 100000;
        return;
    }
    if(root->left == NULL&&root->right == NULL){
        size = 1;
        max_num = root->data;
        min_num = root->data;
        return;
    }
    int size1,max_num1,min_num1,size2,max_num2,min_num2;
    func(root->left,size1,max_num1,min_num1);
    func(root->right,size2,max_num2,min_num2);
    if(root->data>max_num1&&root->data<min_num2){
        size = 1 + size1 + size2;
        max_num = max(root->data,max_num2);
        min_num = min(root->data,min_num1);
        return;
    }
    else{
        size = max(size1,size2);
        max_num = 100000;
        min_num = -100000;
        return;
    }
}
int largestBST(TreeNode<int>* root) 
{
    if(root == NULL)return -1;
    int size = 0;
    int max_num,min_num;
    func(root,size,max_num,min_num);
    return size;
}

// Insertion Deletion in Heap

#include <bits/stdc++.h>
using namespace std;
class heap
{
public:
    int arr[100];
    int size = 0;
    heap()
    {
        arr[0] = -1;
        size = 0;
    }
    void insert(int val)
    {
        size = size + 1;
        int index = size;
        arr[index] = val;
        while (index > 1)
        {
            int parent = index / 2;
            if (arr[parent] < arr[index])
            {
                swap(arr[parent], arr[index]);
                index = parent;
            }
            else
            {
                return;
            }
        }
    }
    void deleteFromHeap()
    {
        if (size == 0)
        {
            cout << "Nothing to delete" << endl;
            return;
        }
        // put last node element at root node
        arr[1] = arr[size];
        // remove last node
        size--;
        // put root node at correct position
        int i = 1;
        while (i < size)
        {
            int leftIndex = 2 * i;
            int rightIndex = 2 * i + 1;
            if (leftIndex < size && arr[i] < arr[leftIndex] && arr[leftIndex] > arr[rightIndex])
            {
                swap(arr[i], arr[leftIndex]);
                i = leftIndex;
            }
            else if (rightIndex < size && arr[i] < arr[rightIndex] && arr[leftIndex] < arr[rightIndex])
            {
                swap(arr[i], arr[rightIndex]);
                i = rightIndex;
            }
            else
            {
                return;
            }
        }
    }
    void print()
    {
        for (int i = 1; i <= size; i++)
        {
            cout << arr[i] << " ";
        }
        cout << endl;
    }
};
int main()
{
    heap h;
    h.insert(50);
    h.insert(55);
    h.insert(53);
    h.insert(52);
    h.insert(54);
    h.print();
    h.deleteFromHeap();
    h.print();
    return 0;
}

// Heapify Algorithm

#include <bits/stdc++.h>
using namespace std;
void heapify(int arr[], int n, int i)
{
    int largest = i;
    int leftChild = 2 * i;
    int rightChild = 2 * i + 1;
    if (leftChild < n && arr[largest] < arr[leftChild])
    {
        largest = leftChild;
    }
    if (rightChild < n && arr[largest] < arr[rightChild])
    {
        largest = rightChild;
    }
    if (largest != i)
    {
        swap(arr[largest], arr[i]);
        heapify(arr, n, largest);
    }
}
int main()
{
    int arr[6] = {-1, 54, 53, 55, 52, 50};
    int n = 5;
    for (int i = n / 2; i > 0; i--)
    {
        heapify(arr, n, i);
    }
    cout << "Printing the array" << endl;
    for (int i = 1; i <= n; i++)
    {
        cout << arr[i] << " ";
    }
    return 0;
}

// Build Min Heap

#include <bits/stdc++.h>
void heapify(vector<int> &arr, int n, int i) {
  int smallest = i;
  int leftChild = 2 * i + 1;
  int rightChild = 2 * i + 2;
  if (leftChild < n && arr[smallest] > arr[leftChild]) {
    smallest = leftChild;
  }
  if (rightChild < n && arr[smallest] > arr[rightChild]) {
    smallest = rightChild;
  }
  if (smallest != i) {
    swap(arr[smallest], arr[i]);
    heapify(arr, n, smallest);
  }
}
vector<int> buildMinHeap(vector<int> &arr) {
  int n = arr.size();
  for (int i = (n / 2) - 1; i >= 0; i--) {
    heapify(arr, n, i);
  }
  return arr;
}

// Build Max Heap

#include <bits/stdc++.h>
void heapify(vector<int> &arr, int n, int i) {
  int largest = i;
  int leftChild = 2 * i + 1;
  int rightChild = 2 * i + 2;
  if (leftChild < n && arr[largest] < arr[leftChild]) {
    largest = leftChild;
  }
  if (rightChild < n && arr[largest] < arr[rightChild]) {
    largest = rightChild;
  }
  if (largest != i) {
    swap(arr[largest], arr[i]);
    heapify(arr, n, largest);
  }
}
vector<int> buildMinHeap(vector<int> &arr) {
  int n = arr.size();
  for (int i = (n / 2) - 1; i >= 0; i--) {
    heapify(arr, n, i);
  }
  return arr;
}

// Heap Sort

// Method-1
class Solution
{
    public:
    void heapify(int arr[], int n, int i)  
    {
        int largest = i;
        int leftChild = 2 * i + 1;
        int rightChild = 2 * i + 2;
        if (leftChild < n && arr[largest] < arr[leftChild]) {
            largest = leftChild;
        }
        if (rightChild < n && arr[largest] < arr[rightChild]) {
            largest = rightChild;
        }
        if (largest != i) {
            swap(arr[largest], arr[i]);
            heapify(arr, n, largest);
        }
    }
    void buildHeap(int arr[], int n)  
    { 
        for (int i = (n / 2) - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
    }
    void heapSort(int arr[], int n)
    {
        buildHeap(arr,n);
        for(int i=n-1;i>=0;i--){
        //swap
        swap(arr[0],arr[i]);
        heapify(arr,i,0);
    }
};

// Method-2
#include <bits/stdc++.h>
vector<int> heapSort(vector<int>& arr, int n) {
	priority_queue<int>maxheap;
    //creating a maxheap
    for(int i=0;i<n;i++){
        maxheap.push(arr[i]);
    }    
    int index=n-1;
    //placing the maximum element at the end of array
    while( !maxheap.empty()){
        int max=maxheap.top();
        maxheap.pop();
        arr[index--]=max;        
    }
    return arr;
}

// Priority queue

#include <bits/stdc++.h>
#include<queue>
using namespace std;
int main()
{
    cout<<"Using priority queue here "<<endl;
    // maxHeap
    priority_queue<int> pq;
    pq.push(4);
    pq.push(2);
    pq.push(5);
    pq.push(3);
    cout<<"Element at the top "<<pq.top()<<endl;
    pq.pop();
    cout<<"Element at the top "<<pq.top()<<endl;
    cout<<"Size is "<<pq.size()<<endl;
    if(pq.empty()){
        cout<<"pq is empty"<<endl;
    }
    else{
        cout<<"pq is not empty"<<endl;
    }
    // minHeap
    priority_queue<int,vector<int>,greater<int>> minheap;
    minheap.push(4);
    minheap.push(2);
    minheap.push(5);
    minheap.push(3);
    cout<<"Element at the top "<<minheap.top()<<endl;
    minheap.pop();
    cout<<"Element at the top "<<minheap.top()<<endl;
    cout<<"Size is "<<minheap.size()<<endl;
    if(minheap.empty()){
        cout<<"pq is empty"<<endl;
    }
    else{
        cout<<"pq is not empty"<<endl;
    }
    return 0;
}

// Kth smallest number

class Solution{
    public:
    // arr : given array
    // l : starting index of the array i.e 0
    // r : ending index of the array i.e size-1
    // k : find kth smallest element and return using this function
    int kthSmallest(int arr[], int l, int r, int k) {
        priority_queue<int> pq;
        for(int i=0;i<k;i++){
            pq.push(arr[i]);
        }
        for(int i=k;i<=r;i++){
            if(arr[i]<pq.top()){
                pq.pop();
                pq.push(arr[i]);
            }
        }
        int ans=pq.top();
        return ans;
    }
};

// Kth largest number

// Method-1
class Solution{
public:	
	vector<int> kLargest(int arr[], int n, int k) {
	    vector<int> ans;
	    sort(arr,arr+n);
	    for(int i=n-1;i>=n-k;--i){
	        ans.push_back(arr[i]);
	    }
	    return ans;
	}
};

// Method-2
class Solution{
public:	
	vector<int> kLargest(int arr[], int n, int k) {
	   vector<int>v; 
       priority_queue<int>mheap;
       for(int i=0;i<n;i++){
           mheap.push(arr[i]);
       }
       for(int i=0;i<k;i++){
           v.push_back(mheap.top());
           mheap.pop();
       }
     return v;
    }
};

// Merge two binary max heaps

// Method-1
class Solution{
    public:
    void heapify(vector<int>&arr ,int n ,int i){
      int largest=i;
      int left = 2*i+1;
      int right =2*i+2;
      if(left<n && arr[largest]<arr[left]){
            largest=left;
      }
      if(right<n && arr[largest]<arr[right]){
          largest=right;
      }
      if(largest!=i){
           swap(arr[largest],arr[i]);
           heapify(arr,n,largest);
      }
    }
    vector<int> mergeHeaps(vector<int> &a, vector<int> &b, int n, int m) {
         vector<int>c;
         for(auto i:a)
	 	c.push_back(i);
         for(auto i:b)
	 	c.push_back(i);
        int N=m+n;
        for(int i=N/2-1 ;i>=0;--i){
             heapify(c,N,i);
        }
        return c;
    }
};

// Method-2
class Solution{
    public:
    vector<int> mergeHeaps(vector<int> &a, vector<int> &b, int n, int m) {
        priority_queue<int>pq;
        for(auto i:a){
            pq.push(i);
        }
        for(auto i:b){
            pq.push(i);
        }
        vector<int>ans;
        while(!pq.empty()){
            ans.push_back(pq.top());
            pq.pop();
        }
        return ans;
    }
};

// Is Binary tree Heap

class Solution {
  public:
      int countNodes(struct Node* root){
          if(root == NULL)
          return 0;
          int ans = 1 + countNodes(root->left) + countNodes(root->right);
          return ans;
      }
      bool isCBT(struct Node* root, int i, int cnt){
          if(root == NULL){
              return true;
          }
          if(i >= cnt){
              return false;
          }
          else{
              bool left = isCBT(root->left, 2*i+1, cnt);
              bool right = isCBT(root->right, 2*i+2, cnt);
              return (left && right);
          }
      }
      bool isMaxOrder(struct Node* root){
          if(root->left == NULL && root->right == NULL){
              return true;
          }
          if(root->right == NULL){
              return root->data > root->left->data;
          }
          else{
              bool left = isMaxOrder(root->left);
              bool right = isMaxOrder(root->right);
              return (left && right && root->data > root->left->data && root->data > root->right->data);
          }
      }
    bool isHeap(struct Node* tree) {
        int index = 0;
        int countNode = countNodes(tree);
        if(isCBT(tree, index, countNode) && isMaxOrder(tree)){
            return true;
        }
        else{
            return false;
        }
    }
};

// Minimum Cost of ropes

class Solution
{
    public:
    long long minCost(long long arr[], long long n) {
        long long cost=0;
        priority_queue<long long,vector<long long>,greater<long long>>pq;
        for(int i=0;i<n;i++){
            pq.push(arr[i]);
        }
        while(pq.size()>1){
            long long a=pq.top();
            pq.pop();
            long long b=pq.top();
            pq.pop();
            long long sum=a+b;
            cost+=sum;
            pq.push(sum);
            
        }
        return cost;
    }
};

// Convert BST to min heap

#include <bits/stdc++.h>
using namespace std;
// Structure of a node of BST
struct Node {
	int data;
	Node *left, *right;
};
// Helper function that allocates a new node with the given data and NULL left and right pointers. 
struct Node* getNode(int data)
{
	struct Node* newNode = new Node;
	newNode->data = data;
	newNode->left = newNode->right = NULL;
	return newNode;
}
// function prototype for preorder traversal of the given tree
void preorderTraversal(Node*);
// function for the inorder traversal of the tree so as to store the node values in 'arr' in sorted order
void inorderTraversal(Node* root, vector<int>& arr)
{
	if (root == NULL)
		return;
	// first recur on left subtree
	inorderTraversal(root->left, arr);
	// then copy the data of the node
	arr.push_back(root->data);
	// now recur for right subtree
	inorderTraversal(root->right, arr);
}
// function to convert the given BST to MIN HEAP performs preorder traversal of the tree
void BSTToMinHeap(Node* root, vector<int> arr, int* i)
{
	if (root == NULL)
		return;
	// first copy data at index 'i' of 'arr' to the node
	root->data = arr[++*i];
	// then recur on left subtree
	BSTToMinHeap(root->left, arr, i);
	// now recur on right subtree
	BSTToMinHeap(root->right, arr, i);
}
// utility function to convert the given BST to MIN HEAP
void convertToMinHeapUtil(Node* root)
{
	// vector to store the data of all the nodes of the BST
	vector<int> arr;
	int i = -1;
	// inorder traversal to populate 'arr'
	inorderTraversal(root, arr);
	// BST to MIN HEAP conversion
	BSTToMinHeap(root, arr, &i);
}
// function for the preorder traversal of the tree
void preorderTraversal(Node* root)
{
	if (!root)
		return;
	// first print the root's data
	cout << root->data << " ";
	// then recur on left subtree
	preorderTraversal(root->left);
	// now recur on right subtree
	preorderTraversal(root->right);
}
int main()
{
	// BST formation
	struct Node* root = getNode(4);
	root->left = getNode(2);
	root->right = getNode(6);
	root->left->left = getNode(1);
	root->left->right = getNode(3);
	root->right->left = getNode(5);
	root->right->right = getNode(7);
	// Function call
	convertToMinHeapUtil(root);
	cout << "Preorder Traversal:" << endl;
	preorderTraversal(root);
	return 0;
}

// K-th Largest Sum Subarray

// Method-1
#include <bits/stdc++.h> 
int getKthLargest(vector<int> &arr, int k)
{
    vector<int>ans;
    for(int i=0;i<arr.size();i++){   // O(n^2)
        int sum=0;
        for(int j=i;j<arr.size();j++){
            sum+=arr[j];
            ans.push_back(sum);
        }
    }
    sort(ans.begin(),ans.end());   // O(LlogL) l is length of ans array  L = n^2
    int n= ans.size();
    return ans[n-k];
}   

// Method-2
#include<queue>

int getKthLargest(vector<int> &arr, int k)
{
	priority_queue<int,vector<int>,greater<int>>mini;
	int n=arr.size();
	for(int i=0;i<n;i++){
		int sum=0;
		for (int j = i; j < n; j++) {
			sum += arr[j];
			if(mini.size()<k){
				mini.push(sum);
			}
			else{
				if(sum>mini.top()){
					mini.pop();
					mini.push(sum);
				}
			}
		}
	}
	return mini.top();
}

// Merge K Sorted Arrays

// Method-1
#include <bits/stdc++.h> 
vector<int> mergeKSortedArrays(vector<vector<int>>&kArrays, int k)
{
    vector<int>ans;
    for(int i=0;i<kArrays.size();i++){
        for(int j=0;j<kArrays[i].size();j++){
            ans.push_back(kArrays[i][j]);
        }
    }
    sort(ans.begin(),ans.end());
    return ans;
}

// Method-2
#include <bits/stdc++.h> 
class node{
    public:
        int data;
        int i;
        int j;  
    node(int data,int row,int col){
        this->data=data;
        i=row;
        j=col;
    }    
};
class compare{
    public:
        bool operator()(node*a,node*b){
            return a->data > b->data;
        }
};
vector<int> mergeKSortedArrays(vector<vector<int>>&kArrays, int k)
{
    priority_queue<node*, vector<node*>,compare > pq;
    // insert all first k elements of array
    for(int i=0;i<k;i++){
        node*temp=new node(kArrays[i][0],i,0);
        pq.push(temp);
    } 
    vector<int> ans;
    while(pq.size()>0){
        node* tp= pq.top();
        pq.pop();
        ans.push_back( tp->data );
        int i= tp->i;
        int j= tp->j;
        if (j + 1 < kArrays[i].size()) {
          node *next = new node(kArrays[i][j + 1], i, j + 1);
          pq.push(next);
        }
    }
    return ans;
}

// Merge k sorted lists

// Method-1
#include<bits/stdc++.h>
void solve(Node<int>*&tail,vector<int>&ans){
    int i=1;
    int n= ans.size();
    while(i!=n){
        Node<int>* temp= new Node<int>(ans[i]);
        tail->next=temp;
        tail=tail->next;
        i++;
    }
}
Node<int>* mergeKLists(vector<Node<int>*> &listArray)
{
    vector<int> ans;
    for(int i=0;i<listArray.size();i++){
        Node<int>* temp= listArray[i];
        while(temp!=NULL){
            ans.push_back( temp->data );
            temp=temp->next;
        }
    }
    sort(ans.begin(),ans.end());
    int n= ans.size();
    if(n==0) return NULL;
    Node<int>* head=new Node<int>(ans[0]);
    Node<int>* tail=head;
    solve(tail,ans);
    return head;
}

// Method-2
#include<queue>
#include<algorithm>
class compare{
    public:
    bool operator()(Node<int>*a,Node<int>*b){
        return a->data > b->data;
    }
};
Node<int>* mergeKLists(vector<Node<int>*> &listArray)
{
    priority_queue<Node<int>*,vector<Node<int>*>,compare>minheap;
    int k=listArray.size();
    if(k==0)
        return NULL;
    Node<int>*head=NULL;
    Node<int>*tail=NULL;
    //creating k heap with the head of k given Linked List
    for(int i=0;i<k;i++){        
        Node<int>*temp=listArray[i];
        if(temp!=NULL)
            minheap.push(temp);
        
    }
    while(minheap.size()>0){
        Node<int>*top=minheap.top();
        minheap.pop();
        if(top->next!=NULL){
            minheap.push(top->next);
        }
        //checking if its the 1st most element 
        if(head==NULL){
            head=top;
            tail=top;
        }
        //for rest of elements
        else{
            tail->next=top;
            tail=top;
        }
    }
    return head;
}

// Median in a stream

// Method-1
#include <bits/stdc++.h>
vector<int> findMedian(vector<int> &arr, int n){
    vector<int> nums, ans;
    for(int x=0; x<n; x++){
        nums.push_back(arr[x]);
        sort(nums.begin(), nums.end());
        int N = nums.size();
        if(N & 1){
            N--;
            ans.push_back(nums[N/2]);
        }else{
            N--;
            ans.push_back( (nums[N/2]+nums[(N/2)+1])/2 );
        }
    } 
    return ans;
}

// Method-2
#include<bits/stdc++.h>
int signum(int a, int b){
	if(a == b)
		return 0;	
	else if(a > b)
		return 1;
	else
		return -1;
}
void calMedian(int element, priority_queue<int> &maxi, 
	priority_queue<int, vector<int>, greater<int> > &mini, int &median){
		switch(signum(maxi.size(), mini.size())){
			case 0:
					if(element > median){
						mini.push(element);
						median = mini.top();
					}
					else{
						maxi.push(element);
						median = maxi.top();
					}
					break;
			case 1:
					if(element > median){
						mini.push(element);
						median = (mini.top() + maxi.top())/2;
					}
					else{
						mini.push(maxi.top());
						maxi.pop();
						maxi.push(element);
						median = (mini.top() + maxi.top())/2;
					}
					break;
			case -1:
					if(element > median){
						maxi.push(mini.top());
						mini.pop();
						mini.push(element);
						median = (mini.top() + maxi.top())/2;
					}
					else{
						maxi.push(element);
						median = (mini.top() + maxi.top())/2;
					}
					break;
		}
}
vector<int> findMedian(vector<int> &arr, int n){
	vector<int> ans;
	priority_queue<int, vector<int>, greater<int> > mini;
	priority_queue<int> maxi;
	int median = 0;
	for(int i = 0; i < n; i++){
		calMedian(arr[i], maxi, mini, median);
		ans.push_back(median);
	}
	return ans;
}

// Smallest Range From K Sorted List

#include<bits/stdc++.h>
class node{
    public:
        int data;
        int row;
        int col;

    node(int d, int r, int c){
        data = d;
        row = r;
        col = c;
    }
};
class compare{
    public:
        bool operator()(node* a, node* b){
            return a->data > b->data;
        }
};
int kSorted(vector<vector<int>> &a, int k, int n) {  
    int mini = INT_MAX, maxi = INT_MIN;
    priority_queue<node*, vector<node*>, compare> pq;
    for (int i=0; i<k; i++){
        int elem = a[i][0];
        mini = min(mini, elem);
        maxi = max(maxi, elem);
        pq.push(new node(elem, i, 0));
    }
    int start = mini, end = maxi;
    while (!pq.empty()){
        node* temp = pq.top();
        pq.pop();
        mini = temp->data;
        if (maxi-mini < end-start){
            start = mini;
            end = maxi;
        }
        if (temp->col+1 < n){
            maxi = max(maxi, a[temp->row][temp->col+1]);
            pq.push(new node(a[temp->row][temp->col+1], temp->row, temp->col+1));
        }
        else{
            break;
        }
    }
    return (end - start + 1);
}

// Rearrange string

// Method-1
#include <bits/stdc++.h> 
void reArrange(string &s, int size){
    for(int i = 0; i < size - 1; i++){
        if(s[i] == s[i+1]){
            int j = i + 1;
            while(s[i] == s[j]){
                j++;
            }
            swap(s[i + 1], s[j]);
        }
    }
}
string reArrangeString(string &s)
{
    int size = s.size();
	reArrange(s, size);
    return s;
}

// Method-2
#include <bits/stdc++.h> 
string reArrangeString(string &s)
{
    map<char,int> m;
    int n=s.size();
    for(int i=0;i<n;i++)
    	m[s[i]]++;
    vector<pair<int,char>> v;
    for(auto i:m)
    	v.push_back(make_pair(i.second,i.first));
    sort(v.begin(),v.end());
    reverse(v.begin(),v.end());
    int idx=0;
    for(auto i:v){
        int val=i.first;
        char key=i.second;
        if(val>n/2+n%2)return "not possible";
        while(val--){
            if(idx>=n)idx=1;
            s[idx]=key;
            idx+=2;
        }
    }
    return s;        
}

// Method-3
#include<bits/stdc++.h>
string reArrangeString(string &s)
{
    priority_queue<char> maxHeap;
	string ans="";
    int count=0;
    for(int i=0;i<s.length();i++) {
		char it = ans[ans.length()-1];
		if(it==s.at(i)) {
			maxHeap.push(s.at(i));
		}
		else {
			ans.push_back(s[i]);
			while(!maxHeap.empty()) {
				char topChar = maxHeap.top();
				it = ans[ans.length()-1];
				if(topChar!=it) {
					ans.push_back(topChar);
					maxHeap.pop();
				}else{
					break;
				}
			}
		}
    }
    while(!maxHeap.empty()) {
        char topChar = maxHeap.top();
		char it = ans[ans.length()-1];
        if(topChar!=it) {
            ans.push_back(topChar);
            maxHeap.pop();
		}
		else{
            break;
        }
	}
    if(maxHeap.empty()) {
        return ans;
    }
	else {
        return "not possible";
    }   
}

// Hashmap

#include<iostream>
#include<map>
#include<unordered_map>
using namespace std;
int main(){
    // creation
    // map<string,int> m; -> just to check map
    unordered_map<string,int> m;
    // insertion
    // 1
    pair<string,int> p = make_pair("krsna",3);
    m.insert(p);
    // 2
    pair<string,int> q("anjum",2);
    m.insert(q);
    // 3
    m["yunus"] = 3;
    // what will happen?
    m["yunus"] = 2;
    // Search
    cout<<m["yunus"]<<endl;
    cout<<m.at("krsna")<<endl;
    // cout<<m.at("unknownKey")<<endl; -> error
    cout<<m["unknownKey"]<<endl; // mapping <unknownKey,0> here
    cout<<m.at("unknownKey")<<endl;
    // size
    cout<<m.size()<<endl;
    // to check presence
    cout<<m.count("bro")<<endl;
    cout<<m.count("anjum")<<endl;
    // erase
    m.erase("yunus");
    cout<<m.size()<<endl;
    // Accesing map through iteration
    // 1
    for(auto i:m){
        cout<<i.first<<" "<<i.second<<endl;
    }
    // 2 -> Not in same order random order
    unordered_map<string,int> :: iterator it = m.begin();
    while(it!=m.end()){
        cout<<it->first<<" "<<it->second<<endl;;
        it++;
    }
    // 3 -> In same order
    // map<string,int> :: iterator it = m.begin();
    // while(it!=m.end()){
    //     cout<<it->first<<" "<<it->second<<endl;;
    //     it++;
    // }
    return 0;
}

// Maximum Frequency Number

int maximumFrequency(vector<int> &arr, int n)
{
    int maxFreq=0;
    int maxAns=0;
    unordered_map<int ,int>mp;
    for(int i=0;i<arr.size();i++){
        mp[arr[i]]++;
        maxFreq=max(maxFreq,mp[arr[i]]);
    }
    for(int i=0;i<arr.size();i++){
        if(maxFreq==mp[arr[i]]){
            maxAns=arr[i];
            break;
        }
    }
    return maxAns;
}
