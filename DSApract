// Reverse Array

class Solution {
public:
    int reverse(int x) {
        int ans=0;
        while(x!=0){
        int digit=x%10;
        if(ans>INT_MAX/10 || ans<INT_MIN/10){
            return 0;
        }
        ans=(ans*10)+digit;
        x=x/10;
        }
        return ans;
    }
};

// Complement of base 10 integer

class Solution {
public:
    int bitwiseComplement(int n) {
        int m=n;
        int mask=0;
        if(n==0){
            return 1;
        }
        while(m!=0){
            mask=(mask<<1)|1;
            m=m>>1;
        }
        int ans=(~n)&mask;
        return ans;
    }
};

// Power of Two

class Solution {
public:
    bool isPowerOfTwo(int n) {
        int ans=1;
        for(int i=0;i<=30;i++){
            if(ans==n){
                return true;
            }
            if(ans<INT_MAX/2){
            ans=ans*2;
            }
        }
        return false;
    }
};

// Unique number

int findUnique(int *arr, int size)
{
    int ans=0;
    for(int i=0;i<size;i++){
        ans=ans^arr[i];
    }
    return ans;
}

// Duplicate number

int findDuplicate(vector<int> &arr) 
{
    int ans=0;
    for(int i=0;i<arr.size();i++){
        ans=ans^arr[i];
    }
    for(int i=0;i<arr.size();i++){
        ans=ans^i;
    }
    return ans;
}

// Array Intersection

#include <bits/stdc++.h> 
vector<int> findArrayIntersection(vector<int> &arr1, int n, vector<int> &arr2, int m)
{
	int i=0,j=0;
	vector<int> ans;
	while(i<n && j<m){
		if(arr1[i]==arr2[j]){
			ans.push_back(arr1[i]);
			i++;
			j++;
		}
		else if(arr1[i]<arr2[j]){
			i++;
		}
		else{
			j++;
		}
	}
	return ans;
}

// Pair Sum

#include <bits/stdc++.h> 
#include <bits/stdc++.h> 
vector<vector<int>> pairSum(vector<int> &arr, int s){
   int n=arr.size();
   vector<vector<int>> ans;
   for(int i=0;i<n;i++){
      for(int j=i+1;j<n;j++){
         if(arr[i]+arr[j]==s){
            vector<int> temp;
            temp.push_back(min(arr[i],arr[j]));
            temp.push_back(max(arr[i],arr[j]));
            ans.push_back(temp);
         }
      }
   }
   sort(ans.begin(),ans.end());
   return ans;
}

// Triplet Sum

#include <bits/stdc++.h>
vector<vector<int>> findTriplets(vector<int> arr, int n, int K) {
  sort(arr.begin(), arr.end());
  set<vector<int>> s;
  vector<vector<int>> ans;
  for (int i = 0; i < n; ++i)
  {
    int j = i + 1;
    int k = n - 1;
    while (j < k)
    {
      int sum = arr[i] + arr[j] + arr[k];
      if (sum == K)
      {
        s.insert({arr[i], arr[j], arr[k]});
        j++;
        k--;
      }
      else if (sum < K)
      {
        j++;
      }
      else
      {
        k--;
      }
    }
  }
  for (auto x : s)
  {
    ans.push_back(x);
  }
  return ans;
}

// Sort 0,1 and 2

#include <bits/stdc++.h>

void swap(int &x,int &y){
   int temp=x;
   x=y;
   y=temp;
}

void sort012(int *arr, int n)
{
   int a0=0,b1=0,c2=n-1;
   while(b1<=c2){
      if(arr[b1]==0){
         swap(arr[a0],arr[b1]);
         a0++;
         b1++;
      }
      else if(arr[b1]==1){
         b1++;
      }
      else{
         swap(arr[b1],arr[c2]);
         c2--;
      }
   }
}

// Unique Number Of Occurences

class Solution {
public:
    bool uniqueOccurrences(vector<int>& arr) {
        int i = 0;
        sort(arr.begin(),arr.end());
        vector<int> ans;
        while (i < arr.size()){
            int count = 1;
            for (int j = i+1; j< arr.size(); j++){
                if (arr[i] == arr[j])
                    count++;
            }
            ans.push_back(count);
            i = i + count;
        }
        sort(ans.begin(),ans.end());
        for (int i = 0; i < ans.size() - 1; i++){
            if (ans[i] == ans [i+1])
                return false;
        }
        return true;
    }
};

// All Duplicates in an Array

class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> ans; 
        sort(nums.begin(),nums.end());
            for(int i=0 ; i<nums.size()-1 ; ){
                if(nums[i]==nums[i+1]){
                    ans.push_back(nums[i]);
                    i=i+2;
                }
                else{
                  i++;  
                } 
            }
        return ans;
    }
};

// Find Pivot Index

class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int sum1=0,sum2=0;
        for(int i=0;i<nums.size();i++){
            sum1+=nums[i];
        }
        for(int i=0;i<nums.size();i++){
            sum1-=nums[i];
            if(sum1==sum2){
                return i;
            }
            sum2+=nums[i];
        }
        return -1;
    }
};

// First and Last Occurence

#include <bits/stdc++.h> 

int FirstOccurence(vector<int>& arr, int n, int k){
    int i=0,j=n-1,mid=i+(j-i)/2;
    int ans=-1;
    while(i<=j){
        if(arr[mid]<k){
            i=mid+1;
        }
        else if(arr[mid]==k){
            ans=mid;
            j=mid-1;
        }
        else{
            j=mid-1;
        }
        mid=i+(j-i)/2;
    }
    return ans;
}

int LastOccurence(vector<int>& arr, int n, int k){
    int i=0,j=n-1,mid=i+(j-i)/2;
    int ans=-1;
    while(i<=j){
        if(arr[mid]<k){
            i=mid+1;
        }
        else if(arr[mid]==k){
            ans=mid;
            i=mid+1;
        }
        else{
            j=mid-1;
        }
        mid=i+(j-i)/2;
    }
    return ans;
}

pair<int, int> firstAndLastPosition(vector<int>& arr, int n, int k)
{
    pair<int,int> p;
    p.first=FirstOccurence(arr,n,k);
    p.second=LastOccurence(arr,n,k);
    return p;
}

// Peak Index in a Mountain Array

class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int n=arr.size();
        int i=0,j=n-1,mid=i+(j-i)/2;
        while(i<j){
            if(arr[mid]<arr[mid+1]){
                i=mid+1;
            }
            else{
                j=mid;
            }
            mid=i+(j-i)/2;
        }
        return i;
    }
};

// Search in Rotated Sorted Array

#include <bits/stdc++.h> 
int pivotIndex(vector<int> arr,int n){
   int start = 0;
   int end = n-1;
   int mid = start + (end-start)/2;
   
   while(start<end){
       if(arr[mid]>=arr[0]){
           start = mid+1;
       }
       else{
           end = mid;
       }
       mid = start + (end-start)/2;
   }
   return start;
}
int binarySearch(vector<int> arr,int start,int end,int key){
   int mid = start + (end-start)/2;
   
   while(start<=end){
       if(arr[mid]==key){
           return mid;
       }
       else if(arr[mid]>key){
           end = mid -1;
       }
       else{
           start = mid+1;
       }
       mid = start+(end-start)/2;
   }
   return -1;
}
int findPosition(vector<int>& arr, int n, int k)
{
   int pivot = pivotIndex(arr,n);
   if(k>=arr[pivot] && k<=arr[n-1]){
       return binarySearch(arr,pivot,n-1,k);
   }
   else{
       return binarySearch(arr,0,pivot-1,k);
   }
}

// Square root of an integer

#include <bits/stdc++.h> 

int sqrtN(long long int N)
{
   if(N < 2) return N;
   long long int s = 0, e = N;
   long long int mid = s + (e - s) / 2;
   long long ans = -1;
   while (s <= e)
   {
       if (mid  == (N/mid)) // same as mid*mid == N, to avoid range overlow
           return mid;
       else if (mid > (N/mid))
           e = mid - 1;
       else
       {
           ans = mid;
           s = mid + 1;
       }
       mid = s + (e - s) / 2;
   }
   return ans;
}

// Allocate Books

#include <bits/stdc++.h>  

bool isPossible(int n, int m, vector<int> time,long long int mid){

   long long int studentCount=1 , chapterSum=0;     
   for(int i=0;i<m;i++){   
      if(chapterSum + time[i] <= mid){  
         chapterSum+= time[i];
       } 
      else  {
           studentCount++;  
           if(studentCount > n || time[i] > mid){
                return false;
           }        
           chapterSum = time[i];
       } 
      if(studentCount>n){  
         return false;  
     }
   }
   return true; 
}
 long long ayushGivesNinjatest(int n, int m, vector<int> time)  {
  
  long long int start=0, sum=0;   
  for(int i=0;i<m;i++){
       sum=sum+time[i];    
  }
  long long int end=sum, ans=-1, mid=start+(end-start)/2;
      while(start<=end){ 
      if(isPossible(n,m,time,mid)){
           ans=mid;
           end=mid-1;
       }
       else {
           start=mid+1;   
        }
       mid=start+(end-start)/2;
   }   
   return ans; 
}

// Aggressive Cows

bool isPossible(vector<int> &stalls, int k, int mid, int n) {
    
    int cowCount = 1;
    int lastPos = stalls[0];
    
    for(int i=0; i<n; i++ ){
        
        if(stalls[i]-lastPos >= mid){
            cowCount++;
            if(cowCount==k)
            {
                return true;
            }
            lastPos = stalls[i];
        }
    }
    return false;
}

int aggressiveCows(vector<int> &stalls, int k)
{
    sort(stalls.begin(), stalls.end());
   	int s = 0;
    int n = stalls.size();
    int e=stalls[n-1];
    int ans = -1;
    int mid = s + (e-s)/2;
    
    while(s<=e) {
        if(isPossible(stalls, k, mid, n)) {
            ans = mid;
            s = mid + 1;
        }
        else
        {
            e = mid - 1;
        }
        mid = s + (e-s)/2;
    }
    return ans;
}

// Painter's Partiton Problem

bool isPossible(vector<int> &boards, int n, int k, int mid) {
  int PainterCount = 1;
  int blockCount = 0;
  for (int i = 0; i < n; ++i) {
    if (blockCount + boards[i] <= mid) {
      blockCount += boards[i];
    } 
    else {
      PainterCount++;
      if (PainterCount > k || boards[i] > mid) {
        return false;
      }
      blockCount = boards[i];
    }
  }
  return true;
}
int findLargestMinDistance(vector<int> &boards, int k) {
  int n = boards.size();
  int s = 0;
  int sum = 0;
  for (int i = 0; i < n; ++i) {
    sum += boards[i];
  }
  int e = sum;
  int ans = -1;
  int mid = s + (e - s) / 2;
  while (s <= e) {
    if (isPossible(boards, n, k, mid)) {
      ans = mid;
      // Left wale bhaag jaenge
      e = mid - 1;
    } 
    else {
      s = mid + 1;
    }
    mid = s + (e - s) / 2;
  }
  return ans;
}

// Reverse an array

#include <bits/stdc++.h> 
void reverseArray(vector<int> &arr , int m)
{
	int n=arr.size();
	int start=m+1,end=n-1;
	while(start<end){
		int temp=arr[start];
		arr[start]=arr[end];
		arr[end]=temp;
		start++;
		end--;
	}
}

// Merge two sorted arrays 

class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        while(nums1.size()>m){
            nums1.pop_back();
        }
        for(int j=0; j<n; j++){
            nums1.push_back(nums2[j]);
        }
        sort(nums1.begin(), nums1.end());
    }
};

// Move zeroes to end

class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int i=0;
        for(int j=0;j<nums.size();j++){
            if(nums[j]!=0){
                swap(nums[j],nums[i]);
                i++;
            }
        }
    }
};

// Rotate the array by k

class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k %= n;
        reverse(nums.begin(), nums.end());
        reverse(nums.begin(), nums.begin()+k);
        reverse(nums.begin()+k, nums.end());
        return;
    }
};

// Check if Array is sorted and rotated

class Solution {
public:
    bool check(vector<int>& nums) {
        int count = 0;
        for(int i=0;i<nums.size()-1;i++)
        {
            if(nums[i]>nums[i+1] )
            count++;
        }
        if(nums[nums.size()-1] > nums[0]){
            count++;
        }
        if(count <= 1){
            return true;
        }
        else{
            return false;
        }
    }
};

// Sum of two arrays

#include <bits/stdc++.h> 

vector<int> reverse(vector<int> v){
	int s=0,e=v.size()-1;
	while(s<e){
		swap(v[s++],v[e--]);
	}
	return v;
}
vector<int> findArraySum(vector<int>&a, int n, vector<int>&b, int m) {
		int i=n-1,j=m-1;
		vector<int> ans;
		int carry=0;
		while(i>=0 && j>=0){
			int value1=a[i];
			int value2=b[j];
			int sum=value1+value2+carry;
			carry=sum/10;
			sum=sum%10;
			ans.push_back(sum);
			i--;
			j--;
		}
		while(i>=0){
			int sum=a[i]+carry;
			carry=sum/10;
			sum=sum%10;
			ans.push_back(sum);
			i--;
		}
		while(j>=0){
			int sum=b[j]+carry;
			carry=sum/10;
			int value=sum%10;
			ans.push_back(value);
			j--;
		}
		while(carry!=0){
			int sum=carry;
			carry=sum/10;
			sum=sum%10;
			ans.push_back(sum);
		}
		return reverse(ans);		
}

// Check if the string is a palindrome

#include <bits/stdc++.h> 

string toLowerCase(string s){
    int i=0,j=s.size()-1;
    string str="";

    while(i<=j){
        if((s[i]>='a' && s[i]<='z') || (s[i]>='0' && s[i]<='9')){
            str+=s[i++];
        }
        else if((s[i]>='A' && s[i]<='Z')){
            str+=s[i++]-'A'+'a';
        }
        else{
            i++;
        }
    }
    return str;
}

bool checkPalindrome(string s)
{
    string str=toLowerCase(s);
    int n=str.size();
    int i=0,j=n-1;
    bool ans=true;
    while(i<=j){
        if(str[i]==str[j]){
            i++;
            j--;
        }
        else{
            ans=false;
            break;
        }
    }
    return ans;
}

// Valid palindrome

class Solution {
public:
    bool isPalindrome(string s) {
        string str="";
        for(int i=0;i<s.size();i++){
            if(isalnum(s[i])) 
                str+=tolower(s[i]);
        }
        string y=str;
        reverse(str.begin(),str.end());
        int i=0,j=0;
        while(i<str.size() && j<y.size()){
            if(str[i]!=y[j]){
                return false;
            }
            else{
                i++;
                j++;
            }
        }
        return true;
    }
};

// Reverse words in a string II

class Solution {
public:
    void reverseWords(vector<char>& s) {
        int i = 0, N = s.size();
        while (i < N) {
            int start = i;
            while (i < N && s[i] != ' ') ++i;
            reverse(begin(s) + start, begin(s) + i);
            ++i;
        }
        reverse(begin(s), end(s));
    }
};

// Maximum occuring character

//{ Driver Code Starts
#include<bits/stdc++.h>
using namespace std;


// } Driver Code Ends


class Solution
{
    public:
    char getMaxOccuringChar(string str)
    {
        int arr[26] = {0};
        for (int i = 0; i < str.length(); i++)
        {
            char ch = str[i];
            int number = 0;
            number = ch - 'a';
            arr[number]++;
        }
        int maxi = -1, ans = 0;
        for (int i = 0; i < 26; i++)
        {
            if (maxi < arr[i])
            {
                ans = i;
                maxi = arr[i];
            }
        }
        return 'a' + ans;
    }

};

//{ Driver Code Starts.

int main()
{
   
    int t;
    cin >> t;
    while(t--)
    {
        string str;
        cin >> str;
    	Solution obj;
        cout<< obj.getMaxOccuringChar(str)<<endl;
    }
}
// } Driver Code Ends

// Remove all occurrences of substring

#include <bits/stdc++.h> 
string replaceSpaces(string &str){
	string ch="@40";
	int i=0;
	while(i<=str.length()){
		if(str[i]==' '){
			str.replace(i,1,ch);
		}
		i++;
	}
	return str;
}

// Remove all adjacent duplicates

class Solution {
public:
    string removeDuplicates(string s) {
        string ans = "";
        for(int i = 0; i < s.length(); i++){
            if(ans == ""){
                ans.push_back(s[i]);
            }
            else if(ans.back()==s[i]){
                ans.pop_back();
            }
            else{
                ans.push_back(s[i]);
            }
        }
        return ans;
    }
};


// String Compression

class Solution {
public:
    int compress(vector<char>& chars) {
        int n=chars.size();
        int i=0,j=0;
        while(j<n){
            int c=0;
            char current_char=chars[j];
            while(j<n && chars[j]==current_char){
                c++;
                j++;
            }
            chars[i++]=current_char;
            if(c>1){
                string count=to_string(c);
                for(auto p:count){
                    chars[i++]=p;
                }
            }

        }
         return i;
    }
};

// Permutation in Strings

class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        int s1_len=s1.size();
        int s2_len=s2.size();
        if(s1_len>s2_len)
        {
            return false;
        }
        sort(s1.begin(),s1.end());
        for(int i=0;i<=(s2_len-s1_len);i++)
        {
            string p=s2.substr(i,s1_len);
            sort(p.begin(),p.end());
            if(p==s1)
            {
                return true;
            }
        }
        return false;
    }
};

// Remove adjacent Duplicates 

class Solution {
public:
    string removeDuplicates(string s) {
        string ans = "";
        for(int i = 0; i < s.length(); i++){
            if(ans == ""){
                ans.push_back(s[i]);
            }
            else if(ans.back()==s[i]){
                ans.pop_back();
            }
            else{
                ans.push_back(s[i]);
            }
        }
        return ans;
    }
};

// Linear Search

#include<iostream>
using namespace std;
int main(){
    int n;
    cin>>n;
    int arr[n];
    for (int i = 0; i < n; i++)
    {
        cin>>arr[i];
    }
    int search;
    cin>>search;
    for (int i = 0; i < n; i++)
    {
        if(arr[i]==search){
            cout<<search<<" element is found"<<" at "<< i <<" index"<<endl;
        }
    }
    return 0;
}

// Row-wise sum

#include<iostream>
using namespace std;
int main(){
    int n,m;
    cin>>n>>m;
    int arr[n][m];
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin>>arr[i][j];
        }
    }
    for (int i = 0; i < n; i++)
    {
        int sum=0;
        for (int j = 0; j < m; j++)
        {
            sum+=arr[i][j];
        } 
        cout<<sum<<" ";
    }
    cout<<endl;
    return 0;
}

// Column-wise sum

#include<iostream>
using namespace std;
int main(){
    int n,m;
    cin>>n>>m;
    int arr[n][m];
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin>>arr[i][j];
        }
    }
    for (int j = 0; j < m; j++)
    {
        int sum=0;
        for (int i = 0; i < n; i++)
        {
            sum+=arr[i][j];
        } 
        cout<<sum<<" ";
    }
    cout<<endl;
    return 0;
}

// Largest Row Sum

#include<iostream>
#include<climits>
using namespace std;
int main(){
    int n,m;
    cin>>n>>m;
    int arr[n][m];
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin>>arr[i][j];
        }
    }
    int max=INT_MIN;
    int RowIndex=-1;
    for (int i = 0; i < n; i++)
    {
        int sum=0;
        for (int j = 0; j < m; j++)
        {
            sum+=arr[i][j];
        }
        if(sum>max){
            max=sum;
            RowIndex=i;
        }
    }
    cout<<max<<endl;
    cout<<RowIndex<<endl;
    return 0;
}

// Wave Print

#include <bits/stdc++.h> 
vector<int> wavePrint(vector<vector<int>> arr, int nRows, int mCols)
{
    vector<int> ans;
    for(int j=0;j<mCols;j++){
        if(j&1){
            for(int i=nRows-1;i>=0;i--)
                ans.push_back(arr[i][j]);
        }
        else{
            for(int i=0;i<nRows;i++)
                ans.push_back(arr[i][j]);
        }
    }
    return ans;
}

// Spiral Matrix

class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> ans;
        int row=matrix.size();
        int col=matrix[0].size();
        int count=0;
        int total=row*col;
        // Indexes
        int startingRow=0;
        int startingCol=0;
        int endingRow=row-1;
        int endingCol=col-1;
        while(count<total){
            for (int index = startingCol; count<total && index <= endingCol ; index++)
            {
                ans.push_back(matrix[startingRow][index]);
                count++;
            }
            startingRow++;
            for (int index = startingRow; count<total && index <= endingRow ; index++)
            {
                ans.push_back(matrix[index][endingCol]);
                count++;
            }
            endingCol--;
            for (int index = endingCol; count<total && index >= startingCol ; index--)
            {
                ans.push_back(matrix[endingRow][index]);
                count++;
            }
            endingRow--;
            for (int index = endingRow; count<total && index >= startingRow ; index--)
            {
                ans.push_back(matrix[index][startingCol]);
                count++;
            }
            startingCol++;
        }
        return ans;
    }
};

// Rotate Image

class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n; i++) {
            for (int j = i+1; j < n; j++) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        for(int k=0;k<n;k++){
            reverse(matrix[k].begin(), matrix[k].end());
        }
    }
};

// Search in a 2D Matrix

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row=matrix.size();
        int col=matrix[0].size();
        int start=0,end=(row*col)-1,mid=start+(end-start)/2;
        while(start<=end){
            int element=matrix[mid/col][mid%col];
            if(element<target){
                start=mid+1;
            }
            else if(element==target){
                return 1;
            }
            else{
                end=mid-1;
            }
            mid=start+(end-start)/2;
        }
        return 0;
    }
};

// Search in a 2D Matrix II

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row=matrix.size();
        int col=matrix[0].size();
        
        int RowIndex=0;
        int ColIndex=col-1;
        
        while(RowIndex<row && ColIndex>=0){
            int element=matrix[RowIndex][ColIndex];
            if(element<target){
                RowIndex++;
            }
            else if(element==target){
                return 1;
            }
            else{
                ColIndex--;
            }
        }
        return 0;
    }
};

// Count prime(Sieve of Eratosthenes)

class Solution {
public:
    int countPrimes(int n) {
        int count=0;
        vector<bool> prime(n+1,true);
        
        prime[0]=prime[1]=false;
        
        for(int i=2;i<n;i++){
            if(prime[i]){
               count++; 
            }
            for(int j=2*i;j<n;j=j+i){
                prime[j]=0;
            }
        }
        return count;
    }
};

// Segmented Sieve

class Solution{
public:
    bool isPrime(long long int n)
    {
        if(n<=1){
           return false;
        }
        for(int i=2 ; i*i<=n ; i++){
            if(n%i == 0){
               return false ;
            }
        }
        return true ;
    }
    long long primeProduct(long long L, long long R){
        long long int ans=1;
        int count=0;
        long long int num=pow(10,9) + 7; 
        for(int i=L; i<=R; i++){
            if(isPrime(i)){
                count++;
                ans=(ans*i)%num;
            }
        }
       if(count==0){
           return 1;
       }
       return ans;
    }
};

// GCD

#include<iostream>
using namespace std;
int gcd(int a,int b){
    if(a==0)
    	return b;
    else if(b==0)
    	return a;
    while(a!=b){
    	if(a>b)
	    a=a-b;
	else   
	    b=b-a;
        }
    return a;
}
int main(){
    int a,b;
    cin>>a>>b;
    cout<<"Gcd of "<<a<<" and "<<b<<" is "<<gcd(a,b);
    return 0;
}

// LCM

#include<iostream>
using namespace std;
int main(){
    int a,b,gcd,temp,lcm;
    cin>>a>>b;
    gcd=a;
    temp=b;
    while(gcd!=lcm){
        if(gcd>temp)
            gcd=gcd-temp;
        else
            temp=temp-gcd;
    }
    lcm=(a*b)/gcd;
    return 0;
}

// Modular Exponentiation

#include <bits/stdc++.h>  
int modularExponentiation(int x, int n, int m) {
	int result=1;
	while(n>0){
		if(n&1){
			result=(1LL*(result)*(x))%m;
		}
		x=(1LL*(x)*(x))%m;
		n=n>>1;
	}
	return result;
}

// Pigeon Hole Principle - If there are n+1 number of pigeons and n number of pigeonholes there is must be atleast one pigeonhole which contain atleast two pigeons.

// Catalan Number - Catalan numbers are defined as a mathematical sequence that consists of positive integers, which can be used to find the number of possibilities of various combinations. Cn = 1/(n+1)(2nCn) = Submission[CiCn-i] , i=0 to n-1

#include <iostream>
using namespace std;
unsigned long int catalan(unsigned int n)
{
    if (n <= 1)
        return 1;
    // catalan(n) is sum of
    // catalan(i)*catalan(n-i-1)
    unsigned long int res = 0;
    for (int i = 0; i < n; i++)
        res += catalan(i) * catalan(n - i - 1);
    return res;
}
int main()
{
    for (int i = 0; i < 10; i++)
        cout << catalan(i) << " ";
    return 0;
}

// Inclusion-Exclusion Principle - 

// Chinese Remainder Theorem -
     We are given two arrays num[0..k-1] and rem[0..k-1]. In num[0..k-1], every pair is coprime (gcd for every pair is 1). We need to find minimum positive number x such that: 
     
     x % num[0]    =  rem[0], 
     x % num[1]    =  rem[1], 
     .......................
     x % num[k-1]  =  rem[k-1]
     
     Basically, we are given k numbers which are pairwise coprime, and given remainders of these numbers when an unknown number x is divided by them. We need to find the minimum possible value of x that produces given remainders.
Examples : 
 

Input:  num[] = {5, 7}, rem[] = {1, 3}
Output: 31
Explanation: 
31 is the smallest number such that:
  (1) When we divide it by 5, we get remainder 1. 
  (2) When we divide it by 7, we get remainder 3.

Input:  num[] = {3, 4, 5}, rem[] = {2, 3, 1}
Output: 11
Explanation: 
11 is the smallest number such that:
  (1) When we divide it by 3, we get remainder 2. 
  (2) When we divide it by 4, we get remainder 3.
  (3) When we divide it by 5, we get remainder 1.

#include<bits/stdc++.h>
using namespace std;
// k is size of num[] and rem[]. Returns the smallest number x such that:
// x % num[0] = rem[0],
// x % num[1] = rem[1],
// ..................
// x % num[k-2] = rem[k-1]
// Assumption: Numbers in num[] are pairwise coprime
// (gcd for every pair is 1)
int findMinX(int num[], int rem[], int k)
{
	int x = 1; // Initialize result
	// As per the Chinese remainder theorem, this loop will always break.
	while (true)
	{
		// Check if remainder of x % num[j] is rem[j] or not (for all j from 0 to k-1)
		int j;
		for (j=0; j<k; j++ )
			if (x%num[j] != rem[j])
			break;
		// If all remainders matched, we found x
		if (j == k)
			return x;
		// Else try next number
		x++;
	}
	return x;
}
int main(void)
{
	int num[] = {3, 4, 5};
	int rem[] = {2, 3, 1};
	int k = sizeof(num)/sizeof(num[0]);
	cout << "x is " << findMinX(num, rem, k);
	return 0;
}
  
// Lucas Theorem
// Fermat's Little Theorem
// Probability Equation

// Factorial of a  Large Number

class Solution {
public:
    vector<int> factorial(int N){
         vector<int> res;
         res.push_back(1);
         
         for(int x=2;x<=N;x++){
             int car=0;
             for(int i=0;i<res.size();i++){
                 int val = res[i]*x+car;
                 res[i]=val %10;
                 car=val/10;
             }
             while(car!=0){
                 res.push_back(car%10);
                 car/=10;
             }
         }
         reverse(res.begin(),res.end());
         return res;
    }
};

// Factorial using recursion

// #include<iostream>
// using namespace std;
// int factorial(int n){
//     if(n==0 || n==1){
//         return 1;
//     }
//     else{
//         return n*factorial(n-1);
//     }
// }
// int main(){
//     int n;
//     cout<<"Enter the number:";
//     cin>>n;
//     cout<<factorial(n);
//     return 0;
// }

// Power of 2 using recursion

// #include<iostream>
// using namespace std;
// int power(int n){
//     if(n==0){
//         return 1;
//     }
//     else{
//         return 2*power(n-1);
//     }
// }
// int main(){
//     int n;
//     cout<<"Enter the number:";
//     cin>>n;
//     cout<<power(n);
//     return 0;
// }

// Print counting using recursion

// #include<iostream>
// using namespace std;
// void Print(int n){
//     if(n==0){
//         return;
//     }
//     Print(n-1);
//     cout<<n<<" ";
// }
// int main(){
//     int n;
//     cout<<"Enter the number:";
//     cin>>n;
//     Print(n);
//     return 0;
// }

// Reach Home using recursion

// #include<iostream>
// using namespace std;
// void target(int src,int dest){
//     cout<<"source "<<src<<" destination "<<dest<<endl;
//     if(src==dest){
//         cout<<"Reached Home"<<endl;
//         return;
//     }
//     src++;
//     target(src,dest);
// }
// int main(){
//     int dest,src=1;
//     cout<<"Enter the destination:";
//     cin>>dest;
//     target(src,dest);
//     return 0;
// }

// Fibonacci Number

// class Solution {
// public:
//     int fib(int n) {
//         if(n==0){
//             return 0;
//         }
//         if(n==1){
//             return 1;
//         }
//         else{
//             return fib(n-1)+fib(n-2);
//         }
//     }
// };

// Count Ways To Reach The N-th Stairs

// #include <bits/stdc++.h>
// #define mod 1000000007
// int countDistinctWays(int nStairs) {
//     int n=nStairs;
//     int prev1=1;
//     int prev2=1;
//     int curr;
//     if(n==1 || n==0)
//         return 1;
//     for(int i=2;i<=n;i++){
//         curr=(prev1+prev2)%mod;
//         prev1=prev2;
//         prev2=curr;
//     }
//     return curr%mod;
// }

// Say digits

// Four One Two
// #include<iostream>
// using namespace std;
// void digit(string arr[],int n){
//     if(n==0){
//         return;
//     }
//     int r=n%10;
//     n=n/10;
//     digit(arr,n);
//     cout<<arr[r]<<" ";
// }
// int main(){
//     int n;
//     cout<<"Enter the number:";
//     cin>>n;
//     string arr[10]={"Zero","One","Two","Three","Four","Five","Six","Seven","Eight","Nine"};
//     digit(arr,n);
// }

// Two One Four
// #include<iostream>
// using namespace std;
// void digit(string arr[],int n){
//     if(n==0){
//         return;
//     }
//     int r=n%10;
//     n=n/10;
//     cout<<arr[r]<<" ";
//     digit(arr,n);
// }
// int main(){
//     int n;
//     cout<<"Enter the number:";
//     cin>>n;
//     string arr[10]={"Zero","One","Two","Three","Four","Five","Six","Seven","Eight","Nine"};
//     digit(arr,n);
// }

// Sorting using recursion

// #include<iostream>
// using namespace std;
// bool Sorted(int arr[],int n){
//     if(n==0 || n==1){
//         return true;
//     }
//     if(arr[0]>arr[1]){
//         return false;
//     }
//     else{
//         bool ans=Sorted(arr+1,n-1);;
//         return ans;
//     }
// }
// int main(){
//     int n;
//     cout<<"Enter the size of the array:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     int ans=Sorted(arr,n);
//     if(ans){
//         cout<<"Array is sorted";
//     }
//     else{
//         cout<<"Array is not sorted";
//     }
//     return 0;
// }

// Sum of array using recursion

// #include<iostream>
// using namespace std;
// int sum(int arr[],int n){
//     if(n==0){
//         return 0;
//     }
//     if(n==1){
//         return arr[0];
//     }
//     else{
//         int leftover=sum(arr+1,n-1);
//         int ans=arr[0]+leftover;
//         return ans;
//     }
// }
// int main(){
//     int n;
//     cout<<"Enter the number:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the size of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     cout<<sum(arr,n);
//     return 0;
// }

// Linear search using recursion

// #include<iostream>
// using namespace std;
// bool LinearSearch(int arr[],int n,int search){
//     if(n==0){
//         return false;
//     }
//     if(arr[0]==search){
//         return true;
//     }
//     else{
//         bool leftover=LinearSearch(arr+1,n-1,search);
//         return leftover;
//     }
// }
// int main(){
//     int n;
//     cout<<"Enter the size of the array:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     int search;
//     cout<<"Enter the element you want to search for:";
//     cin>>search;
//     bool ans=LinearSearch(arr,n,search);
//     if(ans){
//         cout<<"Element "<<search<<" is present in the array";
//     }
//     else{
//         cout<<"Element "<<search<<" is not present in the array";
//     }
//     return 0;
// }

// Binary search using recursion

// #include<iostream>
// using namespace std;
// bool BinarySearch(int arr[],int start,int end,int search){
//     if(start>end){
//         return false;
//     }
//     int mid=start+(end-start)/2;
//     if(arr[mid]==search){
//         return true;
//     }
//     if(arr[mid]<search){
//         return BinarySearch(arr,mid+1,end,search);
//     }
//     else{
//         return BinarySearch(arr,start,mid-1,search);
//     }
// }
// int main(){
//     int n;
//     cout<<"Enter the size of the array:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     int search;
//     cout<<"Enter the element you want to search for:";
//     cin>>search;
//     bool ans=BinarySearch(arr,0,n-1,search);
//     if(ans){
//         cout<<"Element "<<search<<" is present in the array";
//     }
//     else{
//         cout<<"Element "<<search<<" is not present in the array";
//     }
//     return 0;
// }

// BinarySearch using recursion(CS)

// int BinarySearch(int arr[],int s,int e,int k){
//     int mid=s+(e-s)/2;
//     if(s>e){
//         return -1;
//     }
//     if(arr[mid]==k){
//         return mid;
//     }
//     if(arr[mid]<k){
//         return BinarySearch(arr, mid+1, e, k);
//     }
//     else{
//         return BinarySearch(arr,s,mid-1,k);
//     }
// }
// int binarySearch(int *input, int n, int val)
// {
//     int ans=BinarySearch(input, 0, n-1, val);
//     return ans;
// }

// Reverse string using recursion

// #include<iostream>
// #include<algorithm>
// using namespace std;
// void ReverseString(string &str,int s,int e){
//     if(s>e){
//         return;
//     }
//     swap(str[s++],str[e--]);
//     ReverseString(str,s,e);
// }
// int main(){
//     string str;
//     cout<<"Enter the string:";
//     cin>>str;
//     ReverseString(str,0,str.length()-1);
//     cout<<str;
//     return 0;
// }

// #include<iostream>
// #include<algorithm>
// using namespace std;
// void ReverseString(string &str,int s){
//     int l=str.length()-s-1;
//     if(s>=l){
//         return;
//     }
//     swap(str[s++],str[l--]);
//     ReverseString(str,s);
// }
// int main(){
//     string str;
//     cout<<"Enter the string:";
//     cin>>str;
//     ReverseString(str,0);
//     cout<<str;
//     return 0;
// }

// Check Palindrome

// #include<iostream>
// #include<algorithm>
// using namespace std;
// bool CheckPalindrome(string &str,int s,int e){
//     if(s>e){
//         return true;
//     }
//     if(str[s]!=str[e]){
//         return false;
//     }
//     else{
//         return CheckPalindrome(str,s+1,e-1);
//     }
// }
// int main(){
//     string str;
//     cin>>str;
//     bool ans=CheckPalindrome(str,0,str.length()-1);
//     if(ans){
//         cout<<"String is a palindorme";
//     }
//     else{
//         cout<<"String is not a palindrome";
//     }
//     return 0;
// }

// #include<iostream>
// #include<algorithm>
// using namespace std;
// bool CheckPalindrome(string &str,int s){
//     int l=str.length()-s-1;
//     if(s>l){
//         return true;
//     }
//     if(str[s++]==str[l--]){
//          return CheckPalindrome(str,s+1);
//     }
//     else{
//        return false;
//     }
// }
// int main(){
//     string str;
//     cin>>str;
//     bool ans=CheckPalindrome(str,0);
//     if(ans){
//         cout<<"String is a palindorme";
//     }
//     else{
//         cout<<"String is not a palindrome";
//     }
//     return 0;
// }

// Power using recursion

// #include<iostream>
// #include<algorithm>
// using namespace std;
// int power(int b,int e){
//     if(e==0){
//         return 1;
//     }
//     if(e==1){
//         return b;
//     }
//     int ans = power(b,e/2);
//     if(e%2==0){
//         return ans*ans;
//     }
//     else{
//         return b*ans*ans;
//     }
// }
// int main(){
//     int b,e;
//     cout<<"Enter the values of base and exponent:";
//     cin>>b>>e;
//     int ans=power(b,e);
//     cout<<ans;
//     return 0;
// }

// Bubble sort using recursion

// #include<iostream>
// #include<algorithm>
// using namespace std;
// void BubbleSort(int arr[],int n){
//     if(n==0 || n==1){
//         return;
//     }
//     for(int i=0;i<n;i++){
//         if(arr[i]>arr[i+1]){
//             swap(arr[i],arr[i+1]);
//         }
//     }
//     BubbleSort(arr,n-1);
// }
// int main(){
//     int n;
//     cout<<"Enter the size of the array:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     BubbleSort(arr,n);
//     for (int i = 0; i < n; i++)
//     {
//         cout<<arr[i]<<" ";
//     }
//     return 0;
// }

// Selection sort suing recursion

// #include<iostream>
// #include<algorithm>
// using namespace std;
// void SelectionSort(int arr[],int start,int n){
//     if(n<=start){
//         return;
//     }
//     int minIndex=start;
//     for(int i=start;i<n;i++){
//         if(arr[i]<arr[minIndex]){
//             minIndex=i;
//         }
//     }
//     swap(arr[minIndex],arr[start]);
//     SelectionSort(arr,start+1,n);
// }
// int main(){
//     int n;
//     cout<<"Enter the size of the array:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     SelectionSort(arr,0,n);
//     for (int i = 0; i < n; i++)
//     {
//         cout<<arr[i]<<" ";
//     }
//     return 0;
// }

// Insertion Sort using recursion

// #include<iostream>
// #include<algorithm>
// using namespace std;
// void InsertionSort(int arr[],int n){
//     if(n<=1){
//         return;
//     }
//     InsertionSort(arr,n-1);
//     int last=arr[n-1];
//     int j=n-2;
//     while(j>=0 && arr[j]>last){
//         arr[j+1]=arr[j];
//         j--;
//     }
//     arr[j+1]=last;
// }
// int main(){
//     int n;
//     cout<<"Enter the size of the array:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     InsertionSort(arr,n);
//     for (int i = 0; i < n; i++)
//     {
//         cout<<arr[i]<<" ";
//     }
//     return 0;
// }

// Merge Sort

// void merging(vector<int> &arr, int s, int e)
// {
//     int mid = s + (e - s) / 2;
//     int length1 = mid + 1 - s;
//     int length2 = e - mid;
//     int *arr1 = new int[length1];
//     int *arr2 = new int[length2];
//     int mainIndexArray = s;
//     for (int i = 0; i < length1; i++)
//     {
//         arr1[i] = arr[mainIndexArray++];
//     }
//     mainIndexArray = mid + 1;
//     for (int i = 0; i < length2; i++)
//     {
//         arr2[i] = arr[mainIndexArray++];
//     }
//     int index1 = 0;
//     int index2 = 0;
//     mainIndexArray = s;
//     while (index1 < length1 && index2 < length2)
//     {
//         if (arr1[index1] < arr2[index2])
//         {
//             arr[mainIndexArray++] = arr1[index1++];
//         }
//         else
//         {
//             arr[mainIndexArray++] = arr2[index2++];
//         }
//     }
//     while (index1 < length1)
//     {
//         arr[mainIndexArray++] = arr1[index1++];
//     }
//     while (index2 < length2)
//     {
//         arr[mainIndexArray++] = arr2[index2++];
//     }
// }
// void merge(vector<int> &arr, int s, int e)
// {
//     if (s >= e)
//     {
//         return;
//     }
//     int mid = s + (e - s) / 2;
//     merge(arr, s, mid);
//     merge(arr, mid + 1, e);
//     merging(arr, s, e);
// }
// void mergeSort(vector<int> &arr, int n) { merge(arr, 0, n - 1); }

// Quick Sort

// #include<iostream>
// #include<algorithm>
// using namespace std;
// int parts(int arr[],int s,int e){
//     int pivot=arr[s];
//     int count=0;
//     for (int i = s+1; i <= e ; i++)
//     {
//         if(arr[i]<= pivot){
//             count++;
//         }
//     }
//     int pivotIndex=s+count;
//     swap(arr[pivotIndex],arr[s]);
//     int i=s,j=e;
//     while(i<pivotIndex && j>pivotIndex){
//         while(arr[i]<pivot){
//             i++;
//         }
//         while(arr[i]>pivot){
//             j--;
//         }
//         if(i<pivotIndex && j>pivotIndex){
//             swap(arr[i++],arr[j--]);
//         }
//     }
//     return pivotIndex;
// }
// void QuickSort(int arr[],int s,int e){
//     if(s>=e){
//         return;
//     }
//     int p = parts(arr,s,e);
//     QuickSort(arr,s,p-1); 
//     QuickSort(arr,p+1,e); 
// }
// int main()
// {
//     int n;
//     cout << "Enter the size of the array:";
//     cin >> n;
//     int arr[n];
//     cout << "Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin >> arr[i];
//     }
//     QuickSort(arr, 0, n - 1);
//     for (int i = 0; i < n; i++)
//     {
//         cout << arr[i] << " ";
//     }
//     return 0;
// }

// Subsets using recursion

// class Solution {
// public:
//     void solve(vector<int> nums,vector<int> output,int index,vector<vector<int>> &ans){
//         if(index>=nums.size()){
//             ans.push_back(output);
//             return;
//         }
//         solve(nums,output,index+1,ans);
//         int element=nums[index];
//         output.push_back(element);
//         solve(nums,output,index+1,ans);
//     }
//     vector<vector<int>> subsets(vector<int>& nums) {
//         vector<vector<int>> ans;
//         vector<int> output;
//         int index=0;
//         solve(nums,output,index,ans);
//         return ans;
//     }
// };

// Subsets using Bit Manipulation

// #include <bits/stdc++.h>
// using namespace std;
// // Function to find all subsets of given set. Any repeated subset is considered only once in the output
// vector<vector<int> > findPowerSet(vector<int>& nums)
// {
// 	// Size of array to set bit
// 	int bits = nums.size();
// 	// Total number of subsets = pow(2, sizeof(arr))
// 	unsigned int pow_set_size = pow(2, bits);
// 	// Sort to avoid adding permutation of the substring
// 	sort(nums.begin(), nums.end());
// 	vector<vector<int> > ans;
// 	// To store subset as a list toavoid adding exact duplicates
// 	vector<string> list;
// 	// Counter 000..0 to 111..1
// 	for (int counter = 0; counter < pow_set_size;
// 		counter++) {
// 		vector<int> subset;
// 		string temp = "";
// 		// Check for the current bit in the counter
// 		for (int j = 0; j < bits; j++) {
// 			if (counter & (1 << j)) {
// 				subset.push_back(nums[j]);
// 				// Add special character to separate integers
// 				temp += to_string(nums[j]) + '$';
// 			}
// 		}
// 		if (find(list.begin(), list.end(), temp)
// 			== list.end()) {
// 			ans.push_back(subset);
// 			list.push_back(temp);
// 		}
// 	}
// 	return ans;
// }
// int main()
// {
// 	vector<int> arr{ 10, 12, 12 };
// 	vector<vector<int> > power_set = findPowerSet(arr);
// 	for (int i = 0; i < power_set.size(); i++) {
// 		for (int j = 0; j < power_set[i].size(); j++)
// 			cout << power_set[i][j] << " ";
// 		cout << endl;
// 	}
// 	return 0;
// }

// Subsequences of String using Recursion

// #include <bits/stdc++.h>
// using namespace std;
// void solve(string str, string output, int index, vector<string> &ans) {
//   // base case
//   if (index >= str.length()) {
//     if (output.length() > 0) {
//       ans.push_back(output);
//     }
//     return;
//   }
//   // exclude
//   solve(str, output, index + 1, ans);
//   // include
//   char element = str[index];
//   output.push_back(element);
//   solve(str, output, index + 1, ans);
// }
// vector<string> subsequences(string str) {
//   // Write your code here
//   vector<string> ans;
//   string output = "";
//   int index = 0;
//   solve(str, output, index, ans);
//   return ans;
// }

// Subsequences of String using Bit Manipulation

// #include<bits/stdc++.h>
// using namespace std;
// string print(string s , int i){
// 	int j = 0;
// 	string sub;
// 	//finding where the bit is set
// 	while(i>0){
// 		if(i & 1){
// 			sub.push_back(s[j]); //pushing only when bit is set
// 		}
// 		j++; //always incrementing the index pointer
// 		i = i >> 1;
// 	}	
// 	return sub;
// }
// vector<string> createsubsets(string& s){	
// 	vector <string> res;
// 	for(int i = 1 ; i <= ((1 << s.size()) - 1) ; i++){
// 		//each time we create a subsequence for corresponding binary representation
// 		res.push_back(print(s,i));
// 	}
// 	return res;
// }
// int main(){
// 	string s = "abc";
// 	//vector of strings to store all sub-sequences
// 	vector <string> print = createsubsets(s);	
// 	//print function
// 	for(int i = 0 ; i < print.size() ; i++){
// 		for (int j = 0; j < print[i].size(); j++){
// 			cout << print[i][j]<<" ";
// 		}
// 		cout << endl;
// 	}
// 	return 0;
// }

// Letter Combinations of a Phone Number(Phone Keypad Problem)

// class Solution {
// public:
//     void solve(string digits,string output,int index,vector<string> &ans,string mapping[]){
//         if(index>=digits.length()){
//             ans.push_back(output);
//             return;
//         }
//         int number=digits[index]-'0';
//         string value=mapping[number];
//         for(int i=0;i<value.length();i++){
//             output.push_back(value[i]);
//             solve(digits,output,index+1,ans,mapping);
//             output.pop_back();
//         }
//     }
//     vector<string> letterCombinations(string digits) {
//         vector<string> ans;
//         if(digits.length()==0){
//             return ans;
//         }
//         string output="";
//         int index=0;
//         string mapping[10]={""," ","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
//         solve(digits,output,index,ans,mapping);
//         return ans;
//     }
// };

// Permutations of a string

// class Solution {
// public:
//     void solve(vector<int>& nums,vector<vector<int>> &ans,int index){
//         if(index>=nums.size()){
//             ans.push_back(nums);
//             return;
//         }
//         for(int i=index;i<nums.size();i++){
//             swap(nums[i],nums[index]);
//             solve(nums,ans,index+1);
//             swap(nums[i],nums[index]);
//         }
//     }
//     vector<vector<int>> permute(vector<int>& nums) {
//         vector<vector<int>> ans;
//         int index=0;
//         solve(nums,ans,index);
//         return ans;
//     }
// };

// Rat in a Maze Problem - I

class Solution{
    private:
    bool safe(int x ,int y , int n , vector<vector<int>> visited ,vector<vector<int>> &m ){
        if( ( x >= 0 && x < n ) && ( y >= 0 && y < n ) && visited[x][y] == 0 && m[x][y] == 1){
            return true; 
        }
        else{
            return false;
        }
    }
    void solve(vector<vector<int>> &m , int n ,vector<string>& ans , int x , int y ,vector<vector<int>> visited , string path){
        //base case
        if( x == n - 1 && y == n - 1 ){
            ans.push_back(path);
            return ;
        }
        //when you cover that index
        visited[x][y] = 1;
        // their are  choices     
        // 1st is Down
        int newx = x + 1;
        int newy = y;
        if( safe( newx , newy , n ,visited , m)){
            path.push_back('D');
            solve( m , n , ans , newx , newy , visited , path);
            path.pop_back();
        }
        // 1st is Left
         newx = x;
         newy = y - 1;
        if( safe( newx , newy , n ,visited , m)){
            path.push_back('L');
            solve( m , n , ans , newx , newy , visited , path);
            path.pop_back();
        }
        // 1st is Right
        newx = x;
        newy = y + 1;
        if( safe( newx , newy , n ,visited , m)){
            path.push_back('R');
            solve( m , n , ans , newx , newy , visited , path);
            path.pop_back();
        }
        // 1st is Up
         newx = x - 1;
         newy = y;
        if( safe( newx , newy , n ,visited , m)){
            path.push_back('U');
            solve( m , n , ans , newx , newy , visited , path);
            path.pop_back();
        }
        visited[x][y] = 0;
    }
    public:
    vector<string> findPath(vector<vector<int>> &m, int n) {
        vector<string>ans ;
        if( m [0][0] == 0){
            return ans;
        }
        int srcx = 0;
        int srcy = 0;
        // Make a visited 2D vector
        vector<vector<int>> visited = m;
        // make it default by all indeces by 0
        for( int i = 0; i < n; i++){
            for( int j = 0; j < n; j++){
                visited [i][j] = 0;
            }
        }
        string path = "";
        solve( m , n , ans , srcx , srcy , visited , path);
        sort(ans.begin() , ans.end());
        return ans;
    }
};
    
/************************************************************

    Following is the linked list node structure.
    
    class Node 
    {
        public:
        int data;
        Node* next;

        Node(int data) 
        {
            this->data = data;
            this->next = NULL;
        }
    };
    
************************************************************/    
    
// Reverse a Linked List

LinkedListNode<int> *reverseLinkedList(LinkedListNode<int> *head) 
{
    if(head == NULL || head->next == NULL){
        return head;
    }
    LinkedListNode<int>* prev=NULL;
    LinkedListNode<int>* curr=head;
    LinkedListNode<int>* forw=NULL;
    while(curr!=NULL){
        forw=curr->next;
        curr->next=prev;
        prev=curr;
        curr=forw;
    }
    return prev;
}

// Reverse a Linked List(Recursively)

LinkedListNode<int> *rev(LinkedListNode<int> *head) {
	  if (head == NULL || head->next == NULL){
	    return head;
	  }
LinkedListNode<int> *chotaHead = rev(head->next);
	  head->next->next = head;
	  head->next = NULL;
	  return chotaHead;
}
LinkedListNode<int> *reverseLinkedList(LinkedListNode<int> *head) {
    return rev(head);
}

// Reverse a Doubly Linked List

Node* reverseDLL(Node * head){
    Node *prev = NULL;
    Node *curr = head;
    Node *temp=NULL;
    while(curr!=NULL){
        temp = curr->prev;
        curr->prev = curr->next;
        curr->next = temp;
        prev = curr;
        curr = curr->prev;
    }
    return prev;
}

// Middle of a Linked List

int getLength(Node *head){
    int ans=0;
    while(head){
        ans++;
        head=head->next;
    }
    return ans;
}
Node *findMiddle(Node *head) {
    int n=getLength(head);
    int t=n/2;
    Node *ans=head;
    while(t--){
        ans=ans->next;
    }
    return ans;
}

// Reverse Nodes In K-Group

Node *krevgroup(Node *head, int n, int b[], int i)
{
    if (n<1 || head == NULL || head->next == NULL){
        return head;
    }
    Node *prev = NULL;
    Node *curr = head;
    Node *nxt = NULL;
    int cnt = 0;
    while(b[i] == 0 && i < n){ 
    	i++;
    }
    while (curr != NULL && cnt < b[i] && i < n  ){
        nxt = curr->next;
         curr->next = prev;
        prev = curr;
        curr = nxt;
        cnt++;
    }
    if (i >= n && curr != NULL){
        return head;
    }
    if (curr != NULL)
        head->next = krevgroup(nxt, n, b, i + 1);
    return prev;
}
Node *getListAfterReverseOperation(Node *head, int n, int b[]){
	return krevgroup(head,n,b,0);
}

// Circularly LinkedList

// Method-1
bool isCircularList(Node *head){
    //empty list
    if(head==NULL){
    	return head;
    }
    Node *temp=head->next;
    while(temp!=NULL && temp!=head){
          temp=temp->next;
    }
    if(temp==head){
          return true;
    }
    return false;
}

// Method-2
bool isCircular(Node* head){
    if(head==NULL){
        return 1;
    }
    Node* slow=head;
    Node* fast=head;
    while(fast!=NULL && fast->next!=NULL){
        slow=slow->next;
        fast=fast->next->next;
        if(slow==fast){
            if(slow==head){
                return 1;
            }
            else{
                return 0;
            }
        }
    }
    return 0;
}

// Method-3
bool hasCycle(ListNode *head){
	unordered_map<ListNode*,bool>map;
	ListNode *temp=head;
	while(temp!=NULL){
		if(map.find(temp)!=map.end())
			return ttrue;
		map[temp]=true;
		temp=temp->next;
	}
	return false;
}

// Detect and Remove Loop

// Method-1 for detection of loop
bool detectLoop(Node *head){
	if(head==NULL) return false;
	map<Noode*,bool> visited;
	Node *temp=head;
	while(temp!=NULL){
		if(visited[temp]==true){
			return true;
		}
		visited[temp]=true;
		temp=temp->next;
	}
	return false;
}

//this is to find cycle in the loop
Node* floydCycle(Node* head)
{
    if(head == NULL){
        return NULL;
    }
    Node* slow = head;
    Node* fast = head;
    while(slow!=NULL && fast!=NULL){
        fast = fast->next;
        if(fast!=NULL){
            fast = fast->next;
        }
        slow = slow->next;
        if(slow == fast){
            return slow;
        }
    }
    return NULL;
}
//this is to find first element from where loop started 
Node* loopFind(Node* head){
    if(head == NULL){
        return NULL;
    }
    Node* meet = floydCycle(head);
    if(meet == NULL){
        return NULL;
    }
    Node* slow = head;
    while(slow!= meet){
        slow = slow->next;
        meet = meet->next;
    }
    return slow;
}
//this is to remove the loop
Node *removeLoop(Node *head){
    if(head == NULL){
        return NULL;
    }
    Node* startLoop = loopFind(head);
    if(startLoop == NULL){
        return head;
    }
    Node* temp = startLoop;
    while(temp->next!= startLoop){
        temp = temp->next;
    }
    temp->next = NULL;
    return head;
}

// Remove Duplicates From a Sorted Linked List

Node * uniqueSortedList(Node * head) {
    if(head==NULL) return NULL;
    Node* curr=head;
    while(curr!=NULL){
        if(curr->next!=NULL && curr->data==curr->next->data){
            Node* next_next=curr->next->next;
            Node* nodeToDelete=curr->next;
            delete(nodeToDelete);
            curr->next= next_next;
        }
        else{
            curr=curr->next; 
        }
    }
    return head;
}

// Remove Duplicates from a Unsorted Linked List

// Method-1[Brute Force(T.C --> O(n^2),S.C --> O(1))]
Node *removeDuplicates(Node *head)
{
    if(head == NULL) return NULL;
    Node* curr = head;
    while(curr != NULL) {
        Node* temp = curr;
        while(temp -> next != NULL) {
            if(curr -> data == temp -> next -> data){
                Node* next_next = temp -> next -> next;
                Node* nodeToDelete = temp -> next;
                nodeToDelete -> next = NULL;
                delete nodeToDelete;
                temp -> next = next_next;
            }
            else
                temp = temp -> next;
        }
        curr = curr -> next;
    }
    return head;
}

// Method-2
Node *removeDuplicates(Node *head)
{
    if( head == NULL){
        return NULL;
    }
    unordered_map< int, bool> visited;
    Node *curr = head;
    while( curr -> next != NULL){
        visited[curr -> data ] = true;
        if( visited[curr -> next -> data] == true){
            curr -> next = curr -> next -> next;
        }
        else{
            curr = curr -> next;
        }
    }
    return head;
}

// Method-3(sort then use above question approach)

// Split LinkedList in two halves

void splitList(Node *head, Node **head1_ref, Node **head2_ref)
{
    // using two pointer approach fast and slow which is used to calculate middle node
    Node *fast=head->next;
    Node *slow = head;
    
    while(fast->next!=head){
        fast=fast->next;
        if(fast->next!=head){
            fast=fast->next;
        }
        slow=slow->next;
    }
    Node* temp=slow->next;
    slow->next=head;
    fast->next=temp;
    *head1_ref=head;
    *head2_ref=temp;
}

// Split Linked List in parts
		
class Solution {
public:
    vector<ListNode*> splitListToParts(ListNode* head, int k) {
        vector<ListNode*> ans;
        int len=0;
        ListNode *temp=head;
        while(temp!=NULL)
        {
            len++;
            temp=temp->next;
        }
        int size=len/k;
        int rem=len%k;
        temp=head;
        for(int i=0;i<k;i++)
        {
            ListNode *end=temp;
            if(rem>0)
            {
                int c=size;
                while(c--)
                {
                    end=end->next;
                }
                ListNode *x=end->next;
                end->next=NULL;
                ans.push_back(temp);
                temp=x;
                rem--;
            }
            else
            {
                if(size==0)
                {
                    ans.push_back(NULL);    
                }
                else
                {
                    int c=size-1;
                    while(c--)
                    {
                        end=end->next;
                    }
                    ListNode*x=end->next;
                    end->next=NULL;
                    ans.push_back(temp);
                    temp=x;
                }
            }
        }
        return ans;
    }
};	

// Sort 0s,1s and 2s in Linked List

// Method 1
class Solution
{
    public:
    //Function to sort a linked list of 0s, 1s and 2s.
    Node* segregate(Node *head) {
        int zeroCount=0,oneCount=0,twoCount=0;
        Node *temp=head;
        while(temp!=NULL){
            if(temp->data==0) zeroCount++;
            else if(temp->data==1) oneCount++;
            else if(temp->data==2) twoCount++;
            temp=temp->next;
        }
        temp=head;
        while(temp!=NULL){
            if(zeroCount!=0){
                temp->data=0;
                zeroCount--;
            }
            else if(oneCount!=0){
                temp->data=1;
                oneCount--;
            }
            else if(twoCount!=0){
                temp->data=2;
                twoCount--;
            }
            temp=temp->next;
        }
        return head;
    }
};

// Method 2
class Solution
{
    public:
    void insertAtTail(Node *&tail,Node *curr){
        tail->next=curr;
        tail=curr;
    }
    Node* segregate(Node *head) {
        Node *zeroHead=new Node(-1);
        Node *zeroTail=zeroHead;
        Node *oneHead=new Node(-1);
        Node *oneTail=oneHead;
        Node *twoHead=new Node(-1);
        Node *twoTail=twoHead;
        Node *curr=head;
        // created seperate list of 0s,1s and 2s
        while(curr!=NULL){
            int val=curr->data;
            if(val==0) insertAtTail(zeroTail,curr);
            else if(val==1) insertAtTail(oneTail,curr);
            else if(val==2) insertAtTail(twoTail,curr);
            curr=curr->next;
        }
        // merging above list
        if(oneHead->next!=NULL){
            zeroTail->next=oneHead->next;
        }
        else{
            zeroTail->next=twoHead->next;   
        }
        oneTail->next=twoHead->next;
        twoTail->next=NULL;
        // setup head
        head=zeroHead->next;
        // delete dummy nodes
        delete zeroHead;
        delete oneHead;
        delete twoHead;
        return head;
    }
};

// Merge two sorted arrays in a Linked List

Node<int>* solve( Node<int>* first , Node<int>* second){

    if( first -> next == NULL){
        first -> next = second;
        return first;
    }
    Node<int>* curr1 = first;
    Node<int>* next1 = curr1 -> next;
    Node<int>* curr2 = second;
    Node<int>* next2 = curr2 -> next;
    while( next1 != NULL and curr2 != NULL){
        if( (curr2 -> data >= curr1 -> data) and (curr2 -> data <= next1 -> data)){
            curr1 -> next = curr2;
            next2 = curr2 -> next;
            curr2 -> next = next1;
            curr1 = curr2;
            curr2 = next2;
        }
        else{
            curr1 = next1;
            next1 =  next1 -> next;

            if( next1 == NULL){
                curr1 -> next = curr2;
                return first;
            }
        }
    }
    return first;
}

Node<int>* sortTwoLists(Node<int>* first, Node<int>* second)
{
    if(first == NULL){
        return second;
    }
    if(second == NULL){
        return first;
    }

    if( first -> data <= second -> data){
        return solve( first , second );
    }
    else{
        return solve( second , first );
    }
}

// using recursion
Node<int>* sortTwoLists(Node<int>* first, Node<int>* second)
{
    if(first==NULL){
        return second;
    }
    if (second=NULL) {
        return first;
    }
    if(first->data<=second->data){
        first->next=sortTwoLists(first->next,second);
        return first;
    }
    else{
        second->next=sortTwoLists(first,second->next);
        return second;
    }
}

// Linked List is Palindrome or not

// Method 1
#include<vector>
class Solution{
  public:
    bool checkPalindrome(vector<int> arr){
        int n=arr.size();
        int s=0,e=n-1;
        while(s<=e){
            if(arr[s]!=arr[e]){
                return 0;
            }
            s++;
            e--;
        }
        return 1;
    }
    bool isPalindrome(Node *head)
    {
        vector<int> arr;
        Node *temp=head;
        while(temp!=NULL){
            arr.push_back(temp->data);
            temp=temp->next;
        }
        return checkPalindrome(arr);
    }
};

// Method 2
class Solution{
  public:
    Node *getMid(Node *head){
        Node *slow=head;
        Node *fast=head->next;
        while(fast!=NULL && fast->next!=NULL){
            fast=fast->next->next;
            slow=slow->next;
        }
        return slow;
    }
    Node *reverse(Node *head){
        Node *curr=head;
        Node *prev=NULL;
        Node *forward=NULL;
        while(curr!=NULL){
            forward=curr->next;
            curr->next=prev;
            prev=curr;
            curr=forward;
        }
        return prev;
    }
    bool isPalindrome(Node *head)
    {
        if(head->next==NULL){
            return true;    
        } 
        // find mid
        Node *mid=getMid(head);
        // reverse list after mid
        Node *temp=mid->next;
        mid->next=reverse(temp);
        // compare both halves
        Node *head1=head;
        Node *head2=mid->next;
        while(head2!=NULL){
            if(head1->data!=head2->data){
                return false;
            }
            head1=head1->next;
            head2=head2->next;
        }
        // form the same linkedlist given 
        temp=mid->next;
        mid->next=reverse(temp);
        return true;
    }
};

// Add two Numbers in a linked list

// Method-1
class Solution
{
    public:
    struct Node *reverse(Node *head){
        Node *curr=head;
        Node *prev=NULL;
        Node *forward=NULL;
        while(curr!=NULL){
            forward=curr->next;
            curr->next=prev;
            prev=curr;
            curr=forward;
        }
        return prev;
    }
    void insertAtTail(struct Node* &head, struct Node* &tail,int val){
        Node *temp=new Node(val);
        // empty list
        if(head==NULL){
            head=temp;
            tail=temp;
            return;
        }
        // non-empty list
        else{
            tail->next=temp;
            tail=temp;
        }
    }
    struct Node *add(struct Node* first, struct Node* second){
        Node *ansHead=NULL;
        Node *ansTail=NULL;
        int carry=0;
        while(first!=NULL && second!=NULL){
            int sum=carry+first->data+second->data;
            int digit=sum%10;
            // create node and add in answer linked list
            insertAtTail(ansHead,ansTail,digit);
            carry=sum/10;
            first=first->next;
            second=second->next;
        }
        while(first!=NULL){
            int sum=carry+first->data;
            int digit=sum%10;
            // create node and add in answer linked list
            insertAtTail(ansHead,ansTail,digit);
            carry=sum/10;
            first=first->next;
        }
        while(second!=NULL){
            int sum=carry+second->data;
            int digit=sum%10;
            // create node and add in answer linked list
            insertAtTail(ansHead,ansTail,digit);
            carry=sum/10;
            second=second->next;
        }
        while(carry!=0){
            int sum=carry;
            int digit=sum%10;
            // create node and add in answer linked list
            insertAtTail(ansHead,ansTail,digit);
            carry=sum/10;
        }
        return ansHead;
    }
    struct Node* addTwoLists(struct Node* first, struct Node* second)
    {
        // reverse the linked lists which are to be added
        first=reverse(first);
        second=reverse(second);
        // perform addition
        Node *ans=add(first,second);
        // reverse the answer linked list
        ans=reverse(ans);
        return ans;
    }
};

// Method-2(same method but less complicated)
class Solution
{
    public:
    struct Node *reverse(Node *head){
        Node *curr=head;
        Node *prev=NULL;
        Node *forward=NULL;
        while(curr!=NULL){
            forward=curr->next;
            curr->next=prev;
            prev=curr;
            curr=forward;
        }
        return prev;
    }
    void insertAtTail(struct Node* &head, struct Node* &tail,int val){
        Node *temp=new Node(val);
        // empty list
        if(head==NULL){
            head=temp;
            tail=temp;
            return;
        }
        // non-empty list
        else{
            tail->next=temp;
            tail=temp;
        }
    }
    struct Node *add(struct Node* first, struct Node* second){
        Node *ansHead=NULL;
        Node *ansTail=NULL;
        int carry=0;
        while(first!=NULL || second!=NULL || carry!=0){
            int val1=0;
            if(first!=NULL){
                val1=first->data;
            }
            int val2=0;
            if(second!=NULL){
                val2=second->data;
            }
            int sum=carry+val1+val2;
            int digit=sum%10;
            // create node and add in answer linked list
            insertAtTail(ansHead,ansTail,digit);
            carry=sum/10;
            if(first!=NULL){
                first=first->next;
            }
            if(second!=NULL){
                second=second->next;
            }
        }
        return ansHead;
    }
    struct Node* addTwoLists(struct Node* first, struct Node* second)
    {
        // reverse the linked lists which are to be added
        first=reverse(first);
        second=reverse(second);
        // perform addition
        Node *ans=add(first,second);
        // reverse the answer linked list
        ans=reverse(ans);
        return ans;
    }
};

// Add one to the number(Linked List)

// Method-1
class Solution
{
    public:
    Node* reverse(Node* head)
    {
        if(!head || !head->next)
            return head;
        Node* curr = head;
        Node* prev = NULL;
        Node* Next = head->next;
        while(curr->next!=NULL)
        {
            curr->next = prev;
            prev = curr;
            curr = Next;
            Next = Next->next;
        }
        curr->next = prev;
        return curr;
    }
    Node* addOne(Node *head) 
    {
        Node* newHead = reverse(head);
        Node* temp = newHead;
        while(temp->next != NULL && temp->data == 9)
        {
            temp->data = 0;
            temp = temp->next;
        }
        if(temp->data != 9)
            temp->data += 1;
        else if(temp->next == NULL && temp->data == 9)
        {
            temp->data = 0;
            temp->next = new Node(1);
        }
        return reverse(newHead);
    }
};

// Method-2
class Solution
{
    int recursiveAddition(Node*head)
    {
        if(head == NULL)
        {
            return 1;
        }
        int carry = recursiveAddition(head->next);
        int sum = head->data + carry;
        carry = sum / 10;
        sum = sum % 10;
        head->data = sum;
        return carry;
    }
    public:
    Node* addOne(Node *head) 
    {
        // return head of list after adding one
        int carry = recursiveAddition(head);
        if(carry == 0)
        {
            return head;
        }
        Node*temp = new Node(carry);
        temp->next = head;
        head = temp;
        return head;
    }
};

// Clone a Linked List with next and random pointers

// Method-1
class Solution
{
    public:
    Node *copyList(Node *head)
    {
        Node* temp = head;
        unordered_map <Node*, Node*> map;
        vector <Node*> vec;
        while(temp){
            Node* n = new Node(temp->data);
            vec.push_back(n);
            map[temp] = n;
            temp = temp->next;
        }
        for(int i=0; i<vec.size()-1; i++){
            vec[i]->next = vec[i+1];
        }
        vec[vec.size()-1] = NULL;
        temp = head;
        while(temp){
            map[temp]->arb = map[temp->arb];
            temp = temp->next;
        }
        return map[head];   
    }
};

// Method-2
class Solution
{
    public:
    Node *copyList(Node *head)
    {
        Node*current=head;
        while(current!=NULL){
        Node* temp = current->next;
        current->next = new Node(current->data);
        current->next->next = temp;
        current = temp;
        }
        current=head;
        
        //Setting random pointers to new nodes
    
        while(current!=NULL){
            
            current->next->arb = (current->arb) ? current->arb->next: current->arb;
            current = current->next->next;
        }
        
        // Separating both the linked lists
    
        Node* original = head;
        Node *copy  = head->next;
        Node* temp = copy;
        
        while(original!=NULL && copy!=NULL){
            original->next = original->next->next;
            copy->next = (copy->next!= NULL)?copy->next->next:copy->next;
            original = original->next;
            copy = copy->next;
        }
        return temp;
    }
};

// Merge Sort in Linked List

class Solution{
  public:
    //Function to sort the given linked list using Merge Sort.
    Node *middle(Node *head)
    {
        Node* slow=head;
        Node* fast=head->next;
        while(fast!=NULL && fast->next!=NULL)
        {
            slow=slow->next;
            fast=fast->next->next;
        }
        return slow;
    }
    Node *merge(Node* left,Node* right)
    {
        Node *curr=new Node(-1);
        Node *temp=curr;
        if(left==NULL)
        return right;
        if(right==NULL)
        return left;
        while(left!=NULL && right !=NULL)
        {
            if(left->data<right->data)
            {
                temp->next=left;
                temp=temp->next;
                left=left->next;
            }
            else
            {
                 temp->next=right;
                temp=temp->next;
                right=right->next;
            }
        }
        while(left!=NULL)
        {
             temp->next=left;
                temp=temp->next;
                left=left->next;
        }
        while(right!=NULL)
        {
             temp->next=right;
                temp=temp->next;
                right=right->next;
        }
        return curr->next;
    }
    Node* mergeSort(Node* head) {
        // your code here
        if(head==NULL || head->next==NULL)
        {
            return head;
        }
        Node *curr=head;
        Node *left=NULL;
        Node *right=NULL;
        Node* mid=middle(curr);
        left=head;
        right=mid->next;
        mid->next=NULL;
        left=mergeSort(left);
        right=mergeSort(right);
        Node *ans=merge(left,right);
        return ans;
    }
};

// Flatten a Linked List

void insert(Node *head,Node* val){
    Node* curr = head->bottom;
    Node* prev = head;
    while(prev){
        if(!curr or val->data < curr->data){
            prev->bottom = val;
            val->bottom = curr;
            return;
        }
        prev = curr;
        curr = curr->bottom;
    }
}
Node *flatten(Node *root)
{
    Node* head = root,*ans = root;
    root = root->next;
    while(root){
        Node* curr = root;
        while(curr){
            Node* next = curr->bottom;
            curr->bottom = nullptr;
            insert(head,curr);
            curr = next;
        }
        root = root->next;
    }
    return ans;
}

// Two Stacks

#include <bits/stdc++.h> 
class TwoStack {
public:
    int *arr;
    int top1;
    int top2;
    int size;
    // Initialize TwoStack.
    TwoStack(int s) {
        this->size=s;
        arr=new int[s];
        top1=-1;
        top2=s;
    }
    // Push in stack 1.
    void push1(int num) {
        if(top2-top1>1){
            top1++;
            arr[top1]=num;
        }
    }
    // Push in stack 2.
    void push2(int num) {
        if(top2-top1>1){
            top2--;
            arr[top2]=num;
        }
    }
    // Pop from stack 1 and return popped element.
    int pop1() {
        if(top1>=0){
            int ans=arr[top1];
            top1--;
            return ans;
        }
        else{
            return -1;
        }
    }
    // Pop from stack 2 and return popped element.
    int pop2() {
        if(top2<size){
            int ans=arr[top2];
            top2++;
            return ans;
        }
        else{
            return -1;
        }
    }
};

// Reverse a string using Stack

char* reverse(char *S, int len){
    stack<char> st;
    for(int i = 0;i<len;i++){
        st.push(S[i]);
    }
    int i = 0;
    while(!st.empty()){
        S[i++] = st.top();
        st.pop();
    }
    return S;
}
