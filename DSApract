// Reverse Array

class Solution {
public:
    int reverse(int x) {
        int ans=0;
        while(x!=0){
        int digit=x%10;
        if(ans>INT_MAX/10 || ans<INT_MIN/10){
            return 0;
        }
        ans=(ans*10)+digit;
        x=x/10;
        }
        return ans;
    }
};

// Complement of base 10 integer

class Solution {
public:
    int bitwiseComplement(int n) {
        int m=n;
        int mask=0;
        if(n==0){
            return 1;
        }
        while(m!=0){
            mask=(mask<<1)|1;
            m=m>>1;
        }
        int ans=(~n)&mask;
        return ans;
    }
};

// Power of Two

class Solution {
public:
    bool isPowerOfTwo(int n) {
        int ans=1;
        for(int i=0;i<=30;i++){
            if(ans==n){
                return true;
            }
            if(ans<INT_MAX/2){
            ans=ans*2;
            }
        }
        return false;
    }
};

// Unique number

int findUnique(int *arr, int size)
{
    int ans=0;
    for(int i=0;i<size;i++){
        ans=ans^arr[i];
    }
    return ans;
}

// Duplicate number

int findDuplicate(vector<int> &arr) 
{
    int ans=0;
    for(int i=0;i<arr.size();i++){
        ans=ans^arr[i];
    }
    for(int i=0;i<arr.size();i++){
        ans=ans^i;
    }
    return ans;
}

// Array Intersection

#include <bits/stdc++.h> 
vector<int> findArrayIntersection(vector<int> &arr1, int n, vector<int> &arr2, int m)
{
	int i=0,j=0;
	vector<int> ans;
	while(i<n && j<m){
		if(arr1[i]==arr2[j]){
			ans.push_back(arr1[i]);
			i++;
			j++;
		}
		else if(arr1[i]<arr2[j]){
			i++;
		}
		else{
			j++;
		}
	}
	return ans;
}

// Pair Sum

#include <bits/stdc++.h> 
#include <bits/stdc++.h> 
vector<vector<int>> pairSum(vector<int> &arr, int s){
   int n=arr.size();
   vector<vector<int>> ans;
   for(int i=0;i<n;i++){
      for(int j=i+1;j<n;j++){
         if(arr[i]+arr[j]==s){
            vector<int> temp;
            temp.push_back(min(arr[i],arr[j]));
            temp.push_back(max(arr[i],arr[j]));
            ans.push_back(temp);
         }
      }
   }
   sort(ans.begin(),ans.end());
   return ans;
}

// Triplet Sum

#include <bits/stdc++.h>
vector<vector<int>> findTriplets(vector<int> arr, int n, int K) {
  sort(arr.begin(), arr.end());
  set<vector<int>> s;
  vector<vector<int>> ans;
  for (int i = 0; i < n; ++i)
  {
    int j = i + 1;
    int k = n - 1;
    while (j < k)
    {
      int sum = arr[i] + arr[j] + arr[k];
      if (sum == K)
      {
        s.insert({arr[i], arr[j], arr[k]});
        j++;
        k--;
      }
      else if (sum < K)
      {
        j++;
      }
      else
      {
        k--;
      }
    }
  }
  for (auto x : s)
  {
    ans.push_back(x);
  }
  return ans;
}

// Sort 0,1 and 2

#include <bits/stdc++.h>

void swap(int &x,int &y){
   int temp=x;
   x=y;
   y=temp;
}

void sort012(int *arr, int n)
{
   int a0=0,b1=0,c2=n-1;
   while(b1<=c2){
      if(arr[b1]==0){
         swap(arr[a0],arr[b1]);
         a0++;
         b1++;
      }
      else if(arr[b1]==1){
         b1++;
      }
      else{
         swap(arr[b1],arr[c2]);
         c2--;
      }
   }
}

// Unique Number Of Occurences

class Solution {
public:
    bool uniqueOccurrences(vector<int>& arr) {
        int i = 0;
        sort(arr.begin(),arr.end());
        vector<int> ans;
        while (i < arr.size()){
            int count = 1;
            for (int j = i+1; j< arr.size(); j++){
                if (arr[i] == arr[j])
                    count++;
            }
            ans.push_back(count);
            i = i + count;
        }
        sort(ans.begin(),ans.end());
        for (int i = 0; i < ans.size() - 1; i++){
            if (ans[i] == ans [i+1])
                return false;
        }
        return true;
    }
};

// All Duplicates in an Array

class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> ans; 
        sort(nums.begin(),nums.end());
            for(int i=0 ; i<nums.size()-1 ; ){
                if(nums[i]==nums[i+1]){
                    ans.push_back(nums[i]);
                    i=i+2;
                }
                else{
                  i++;  
                } 
            }
        return ans;
    }
};

// Find Pivot Index

class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int sum1=0,sum2=0;
        for(int i=0;i<nums.size();i++){
            sum1+=nums[i];
        }
        for(int i=0;i<nums.size();i++){
            sum1-=nums[i];
            if(sum1==sum2){
                return i;
            }
            sum2+=nums[i];
        }
        return -1;
    }
};

// First and Last Occurence

#include <bits/stdc++.h> 

int FirstOccurence(vector<int>& arr, int n, int k){
    int i=0,j=n-1,mid=i+(j-i)/2;
    int ans=-1;
    while(i<=j){
        if(arr[mid]<k){
            i=mid+1;
        }
        else if(arr[mid]==k){
            ans=mid;
            j=mid-1;
        }
        else{
            j=mid-1;
        }
        mid=i+(j-i)/2;
    }
    return ans;
}

int LastOccurence(vector<int>& arr, int n, int k){
    int i=0,j=n-1,mid=i+(j-i)/2;
    int ans=-1;
    while(i<=j){
        if(arr[mid]<k){
            i=mid+1;
        }
        else if(arr[mid]==k){
            ans=mid;
            i=mid+1;
        }
        else{
            j=mid-1;
        }
        mid=i+(j-i)/2;
    }
    return ans;
}

pair<int, int> firstAndLastPosition(vector<int>& arr, int n, int k)
{
    pair<int,int> p;
    p.first=FirstOccurence(arr,n,k);
    p.second=LastOccurence(arr,n,k);
    return p;
}

// Peak Index in a Mountain Array

class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int n=arr.size();
        int i=0,j=n-1,mid=i+(j-i)/2;
        while(i<j){
            if(arr[mid]<arr[mid+1]){
                i=mid+1;
            }
            else{
                j=mid;
            }
            mid=i+(j-i)/2;
        }
        return i;
    }
};

// Search in Rotated Sorted Array

#include <bits/stdc++.h> 
int pivotIndex(vector<int> arr,int n){
   int start = 0;
   int end = n-1;
   int mid = start + (end-start)/2;
   
   while(start<end){
       if(arr[mid]>=arr[0]){
           start = mid+1;
       }
       else{
           end = mid;
       }
       mid = start + (end-start)/2;
   }
   return start;
}
int binarySearch(vector<int> arr,int start,int end,int key){
   int mid = start + (end-start)/2;
   
   while(start<=end){
       if(arr[mid]==key){
           return mid;
       }
       else if(arr[mid]>key){
           end = mid -1;
       }
       else{
           start = mid+1;
       }
       mid = start+(end-start)/2;
   }
   return -1;
}
int findPosition(vector<int>& arr, int n, int k)
{
   int pivot = pivotIndex(arr,n);
   if(k>=arr[pivot] && k<=arr[n-1]){
       return binarySearch(arr,pivot,n-1,k);
   }
   else{
       return binarySearch(arr,0,pivot-1,k);
   }
}

// Square root of an integer

#include <bits/stdc++.h> 

int sqrtN(long long int N)
{
   if(N < 2) return N;
   long long int s = 0, e = N;
   long long int mid = s + (e - s) / 2;
   long long ans = -1;
   while (s <= e)
   {
       if (mid  == (N/mid)) // same as mid*mid == N, to avoid range overlow
           return mid;
       else if (mid > (N/mid))
           e = mid - 1;
       else
       {
           ans = mid;
           s = mid + 1;
       }
       mid = s + (e - s) / 2;
   }
   return ans;
}

// Allocate Books

#include <bits/stdc++.h>  

bool isPossible(int n, int m, vector<int> time,long long int mid){

   long long int studentCount=1 , chapterSum=0;     
   for(int i=0;i<m;i++){   
      if(chapterSum + time[i] <= mid){  
         chapterSum+= time[i];
       } 
      else  {
           studentCount++;  
           if(studentCount > n || time[i] > mid){
                return false;
           }        
           chapterSum = time[i];
       } 
      if(studentCount>n){  
         return false;  
     }
   }
   return true; 
}
 long long ayushGivesNinjatest(int n, int m, vector<int> time)  {
  
  long long int start=0, sum=0;   
  for(int i=0;i<m;i++){
       sum=sum+time[i];    
  }
  long long int end=sum, ans=-1, mid=start+(end-start)/2;
      while(start<=end){ 
      if(isPossible(n,m,time,mid)){
           ans=mid;
           end=mid-1;
       }
       else {
           start=mid+1;   
        }
       mid=start+(end-start)/2;
   }   
   return ans; 
}

// Aggressive Cows

bool isPossible(vector<int> &stalls, int k, int mid, int n) {
    
    int cowCount = 1;
    int lastPos = stalls[0];
    
    for(int i=0; i<n; i++ ){
        
        if(stalls[i]-lastPos >= mid){
            cowCount++;
            if(cowCount==k)
            {
                return true;
            }
            lastPos = stalls[i];
        }
    }
    return false;
}

int aggressiveCows(vector<int> &stalls, int k)
{
    sort(stalls.begin(), stalls.end());
   	int s = 0;
    int n = stalls.size();
    int e=stalls[n-1];
    int ans = -1;
    int mid = s + (e-s)/2;
    
    while(s<=e) {
        if(isPossible(stalls, k, mid, n)) {
            ans = mid;
            s = mid + 1;
        }
        else
        {
            e = mid - 1;
        }
        mid = s + (e-s)/2;
    }
    return ans;
}

// Painter's Partiton Problem

bool isPossible(vector<int> &boards, int n, int k, int mid) {
  int PainterCount = 1;
  int blockCount = 0;
  for (int i = 0; i < n; ++i) {
    if (blockCount + boards[i] <= mid) {
      blockCount += boards[i];
    } 
    else {
      PainterCount++;
      if (PainterCount > k || boards[i] > mid) {
        return false;
      }
      blockCount = boards[i];
    }
  }
  return true;
}
int findLargestMinDistance(vector<int> &boards, int k) {
  int n = boards.size();
  int s = 0;
  int sum = 0;
  for (int i = 0; i < n; ++i) {
    sum += boards[i];
  }
  int e = sum;
  int ans = -1;
  int mid = s + (e - s) / 2;
  while (s <= e) {
    if (isPossible(boards, n, k, mid)) {
      ans = mid;
      // Left wale bhaag jaenge
      e = mid - 1;
    } 
    else {
      s = mid + 1;
    }
    mid = s + (e - s) / 2;
  }
  return ans;
}

// Reverse an array

#include <bits/stdc++.h> 
void reverseArray(vector<int> &arr , int m)
{
	int n=arr.size();
	int start=m+1,end=n-1;
	while(start<end){
		int temp=arr[start];
		arr[start]=arr[end];
		arr[end]=temp;
		start++;
		end--;
	}
}

// Merge two sorted arrays 

class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        while(nums1.size()>m){
            nums1.pop_back();
        }
        for(int j=0; j<n; j++){
            nums1.push_back(nums2[j]);
        }
        sort(nums1.begin(), nums1.end());
    }
};

// Move zeroes to end

class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int i=0;
        for(int j=0;j<nums.size();j++){
            if(nums[j]!=0){
                swap(nums[j],nums[i]);
                i++;
            }
        }
    }
};

// Rotate the array by k

class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k %= n;
        reverse(nums.begin(), nums.end());
        reverse(nums.begin(), nums.begin()+k);
        reverse(nums.begin()+k, nums.end());
        return;
    }
};

// Check if Array is sorted and rotated

class Solution {
public:
    bool check(vector<int>& nums) {
        int count = 0;
        for(int i=0;i<nums.size()-1;i++)
        {
            if(nums[i]>nums[i+1] )
            count++;
        }
        if(nums[nums.size()-1] > nums[0]){
            count++;
        }
        if(count <= 1){
            return true;
        }
        else{
            return false;
        }
    }
};

// Sum of two arrays

#include <bits/stdc++.h> 

vector<int> reverse(vector<int> v){
	int s=0,e=v.size()-1;
	while(s<e){
		swap(v[s++],v[e--]);
	}
	return v;
}
vector<int> findArraySum(vector<int>&a, int n, vector<int>&b, int m) {
		int i=n-1,j=m-1;
		vector<int> ans;
		int carry=0;
		while(i>=0 && j>=0){
			int value1=a[i];
			int value2=b[j];
			int sum=value1+value2+carry;
			carry=sum/10;
			sum=sum%10;
			ans.push_back(sum);
			i--;
			j--;
		}
		while(i>=0){
			int sum=a[i]+carry;
			carry=sum/10;
			sum=sum%10;
			ans.push_back(sum);
			i--;
		}
		while(j>=0){
			int sum=b[j]+carry;
			carry=sum/10;
			int value=sum%10;
			ans.push_back(value);
			j--;
		}
		while(carry!=0){
			int sum=carry;
			carry=sum/10;
			sum=sum%10;
			ans.push_back(sum);
		}
		return reverse(ans);		
}

// Check if the string is a palindrome

#include <bits/stdc++.h> 

string toLowerCase(string s){
    int i=0,j=s.size()-1;
    string str="";

    while(i<=j){
        if((s[i]>='a' && s[i]<='z') || (s[i]>='0' && s[i]<='9')){
            str+=s[i++];
        }
        else if((s[i]>='A' && s[i]<='Z')){
            str+=s[i++]-'A'+'a';
        }
        else{
            i++;
        }
    }
    return str;
}

bool checkPalindrome(string s)
{
    string str=toLowerCase(s);
    int n=str.size();
    int i=0,j=n-1;
    bool ans=true;
    while(i<=j){
        if(str[i]==str[j]){
            i++;
            j--;
        }
        else{
            ans=false;
            break;
        }
    }
    return ans;
}

// Valid palindrome

class Solution {
public:
    bool isPalindrome(string s) {
        string str="";
        for(int i=0;i<s.size();i++){
            if(isalnum(s[i])) 
                str+=tolower(s[i]);
        }
        string y=str;
        reverse(str.begin(),str.end());
        int i=0,j=0;
        while(i<str.size() && j<y.size()){
            if(str[i]!=y[j]){
                return false;
            }
            else{
                i++;
                j++;
            }
        }
        return true;
    }
};

// Reverse words in a string II

class Solution {
public:
    void reverseWords(vector<char>& s) {
        int i = 0, N = s.size();
        while (i < N) {
            int start = i;
            while (i < N && s[i] != ' ') ++i;
            reverse(begin(s) + start, begin(s) + i);
            ++i;
        }
        reverse(begin(s), end(s));
    }
};

// Maximum occuring character

//{ Driver Code Starts
#include<bits/stdc++.h>
using namespace std;


// } Driver Code Ends


class Solution
{
    public:
    char getMaxOccuringChar(string str)
    {
        int arr[26] = {0};
        for (int i = 0; i < str.length(); i++)
        {
            char ch = str[i];
            int number = 0;
            number = ch - 'a';
            arr[number]++;
        }
        int maxi = -1, ans = 0;
        for (int i = 0; i < 26; i++)
        {
            if (maxi < arr[i])
            {
                ans = i;
                maxi = arr[i];
            }
        }
        return 'a' + ans;
    }

};

//{ Driver Code Starts.

int main()
{
   
    int t;
    cin >> t;
    while(t--)
    {
        string str;
        cin >> str;
    	Solution obj;
        cout<< obj.getMaxOccuringChar(str)<<endl;
    }
}
// } Driver Code Ends

// Remove all occurrences of substring

#include <bits/stdc++.h> 
string replaceSpaces(string &str){
	string ch="@40";
	int i=0;
	while(i<=str.length()){
		if(str[i]==' '){
			str.replace(i,1,ch);
		}
		i++;
	}
	return str;
}

// Remove all adjacent duplicates

class Solution {
public:
    string removeDuplicates(string s) {
        string ans = "";
        for(int i = 0; i < s.length(); i++){
            if(ans == ""){
                ans.push_back(s[i]);
            }
            else if(ans.back()==s[i]){
                ans.pop_back();
            }
            else{
                ans.push_back(s[i]);
            }
        }
        return ans;
    }
};


// String Compression

class Solution {
public:
    int compress(vector<char>& chars) {
        int n=chars.size();
        int i=0,j=0;
        while(j<n){
            int c=0;
            char current_char=chars[j];
            while(j<n && chars[j]==current_char){
                c++;
                j++;
            }
            chars[i++]=current_char;
            if(c>1){
                string count=to_string(c);
                for(auto p:count){
                    chars[i++]=p;
                }
            }

        }
         return i;
    }
};

// Permutation in Strings

class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        int s1_len=s1.size();
        int s2_len=s2.size();
        if(s1_len>s2_len)
        {
            return false;
        }
        sort(s1.begin(),s1.end());
        for(int i=0;i<=(s2_len-s1_len);i++)
        {
            string p=s2.substr(i,s1_len);
            sort(p.begin(),p.end());
            if(p==s1)
            {
                return true;
            }
        }
        return false;
    }
};

// Remove adjacent Duplicates 

class Solution {
public:
    string removeDuplicates(string s) {
        string ans = "";
        for(int i = 0; i < s.length(); i++){
            if(ans == ""){
                ans.push_back(s[i]);
            }
            else if(ans.back()==s[i]){
                ans.pop_back();
            }
            else{
                ans.push_back(s[i]);
            }
        }
        return ans;
    }
};

// Linear Search

#include<iostream>
using namespace std;
int main(){
    int n;
    cin>>n;
    int arr[n];
    for (int i = 0; i < n; i++)
    {
        cin>>arr[i];
    }
    int search;
    cin>>search;
    for (int i = 0; i < n; i++)
    {
        if(arr[i]==search){
            cout<<search<<" element is found"<<" at "<< i <<" index"<<endl;
        }
    }
    return 0;
}

// Row-wise sum

#include<iostream>
using namespace std;
int main(){
    int n,m;
    cin>>n>>m;
    int arr[n][m];
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin>>arr[i][j];
        }
    }
    for (int i = 0; i < n; i++)
    {
        int sum=0;
        for (int j = 0; j < m; j++)
        {
            sum+=arr[i][j];
        } 
        cout<<sum<<" ";
    }
    cout<<endl;
    return 0;
}

// Column-wise sum

#include<iostream>
using namespace std;
int main(){
    int n,m;
    cin>>n>>m;
    int arr[n][m];
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin>>arr[i][j];
        }
    }
    for (int j = 0; j < m; j++)
    {
        int sum=0;
        for (int i = 0; i < n; i++)
        {
            sum+=arr[i][j];
        } 
        cout<<sum<<" ";
    }
    cout<<endl;
    return 0;
}

// Largest Row Sum

#include<iostream>
#include<climits>
using namespace std;
int main(){
    int n,m;
    cin>>n>>m;
    int arr[n][m];
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin>>arr[i][j];
        }
    }
    int max=INT_MIN;
    int RowIndex=-1;
    for (int i = 0; i < n; i++)
    {
        int sum=0;
        for (int j = 0; j < m; j++)
        {
            sum+=arr[i][j];
        }
        if(sum>max){
            max=sum;
            RowIndex=i;
        }
    }
    cout<<max<<endl;
    cout<<RowIndex<<endl;
    return 0;
}

// Wave Print

#include <bits/stdc++.h> 
vector<int> wavePrint(vector<vector<int>> arr, int nRows, int mCols)
{
    vector<int> ans;
    for(int j=0;j<mCols;j++){
        if(j&1){
            for(int i=nRows-1;i>=0;i--)
                ans.push_back(arr[i][j]);
        }
        else{
            for(int i=0;i<nRows;i++)
                ans.push_back(arr[i][j]);
        }
    }
    return ans;
}

// Spiral Matrix

class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> ans;
        int row=matrix.size();
        int col=matrix[0].size();
        int count=0;
        int total=row*col;
        // Indexes
        int startingRow=0;
        int startingCol=0;
        int endingRow=row-1;
        int endingCol=col-1;
        while(count<total){
            for (int index = startingCol; count<total && index <= endingCol ; index++)
            {
                ans.push_back(matrix[startingRow][index]);
                count++;
            }
            startingRow++;
            for (int index = startingRow; count<total && index <= endingRow ; index++)
            {
                ans.push_back(matrix[index][endingCol]);
                count++;
            }
            endingCol--;
            for (int index = endingCol; count<total && index >= startingCol ; index--)
            {
                ans.push_back(matrix[endingRow][index]);
                count++;
            }
            endingRow--;
            for (int index = endingRow; count<total && index >= startingRow ; index--)
            {
                ans.push_back(matrix[index][startingCol]);
                count++;
            }
            startingCol++;
        }
        return ans;
    }
};

// Rotate Image

class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n; i++) {
            for (int j = i+1; j < n; j++) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        for(int k=0;k<n;k++){
            reverse(matrix[k].begin(), matrix[k].end());
        }
    }
};

// Search in a 2D Matrix

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row=matrix.size();
        int col=matrix[0].size();
        int start=0,end=(row*col)-1,mid=start+(end-start)/2;
        while(start<=end){
            int element=matrix[mid/col][mid%col];
            if(element<target){
                start=mid+1;
            }
            else if(element==target){
                return 1;
            }
            else{
                end=mid-1;
            }
            mid=start+(end-start)/2;
        }
        return 0;
    }
};

// Search in a 2D Matrix II

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row=matrix.size();
        int col=matrix[0].size();
        
        int RowIndex=0;
        int ColIndex=col-1;
        
        while(RowIndex<row && ColIndex>=0){
            int element=matrix[RowIndex][ColIndex];
            if(element<target){
                RowIndex++;
            }
            else if(element==target){
                return 1;
            }
            else{
                ColIndex--;
            }
        }
        return 0;
    }
};

// Count prime(Sieve of Eratosthenes)

class Solution {
public:
    int countPrimes(int n) {
        int count=0;
        vector<bool> prime(n+1,true);
        
        prime[0]=prime[1]=false;
        
        for(int i=2;i<n;i++){
            if(prime[i]){
               count++; 
            }
            for(int j=2*i;j<n;j=j+i){
                prime[j]=0;
            }
        }
        return count;
    }
};

// Segmented Sieve

class Solution{
public:
    bool isPrime(long long int n)
    {
        if(n<=1){
           return false;
        }
        for(int i=2 ; i*i<=n ; i++){
            if(n%i == 0){
               return false ;
            }
        }
        return true ;
    }
    long long primeProduct(long long L, long long R){
        long long int ans=1;
        int count=0;
        long long int num=pow(10,9) + 7; 
        for(int i=L; i<=R; i++){
            if(isPrime(i)){
                count++;
                ans=(ans*i)%num;
            }
        }
       if(count==0){
           return 1;
       }
       return ans;
    }
};

// GCD



// LCM



// Modular Exponentiation

