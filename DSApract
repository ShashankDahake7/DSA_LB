// Reverse Array

class Solution {
public:
    int reverse(int x) {
        int ans=0;
        while(x!=0){
        int digit=x%10;
        if(ans>INT_MAX/10 || ans<INT_MIN/10){
            return 0;
        }
        ans=(ans*10)+digit;
        x=x/10;
        }
        return ans;
    }
};

// Complement of base 10 integer

class Solution {
public:
    int bitwiseComplement(int n) {
        int m=n;
        int mask=0;
        if(n==0){
            return 1;
        }
        while(m!=0){
            mask=(mask<<1)|1;
            m=m>>1;
        }
        int ans=(~n)&mask;
        return ans;
    }
};

// Power of Two

class Solution {
public:
    bool isPowerOfTwo(int n) {
        int ans=1;
        for(int i=0;i<=30;i++){
            if(ans==n){
                return true;
            }
            if(ans<INT_MAX/2){
            ans=ans*2;
            }
        }
        return false;
    }
};

// Unique number

int findUnique(int *arr, int size)
{
    int ans=0;
    for(int i=0;i<size;i++){
        ans=ans^arr[i];
    }
    return ans;
}

// Duplicate number

int findDuplicate(vector<int> &arr) 
{
    int ans=0;
    for(int i=0;i<arr.size();i++){
        ans=ans^arr[i];
    }
    for(int i=0;i<arr.size();i++){
        ans=ans^i;
    }
    return ans;
}

// Array Intersection

#include <bits/stdc++.h> 
vector<int> findArrayIntersection(vector<int> &arr1, int n, vector<int> &arr2, int m)
{
	int i=0,j=0;
	vector<int> ans;
	while(i<n && j<m){
		if(arr1[i]==arr2[j]){
			ans.push_back(arr1[i]);
			i++;
			j++;
		}
		else if(arr1[i]<arr2[j]){
			i++;
		}
		else{
			j++;
		}
	}
	return ans;
}

// Pair Sum

#include <bits/stdc++.h> 
#include <bits/stdc++.h> 
vector<vector<int>> pairSum(vector<int> &arr, int s){
   int n=arr.size();
   vector<vector<int>> ans;
   for(int i=0;i<n;i++){
      for(int j=i+1;j<n;j++){
         if(arr[i]+arr[j]==s){
            vector<int> temp;
            temp.push_back(min(arr[i],arr[j]));
            temp.push_back(max(arr[i],arr[j]));
            ans.push_back(temp);
         }
      }
   }
   sort(ans.begin(),ans.end());
   return ans;
}

// Triplet Sum

#include <bits/stdc++.h>
vector<vector<int>> findTriplets(vector<int> arr, int n, int K) {
  sort(arr.begin(), arr.end());
  set<vector<int>> s;
  vector<vector<int>> ans;
  for (int i = 0; i < n; ++i)
  {
    int j = i + 1;
    int k = n - 1;
    while (j < k)
    {
      int sum = arr[i] + arr[j] + arr[k];
      if (sum == K)
      {
        s.insert({arr[i], arr[j], arr[k]});
        j++;
        k--;
      }
      else if (sum < K)
      {
        j++;
      }
      else
      {
        k--;
      }
    }
  }
  for (auto x : s)
  {
    ans.push_back(x);
  }
  return ans;
}

// Sort 0,1 and 2

#include <bits/stdc++.h>

void swap(int &x,int &y){
   int temp=x;
   x=y;
   y=temp;
}

void sort012(int *arr, int n)
{
   int a0=0,b1=0,c2=n-1;
   while(b1<=c2){
      if(arr[b1]==0){
         swap(arr[a0],arr[b1]);
         a0++;
         b1++;
      }
      else if(arr[b1]==1){
         b1++;
      }
      else{
         swap(arr[b1],arr[c2]);
         c2--;
      }
   }
}

// Unique Number Of Occurences

class Solution {
public:
    bool uniqueOccurrences(vector<int>& arr) {
        int i = 0;
        sort(arr.begin(),arr.end());
        vector<int> ans;
        while (i < arr.size()){
            int count = 1;
            for (int j = i+1; j< arr.size(); j++){
                if (arr[i] == arr[j])
                    count++;
            }
            ans.push_back(count);
            i = i + count;
        }
        sort(ans.begin(),ans.end());
        for (int i = 0; i < ans.size() - 1; i++){
            if (ans[i] == ans [i+1])
                return false;
        }
        return true;
    }
};

// All Duplicates in an Array

class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> ans; 
        sort(nums.begin(),nums.end());
            for(int i=0 ; i<nums.size()-1 ; ){
                if(nums[i]==nums[i+1]){
                    ans.push_back(nums[i]);
                    i=i+2;
                }
                else{
                  i++;  
                } 
            }
        return ans;
    }
};

// Find Pivot Index

class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int sum1=0,sum2=0;
        for(int i=0;i<nums.size();i++){
            sum1+=nums[i];
        }
        for(int i=0;i<nums.size();i++){
            sum1-=nums[i];
            if(sum1==sum2){
                return i;
            }
            sum2+=nums[i];
        }
        return -1;
    }
};

// First and Last Occurence

#include <bits/stdc++.h> 

int FirstOccurence(vector<int>& arr, int n, int k){
    int i=0,j=n-1,mid=i+(j-i)/2;
    int ans=-1;
    while(i<=j){
        if(arr[mid]<k){
            i=mid+1;
        }
        else if(arr[mid]==k){
            ans=mid;
            j=mid-1;
        }
        else{
            j=mid-1;
        }
        mid=i+(j-i)/2;
    }
    return ans;
}

int LastOccurence(vector<int>& arr, int n, int k){
    int i=0,j=n-1,mid=i+(j-i)/2;
    int ans=-1;
    while(i<=j){
        if(arr[mid]<k){
            i=mid+1;
        }
        else if(arr[mid]==k){
            ans=mid;
            i=mid+1;
        }
        else{
            j=mid-1;
        }
        mid=i+(j-i)/2;
    }
    return ans;
}

pair<int, int> firstAndLastPosition(vector<int>& arr, int n, int k)
{
    pair<int,int> p;
    p.first=FirstOccurence(arr,n,k);
    p.second=LastOccurence(arr,n,k);
    return p;
}

// Peak Index in a Mountain Array

class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int n=arr.size();
        int i=0,j=n-1,mid=i+(j-i)/2;
        while(i<j){
            if(arr[mid]<arr[mid+1]){
                i=mid+1;
            }
            else{
                j=mid;
            }
            mid=i+(j-i)/2;
        }
        return i;
    }
};

// Search in Rotated Sorted Array

#include <bits/stdc++.h> 
int pivotIndex(vector<int> arr,int n){
   int start = 0;
   int end = n-1;
   int mid = start + (end-start)/2;
   
   while(start<end){
       if(arr[mid]>=arr[0]){
           start = mid+1;
       }
       else{
           end = mid;
       }
       mid = start + (end-start)/2;
   }
   return start;
}
int binarySearch(vector<int> arr,int start,int end,int key){
   int mid = start + (end-start)/2;
   
   while(start<=end){
       if(arr[mid]==key){
           return mid;
       }
       else if(arr[mid]>key){
           end = mid -1;
       }
       else{
           start = mid+1;
       }
       mid = start+(end-start)/2;
   }
   return -1;
}
int findPosition(vector<int>& arr, int n, int k)
{
   int pivot = pivotIndex(arr,n);
   if(k>=arr[pivot] && k<=arr[n-1]){
       return binarySearch(arr,pivot,n-1,k);
   }
   else{
       return binarySearch(arr,0,pivot-1,k);
   }
}

// Square root of an integer

#include <bits/stdc++.h> 

int sqrtN(long long int N)
{
   if(N < 2) return N;
   long long int s = 0, e = N;
   long long int mid = s + (e - s) / 2;
   long long ans = -1;
   while (s <= e)
   {
       if (mid  == (N/mid)) // same as mid*mid == N, to avoid range overlow
           return mid;
       else if (mid > (N/mid))
           e = mid - 1;
       else
       {
           ans = mid;
           s = mid + 1;
       }
       mid = s + (e - s) / 2;
   }
   return ans;
}

// Allocate Books

#include <bits/stdc++.h>  

bool isPossible(int n, int m, vector<int> time,long long int mid){

   long long int studentCount=1 , chapterSum=0;     
   for(int i=0;i<m;i++){   
      if(chapterSum + time[i] <= mid){  
         chapterSum+= time[i];
       } 
      else  {
           studentCount++;  
           if(studentCount > n || time[i] > mid){
                return false;
           }        
           chapterSum = time[i];
       } 
      if(studentCount>n){  
         return false;  
     }
   }
   return true; 
}
 long long ayushGivesNinjatest(int n, int m, vector<int> time)  {
  
  long long int start=0, sum=0;   
  for(int i=0;i<m;i++){
       sum=sum+time[i];    
  }
  long long int end=sum, ans=-1, mid=start+(end-start)/2;
      while(start<=end){ 
      if(isPossible(n,m,time,mid)){
           ans=mid;
           end=mid-1;
       }
       else {
           start=mid+1;   
        }
       mid=start+(end-start)/2;
   }   
   return ans; 
}

// Aggressive Cows

bool isPossible(vector<int> &stalls, int k, int mid, int n) {
    
    int cowCount = 1;
    int lastPos = stalls[0];
    
    for(int i=0; i<n; i++ ){
        
        if(stalls[i]-lastPos >= mid){
            cowCount++;
            if(cowCount==k)
            {
                return true;
            }
            lastPos = stalls[i];
        }
    }
    return false;
}

int aggressiveCows(vector<int> &stalls, int k)
{
    sort(stalls.begin(), stalls.end());
   	int s = 0;
    int n = stalls.size();
    int e=stalls[n-1];
    int ans = -1;
    int mid = s + (e-s)/2;
    
    while(s<=e) {
        if(isPossible(stalls, k, mid, n)) {
            ans = mid;
            s = mid + 1;
        }
        else
        {
            e = mid - 1;
        }
        mid = s + (e-s)/2;
    }
    return ans;
}

// Painter's Partiton Problem

bool isPossible(vector<int> &boards, int n, int k, int mid) {
  int PainterCount = 1;
  int blockCount = 0;
  for (int i = 0; i < n; ++i) {
    if (blockCount + boards[i] <= mid) {
      blockCount += boards[i];
    } 
    else {
      PainterCount++;
      if (PainterCount > k || boards[i] > mid) {
        return false;
      }
      blockCount = boards[i];
    }
  }
  return true;
}
int findLargestMinDistance(vector<int> &boards, int k) {
  int n = boards.size();
  int s = 0;
  int sum = 0;
  for (int i = 0; i < n; ++i) {
    sum += boards[i];
  }
  int e = sum;
  int ans = -1;
  int mid = s + (e - s) / 2;
  while (s <= e) {
    if (isPossible(boards, n, k, mid)) {
      ans = mid;
      // Left wale bhaag jaenge
      e = mid - 1;
    } 
    else {
      s = mid + 1;
    }
    mid = s + (e - s) / 2;
  }
  return ans;
}

// Reverse an array

#include <bits/stdc++.h> 
void reverseArray(vector<int> &arr , int m)
{
	int n=arr.size();
	int start=m+1,end=n-1;
	while(start<end){
		int temp=arr[start];
		arr[start]=arr[end];
		arr[end]=temp;
		start++;
		end--;
	}
}

// Merge two sorted arrays 

class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        while(nums1.size()>m){
            nums1.pop_back();
        }
        for(int j=0; j<n; j++){
            nums1.push_back(nums2[j]);
        }
        sort(nums1.begin(), nums1.end());
    }
};

// Move zeroes to end

class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int i=0;
        for(int j=0;j<nums.size();j++){
            if(nums[j]!=0){
                swap(nums[j],nums[i]);
                i++;
            }
        }
    }
};

// Rotate the array by k

class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k %= n;
        reverse(nums.begin(), nums.end());
        reverse(nums.begin(), nums.begin()+k);
        reverse(nums.begin()+k, nums.end());
        return;
    }
};

// Check if Array is sorted and rotated

class Solution {
public:
    bool check(vector<int>& nums) {
        int count = 0;
        for(int i=0;i<nums.size()-1;i++)
        {
            if(nums[i]>nums[i+1] )
            count++;
        }
        if(nums[nums.size()-1] > nums[0]){
            count++;
        }
        if(count <= 1){
            return true;
        }
        else{
            return false;
        }
    }
};

// Sum of two arrays

#include <bits/stdc++.h> 

vector<int> reverse(vector<int> v){
	int s=0,e=v.size()-1;
	while(s<e){
		swap(v[s++],v[e--]);
	}
	return v;
}
vector<int> findArraySum(vector<int>&a, int n, vector<int>&b, int m) {
		int i=n-1,j=m-1;
		vector<int> ans;
		int carry=0;
		while(i>=0 && j>=0){
			int value1=a[i];
			int value2=b[j];
			int sum=value1+value2+carry;
			carry=sum/10;
			sum=sum%10;
			ans.push_back(sum);
			i--;
			j--;
		}
		while(i>=0){
			int sum=a[i]+carry;
			carry=sum/10;
			sum=sum%10;
			ans.push_back(sum);
			i--;
		}
		while(j>=0){
			int sum=b[j]+carry;
			carry=sum/10;
			int value=sum%10;
			ans.push_back(value);
			j--;
		}
		while(carry!=0){
			int sum=carry;
			carry=sum/10;
			sum=sum%10;
			ans.push_back(sum);
		}
		return reverse(ans);		
}

// Check if the string is a palindrome

#include <bits/stdc++.h> 

string toLowerCase(string s){
    int i=0,j=s.size()-1;
    string str="";

    while(i<=j){
        if((s[i]>='a' && s[i]<='z') || (s[i]>='0' && s[i]<='9')){
            str+=s[i++];
        }
        else if((s[i]>='A' && s[i]<='Z')){
            str+=s[i++]-'A'+'a';
        }
        else{
            i++;
        }
    }
    return str;
}

bool checkPalindrome(string s)
{
    string str=toLowerCase(s);
    int n=str.size();
    int i=0,j=n-1;
    bool ans=true;
    while(i<=j){
        if(str[i]==str[j]){
            i++;
            j--;
        }
        else{
            ans=false;
            break;
        }
    }
    return ans;
}

// Valid palindrome

class Solution {
public:
    bool isPalindrome(string s) {
        string str="";
        for(int i=0;i<s.size();i++){
            if(isalnum(s[i])) 
                str+=tolower(s[i]);
        }
        string y=str;
        reverse(str.begin(),str.end());
        int i=0,j=0;
        while(i<str.size() && j<y.size()){
            if(str[i]!=y[j]){
                return false;
            }
            else{
                i++;
                j++;
            }
        }
        return true;
    }
};

// Reverse words in a string II

class Solution {
public:
    void reverseWords(vector<char>& s) {
        int i = 0, N = s.size();
        while (i < N) {
            int start = i;
            while (i < N && s[i] != ' ') ++i;
            reverse(begin(s) + start, begin(s) + i);
            ++i;
        }
        reverse(begin(s), end(s));
    }
};

// Maximum occuring character

//{ Driver Code Starts
#include<bits/stdc++.h>
using namespace std;


// } Driver Code Ends


class Solution
{
    public:
    char getMaxOccuringChar(string str)
    {
        int arr[26] = {0};
        for (int i = 0; i < str.length(); i++)
        {
            char ch = str[i];
            int number = 0;
            number = ch - 'a';
            arr[number]++;
        }
        int maxi = -1, ans = 0;
        for (int i = 0; i < 26; i++)
        {
            if (maxi < arr[i])
            {
                ans = i;
                maxi = arr[i];
            }
        }
        return 'a' + ans;
    }

};

//{ Driver Code Starts.

int main()
{
   
    int t;
    cin >> t;
    while(t--)
    {
        string str;
        cin >> str;
    	Solution obj;
        cout<< obj.getMaxOccuringChar(str)<<endl;
    }
}
// } Driver Code Ends

// Remove all occurrences of substring

#include <bits/stdc++.h> 
string replaceSpaces(string &str){
	string ch="@40";
	int i=0;
	while(i<=str.length()){
		if(str[i]==' '){
			str.replace(i,1,ch);
		}
		i++;
	}
	return str;
}

// Remove all adjacent duplicates

class Solution {
public:
    string removeDuplicates(string s) {
        string ans = "";
        for(int i = 0; i < s.length(); i++){
            if(ans == ""){
                ans.push_back(s[i]);
            }
            else if(ans.back()==s[i]){
                ans.pop_back();
            }
            else{
                ans.push_back(s[i]);
            }
        }
        return ans;
    }
};


// String Compression

class Solution {
public:
    int compress(vector<char>& chars) {
        int n=chars.size();
        int i=0,j=0;
        while(j<n){
            int c=0;
            char current_char=chars[j];
            while(j<n && chars[j]==current_char){
                c++;
                j++;
            }
            chars[i++]=current_char;
            if(c>1){
                string count=to_string(c);
                for(auto p:count){
                    chars[i++]=p;
                }
            }

        }
         return i;
    }
};

// Permutation in Strings

class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        int s1_len=s1.size();
        int s2_len=s2.size();
        if(s1_len>s2_len)
        {
            return false;
        }
        sort(s1.begin(),s1.end());
        for(int i=0;i<=(s2_len-s1_len);i++)
        {
            string p=s2.substr(i,s1_len);
            sort(p.begin(),p.end());
            if(p==s1)
            {
                return true;
            }
        }
        return false;
    }
};

// Remove adjacent Duplicates 

class Solution {
public:
    string removeDuplicates(string s) {
        string ans = "";
        for(int i = 0; i < s.length(); i++){
            if(ans == ""){
                ans.push_back(s[i]);
            }
            else if(ans.back()==s[i]){
                ans.pop_back();
            }
            else{
                ans.push_back(s[i]);
            }
        }
        return ans;
    }
};

// Linear Search

#include<iostream>
using namespace std;
int main(){
    int n;
    cin>>n;
    int arr[n];
    for (int i = 0; i < n; i++)
    {
        cin>>arr[i];
    }
    int search;
    cin>>search;
    for (int i = 0; i < n; i++)
    {
        if(arr[i]==search){
            cout<<search<<" element is found"<<" at "<< i <<" index"<<endl;
        }
    }
    return 0;
}

// Row-wise sum

#include<iostream>
using namespace std;
int main(){
    int n,m;
    cin>>n>>m;
    int arr[n][m];
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin>>arr[i][j];
        }
    }
    for (int i = 0; i < n; i++)
    {
        int sum=0;
        for (int j = 0; j < m; j++)
        {
            sum+=arr[i][j];
        } 
        cout<<sum<<" ";
    }
    cout<<endl;
    return 0;
}

// Column-wise sum

#include<iostream>
using namespace std;
int main(){
    int n,m;
    cin>>n>>m;
    int arr[n][m];
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin>>arr[i][j];
        }
    }
    for (int j = 0; j < m; j++)
    {
        int sum=0;
        for (int i = 0; i < n; i++)
        {
            sum+=arr[i][j];
        } 
        cout<<sum<<" ";
    }
    cout<<endl;
    return 0;
}

// Largest Row Sum

#include<iostream>
#include<climits>
using namespace std;
int main(){
    int n,m;
    cin>>n>>m;
    int arr[n][m];
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin>>arr[i][j];
        }
    }
    int max=INT_MIN;
    int RowIndex=-1;
    for (int i = 0; i < n; i++)
    {
        int sum=0;
        for (int j = 0; j < m; j++)
        {
            sum+=arr[i][j];
        }
        if(sum>max){
            max=sum;
            RowIndex=i;
        }
    }
    cout<<max<<endl;
    cout<<RowIndex<<endl;
    return 0;
}

// Wave Print

#include <bits/stdc++.h> 
vector<int> wavePrint(vector<vector<int>> arr, int nRows, int mCols)
{
    vector<int> ans;
    for(int j=0;j<mCols;j++){
        if(j&1){
            for(int i=nRows-1;i>=0;i--)
                ans.push_back(arr[i][j]);
        }
        else{
            for(int i=0;i<nRows;i++)
                ans.push_back(arr[i][j]);
        }
    }
    return ans;
}

// Spiral Matrix

class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> ans;
        int row=matrix.size();
        int col=matrix[0].size();
        int count=0;
        int total=row*col;
        // Indexes
        int startingRow=0;
        int startingCol=0;
        int endingRow=row-1;
        int endingCol=col-1;
        while(count<total){
            for (int index = startingCol; count<total && index <= endingCol ; index++)
            {
                ans.push_back(matrix[startingRow][index]);
                count++;
            }
            startingRow++;
            for (int index = startingRow; count<total && index <= endingRow ; index++)
            {
                ans.push_back(matrix[index][endingCol]);
                count++;
            }
            endingCol--;
            for (int index = endingCol; count<total && index >= startingCol ; index--)
            {
                ans.push_back(matrix[endingRow][index]);
                count++;
            }
            endingRow--;
            for (int index = endingRow; count<total && index >= startingRow ; index--)
            {
                ans.push_back(matrix[index][startingCol]);
                count++;
            }
            startingCol++;
        }
        return ans;
    }
};

// Rotate Image

class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n; i++) {
            for (int j = i+1; j < n; j++) {
                swap(matrix[i][j], matrix[j][i]);
            }
        }
        for(int k=0;k<n;k++){
            reverse(matrix[k].begin(), matrix[k].end());
        }
    }
};

// Search in a 2D Matrix

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row=matrix.size();
        int col=matrix[0].size();
        int start=0,end=(row*col)-1,mid=start+(end-start)/2;
        while(start<=end){
            int element=matrix[mid/col][mid%col];
            if(element<target){
                start=mid+1;
            }
            else if(element==target){
                return 1;
            }
            else{
                end=mid-1;
            }
            mid=start+(end-start)/2;
        }
        return 0;
    }
};

// Search in a 2D Matrix II

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row=matrix.size();
        int col=matrix[0].size();
        
        int RowIndex=0;
        int ColIndex=col-1;
        
        while(RowIndex<row && ColIndex>=0){
            int element=matrix[RowIndex][ColIndex];
            if(element<target){
                RowIndex++;
            }
            else if(element==target){
                return 1;
            }
            else{
                ColIndex--;
            }
        }
        return 0;
    }
};

// Count prime(Sieve of Eratosthenes)

class Solution {
public:
    int countPrimes(int n) {
        int count=0;
        vector<bool> prime(n+1,true);
        
        prime[0]=prime[1]=false;
        
        for(int i=2;i<n;i++){
            if(prime[i]){
               count++; 
            }
            for(int j=2*i;j<n;j=j+i){
                prime[j]=0;
            }
        }
        return count;
    }
};

// Segmented Sieve

class Solution{
public:
    bool isPrime(long long int n)
    {
        if(n<=1){
           return false;
        }
        for(int i=2 ; i*i<=n ; i++){
            if(n%i == 0){
               return false ;
            }
        }
        return true ;
    }
    long long primeProduct(long long L, long long R){
        long long int ans=1;
        int count=0;
        long long int num=pow(10,9) + 7; 
        for(int i=L; i<=R; i++){
            if(isPrime(i)){
                count++;
                ans=(ans*i)%num;
            }
        }
       if(count==0){
           return 1;
       }
       return ans;
    }
};

// GCD

#include<iostream>
using namespace std;
int gcd(int a,int b){
    if(a==0)
    	return b;
    else if(b==0)
    	return a;
    while(a!=b){
    	if(a>b)
	    a=a-b;
	else   
	    b=b-a;
        }
    return a;
}
int main(){
    int a,b;
    cin>>a>>b;
    cout<<"Gcd of "<<a<<" and "<<b<<" is "<<gcd(a,b);
    return 0;
}

// LCM

#include<iostream>
using namespace std;
int main(){
    int a,b,gcd,temp,lcm;
    cin>>a>>b;
    gcd=a;
    temp=b;
    while(gcd!=lcm){
        if(gcd>temp)
            gcd=gcd-temp;
        else
            temp=temp-gcd;
    }
    lcm=(a*b)/gcd;
    return 0;
}

// Modular Exponentiation

#include <bits/stdc++.h>  
int modularExponentiation(int x, int n, int m) {
	int result=1;
	while(n>0){
		if(n&1){
			result=(1LL*(result)*(x))%m;
		}
		x=(1LL*(x)*(x))%m;
		n=n>>1;
	}
	return result;
}

// Pigeon Hole Principle - If there are n+1 number of pigeons and n number of pigeonholes there is must be atleast one pigeonhole which contain atleast two pigeons.

// Catalan Number - Catalan numbers are defined as a mathematical sequence that consists of positive integers, which can be used to find the number of possibilities of various combinations. Cn = 1/(n+1)(2nCn) = Submission[CiCn-i] , i=0 to n-1

#include <iostream>
using namespace std;
unsigned long int catalan(unsigned int n)
{
    if (n <= 1)
        return 1;
    // catalan(n) is sum of
    // catalan(i)*catalan(n-i-1)
    unsigned long int res = 0;
    for (int i = 0; i < n; i++)
        res += catalan(i) * catalan(n - i - 1);
    return res;
}
int main()
{
    for (int i = 0; i < 10; i++)
        cout << catalan(i) << " ";
    return 0;
}

// Inclusion-Exclusion Principle - 

// Chinese Remainder Theorem -
     We are given two arrays num[0..k-1] and rem[0..k-1]. In num[0..k-1], every pair is coprime (gcd for every pair is 1). We need to find minimum positive number x such that: 
     
     x % num[0]    =  rem[0], 
     x % num[1]    =  rem[1], 
     .......................
     x % num[k-1]  =  rem[k-1]
     
     Basically, we are given k numbers which are pairwise coprime, and given remainders of these numbers when an unknown number x is divided by them. We need to find the minimum possible value of x that produces given remainders.
Examples : 
 

Input:  num[] = {5, 7}, rem[] = {1, 3}
Output: 31
Explanation: 
31 is the smallest number such that:
  (1) When we divide it by 5, we get remainder 1. 
  (2) When we divide it by 7, we get remainder 3.

Input:  num[] = {3, 4, 5}, rem[] = {2, 3, 1}
Output: 11
Explanation: 
11 is the smallest number such that:
  (1) When we divide it by 3, we get remainder 2. 
  (2) When we divide it by 4, we get remainder 3.
  (3) When we divide it by 5, we get remainder 1.

#include<bits/stdc++.h>
using namespace std;
// k is size of num[] and rem[]. Returns the smallest number x such that:
// x % num[0] = rem[0],
// x % num[1] = rem[1],
// ..................
// x % num[k-2] = rem[k-1]
// Assumption: Numbers in num[] are pairwise coprime
// (gcd for every pair is 1)
int findMinX(int num[], int rem[], int k)
{
	int x = 1; // Initialize result
	// As per the Chinese remainder theorem, this loop will always break.
	while (true)
	{
		// Check if remainder of x % num[j] is rem[j] or not (for all j from 0 to k-1)
		int j;
		for (j=0; j<k; j++ )
			if (x%num[j] != rem[j])
			break;
		// If all remainders matched, we found x
		if (j == k)
			return x;
		// Else try next number
		x++;
	}
	return x;
}
int main(void)
{
	int num[] = {3, 4, 5};
	int rem[] = {2, 3, 1};
	int k = sizeof(num)/sizeof(num[0]);
	cout << "x is " << findMinX(num, rem, k);
	return 0;
}
  
// Lucas Theorem
// Fermat's Little Theorem
// Probability Equation

// Factorial of a  Large Number

class Solution {
public:
    vector<int> factorial(int N){
         vector<int> res;
         res.push_back(1);
         
         for(int x=2;x<=N;x++){
             int car=0;
             for(int i=0;i<res.size();i++){
                 int val = res[i]*x+car;
                 res[i]=val %10;
                 car=val/10;
             }
             while(car!=0){
                 res.push_back(car%10);
                 car/=10;
             }
         }
         reverse(res.begin(),res.end());
         return res;
    }
};

// Factorial using recursion

// #include<iostream>
// using namespace std;
// int factorial(int n){
//     if(n==0 || n==1){
//         return 1;
//     }
//     else{
//         return n*factorial(n-1);
//     }
// }
// int main(){
//     int n;
//     cout<<"Enter the number:";
//     cin>>n;
//     cout<<factorial(n);
//     return 0;
// }

// Power of 2 using recursion

// #include<iostream>
// using namespace std;
// int power(int n){
//     if(n==0){
//         return 1;
//     }
//     else{
//         return 2*power(n-1);
//     }
// }
// int main(){
//     int n;
//     cout<<"Enter the number:";
//     cin>>n;
//     cout<<power(n);
//     return 0;
// }

// Print counting using recursion

// #include<iostream>
// using namespace std;
// void Print(int n){
//     if(n==0){
//         return;
//     }
//     Print(n-1);
//     cout<<n<<" ";
// }
// int main(){
//     int n;
//     cout<<"Enter the number:";
//     cin>>n;
//     Print(n);
//     return 0;
// }

// Reach Home using recursion

// #include<iostream>
// using namespace std;
// void target(int src,int dest){
//     cout<<"source "<<src<<" destination "<<dest<<endl;
//     if(src==dest){
//         cout<<"Reached Home"<<endl;
//         return;
//     }
//     src++;
//     target(src,dest);
// }
// int main(){
//     int dest,src=1;
//     cout<<"Enter the destination:";
//     cin>>dest;
//     target(src,dest);
//     return 0;
// }

// Fibonacci Number

// class Solution {
// public:
//     int fib(int n) {
//         if(n==0){
//             return 0;
//         }
//         if(n==1){
//             return 1;
//         }
//         else{
//             return fib(n-1)+fib(n-2);
//         }
//     }
// };

// Count Ways To Reach The N-th Stairs

// #include <bits/stdc++.h>
// #define mod 1000000007
// int countDistinctWays(int nStairs) {
//     int n=nStairs;
//     int prev1=1;
//     int prev2=1;
//     int curr;
//     if(n==1 || n==0)
//         return 1;
//     for(int i=2;i<=n;i++){
//         curr=(prev1+prev2)%mod;
//         prev1=prev2;
//         prev2=curr;
//     }
//     return curr%mod;
// }

// Say digits

// Four One Two
// #include<iostream>
// using namespace std;
// void digit(string arr[],int n){
//     if(n==0){
//         return;
//     }
//     int r=n%10;
//     n=n/10;
//     digit(arr,n);
//     cout<<arr[r]<<" ";
// }
// int main(){
//     int n;
//     cout<<"Enter the number:";
//     cin>>n;
//     string arr[10]={"Zero","One","Two","Three","Four","Five","Six","Seven","Eight","Nine"};
//     digit(arr,n);
// }

// Two One Four
// #include<iostream>
// using namespace std;
// void digit(string arr[],int n){
//     if(n==0){
//         return;
//     }
//     int r=n%10;
//     n=n/10;
//     cout<<arr[r]<<" ";
//     digit(arr,n);
// }
// int main(){
//     int n;
//     cout<<"Enter the number:";
//     cin>>n;
//     string arr[10]={"Zero","One","Two","Three","Four","Five","Six","Seven","Eight","Nine"};
//     digit(arr,n);
// }

// Sorting using recursion

// #include<iostream>
// using namespace std;
// bool Sorted(int arr[],int n){
//     if(n==0 || n==1){
//         return true;
//     }
//     if(arr[0]>arr[1]){
//         return false;
//     }
//     else{
//         bool ans=Sorted(arr+1,n-1);;
//         return ans;
//     }
// }
// int main(){
//     int n;
//     cout<<"Enter the size of the array:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     int ans=Sorted(arr,n);
//     if(ans){
//         cout<<"Array is sorted";
//     }
//     else{
//         cout<<"Array is not sorted";
//     }
//     return 0;
// }

// Sum of array using recursion

// #include<iostream>
// using namespace std;
// int sum(int arr[],int n){
//     if(n==0){
//         return 0;
//     }
//     if(n==1){
//         return arr[0];
//     }
//     else{
//         int leftover=sum(arr+1,n-1);
//         int ans=arr[0]+leftover;
//         return ans;
//     }
// }
// int main(){
//     int n;
//     cout<<"Enter the number:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the size of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     cout<<sum(arr,n);
//     return 0;
// }

// Linear search using recursion

// #include<iostream>
// using namespace std;
// bool LinearSearch(int arr[],int n,int search){
//     if(n==0){
//         return false;
//     }
//     if(arr[0]==search){
//         return true;
//     }
//     else{
//         bool leftover=LinearSearch(arr+1,n-1,search);
//         return leftover;
//     }
// }
// int main(){
//     int n;
//     cout<<"Enter the size of the array:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     int search;
//     cout<<"Enter the element you want to search for:";
//     cin>>search;
//     bool ans=LinearSearch(arr,n,search);
//     if(ans){
//         cout<<"Element "<<search<<" is present in the array";
//     }
//     else{
//         cout<<"Element "<<search<<" is not present in the array";
//     }
//     return 0;
// }

// Binary search using recursion

// #include<iostream>
// using namespace std;
// bool BinarySearch(int arr[],int start,int end,int search){
//     if(start>end){
//         return false;
//     }
//     int mid=start+(end-start)/2;
//     if(arr[mid]==search){
//         return true;
//     }
//     if(arr[mid]<search){
//         return BinarySearch(arr,mid+1,end,search);
//     }
//     else{
//         return BinarySearch(arr,start,mid-1,search);
//     }
// }
// int main(){
//     int n;
//     cout<<"Enter the size of the array:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     int search;
//     cout<<"Enter the element you want to search for:";
//     cin>>search;
//     bool ans=BinarySearch(arr,0,n-1,search);
//     if(ans){
//         cout<<"Element "<<search<<" is present in the array";
//     }
//     else{
//         cout<<"Element "<<search<<" is not present in the array";
//     }
//     return 0;
// }

// BinarySearch using recursion(CS)

// int BinarySearch(int arr[],int s,int e,int k){
//     int mid=s+(e-s)/2;
//     if(s>e){
//         return -1;
//     }
//     if(arr[mid]==k){
//         return mid;
//     }
//     if(arr[mid]<k){
//         return BinarySearch(arr, mid+1, e, k);
//     }
//     else{
//         return BinarySearch(arr,s,mid-1,k);
//     }
// }
// int binarySearch(int *input, int n, int val)
// {
//     int ans=BinarySearch(input, 0, n-1, val);
//     return ans;
// }

// Reverse string using recursion

// #include<iostream>
// #include<algorithm>
// using namespace std;
// void ReverseString(string &str,int s,int e){
//     if(s>e){
//         return;
//     }
//     swap(str[s++],str[e--]);
//     ReverseString(str,s,e);
// }
// int main(){
//     string str;
//     cout<<"Enter the string:";
//     cin>>str;
//     ReverseString(str,0,str.length()-1);
//     cout<<str;
//     return 0;
// }

// #include<iostream>
// #include<algorithm>
// using namespace std;
// void ReverseString(string &str,int s){
//     int l=str.length()-s-1;
//     if(s>=l){
//         return;
//     }
//     swap(str[s++],str[l--]);
//     ReverseString(str,s);
// }
// int main(){
//     string str;
//     cout<<"Enter the string:";
//     cin>>str;
//     ReverseString(str,0);
//     cout<<str;
//     return 0;
// }

// Check Palindrome

// #include<iostream>
// #include<algorithm>
// using namespace std;
// bool CheckPalindrome(string &str,int s,int e){
//     if(s>e){
//         return true;
//     }
//     if(str[s]!=str[e]){
//         return false;
//     }
//     else{
//         return CheckPalindrome(str,s+1,e-1);
//     }
// }
// int main(){
//     string str;
//     cin>>str;
//     bool ans=CheckPalindrome(str,0,str.length()-1);
//     if(ans){
//         cout<<"String is a palindorme";
//     }
//     else{
//         cout<<"String is not a palindrome";
//     }
//     return 0;
// }

// #include<iostream>
// #include<algorithm>
// using namespace std;
// bool CheckPalindrome(string &str,int s){
//     int l=str.length()-s-1;
//     if(s>l){
//         return true;
//     }
//     if(str[s++]==str[l--]){
//          return CheckPalindrome(str,s+1);
//     }
//     else{
//        return false;
//     }
// }
// int main(){
//     string str;
//     cin>>str;
//     bool ans=CheckPalindrome(str,0);
//     if(ans){
//         cout<<"String is a palindorme";
//     }
//     else{
//         cout<<"String is not a palindrome";
//     }
//     return 0;
// }

// Power using recursion

// #include<iostream>
// #include<algorithm>
// using namespace std;
// int power(int b,int e){
//     if(e==0){
//         return 1;
//     }
//     if(e==1){
//         return b;
//     }
//     int ans = power(b,e/2);
//     if(e%2==0){
//         return ans*ans;
//     }
//     else{
//         return b*ans*ans;
//     }
// }
// int main(){
//     int b,e;
//     cout<<"Enter the values of base and exponent:";
//     cin>>b>>e;
//     int ans=power(b,e);
//     cout<<ans;
//     return 0;
// }

// Bubble sort using recursion

// #include<iostream>
// #include<algorithm>
// using namespace std;
// void BubbleSort(int arr[],int n){
//     if(n==0 || n==1){
//         return;
//     }
//     for(int i=0;i<n;i++){
//         if(arr[i]>arr[i+1]){
//             swap(arr[i],arr[i+1]);
//         }
//     }
//     BubbleSort(arr,n-1);
// }
// int main(){
//     int n;
//     cout<<"Enter the size of the array:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     BubbleSort(arr,n);
//     for (int i = 0; i < n; i++)
//     {
//         cout<<arr[i]<<" ";
//     }
//     return 0;
// }

// Selection sort suing recursion

// #include<iostream>
// #include<algorithm>
// using namespace std;
// void SelectionSort(int arr[],int start,int n){
//     if(n<=start){
//         return;
//     }
//     int minIndex=start;
//     for(int i=start;i<n;i++){
//         if(arr[i]<arr[minIndex]){
//             minIndex=i;
//         }
//     }
//     swap(arr[minIndex],arr[start]);
//     SelectionSort(arr,start+1,n);
// }
// int main(){
//     int n;
//     cout<<"Enter the size of the array:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     SelectionSort(arr,0,n);
//     for (int i = 0; i < n; i++)
//     {
//         cout<<arr[i]<<" ";
//     }
//     return 0;
// }

// Insertion Sort using recursion

// #include<iostream>
// #include<algorithm>
// using namespace std;
// void InsertionSort(int arr[],int n){
//     if(n<=1){
//         return;
//     }
//     InsertionSort(arr,n-1);
//     int last=arr[n-1];
//     int j=n-2;
//     while(j>=0 && arr[j]>last){
//         arr[j+1]=arr[j];
//         j--;
//     }
//     arr[j+1]=last;
// }
// int main(){
//     int n;
//     cout<<"Enter the size of the array:";
//     cin>>n;
//     int arr[n];
//     cout<<"Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin>>arr[i];
//     }
//     InsertionSort(arr,n);
//     for (int i = 0; i < n; i++)
//     {
//         cout<<arr[i]<<" ";
//     }
//     return 0;
// }

// Merge Sort

// void merging(vector<int> &arr, int s, int e)
// {
//     int mid = s + (e - s) / 2;
//     int length1 = mid + 1 - s;
//     int length2 = e - mid;
//     int *arr1 = new int[length1];
//     int *arr2 = new int[length2];
//     int mainIndexArray = s;
//     for (int i = 0; i < length1; i++)
//     {
//         arr1[i] = arr[mainIndexArray++];
//     }
//     mainIndexArray = mid + 1;
//     for (int i = 0; i < length2; i++)
//     {
//         arr2[i] = arr[mainIndexArray++];
//     }
//     int index1 = 0;
//     int index2 = 0;
//     mainIndexArray = s;
//     while (index1 < length1 && index2 < length2)
//     {
//         if (arr1[index1] < arr2[index2])
//         {
//             arr[mainIndexArray++] = arr1[index1++];
//         }
//         else
//         {
//             arr[mainIndexArray++] = arr2[index2++];
//         }
//     }
//     while (index1 < length1)
//     {
//         arr[mainIndexArray++] = arr1[index1++];
//     }
//     while (index2 < length2)
//     {
//         arr[mainIndexArray++] = arr2[index2++];
//     }
// }
// void merge(vector<int> &arr, int s, int e)
// {
//     if (s >= e)
//     {
//         return;
//     }
//     int mid = s + (e - s) / 2;
//     merge(arr, s, mid);
//     merge(arr, mid + 1, e);
//     merging(arr, s, e);
// }
// void mergeSort(vector<int> &arr, int n) { merge(arr, 0, n - 1); }

// Quick Sort

// #include<iostream>
// #include<algorithm>
// using namespace std;
// int parts(int arr[],int s,int e){
//     int pivot=arr[s];
//     int count=0;
//     for (int i = s+1; i <= e ; i++)
//     {
//         if(arr[i]<= pivot){
//             count++;
//         }
//     }
//     int pivotIndex=s+count;
//     swap(arr[pivotIndex],arr[s]);
//     int i=s,j=e;
//     while(i<pivotIndex && j>pivotIndex){
//         while(arr[i]<pivot){
//             i++;
//         }
//         while(arr[i]>pivot){
//             j--;
//         }
//         if(i<pivotIndex && j>pivotIndex){
//             swap(arr[i++],arr[j--]);
//         }
//     }
//     return pivotIndex;
// }
// void QuickSort(int arr[],int s,int e){
//     if(s>=e){
//         return;
//     }
//     int p = parts(arr,s,e);
//     QuickSort(arr,s,p-1); 
//     QuickSort(arr,p+1,e); 
// }
// int main()
// {
//     int n;
//     cout << "Enter the size of the array:";
//     cin >> n;
//     int arr[n];
//     cout << "Enter the elements of the array:";
//     for (int i = 0; i < n; i++)
//     {
//         cin >> arr[i];
//     }
//     QuickSort(arr, 0, n - 1);
//     for (int i = 0; i < n; i++)
//     {
//         cout << arr[i] << " ";
//     }
//     return 0;
// }

// Subsets using recursion

// class Solution {
// public:
//     void solve(vector<int> nums,vector<int> output,int index,vector<vector<int>> &ans){
//         if(index>=nums.size()){
//             ans.push_back(output);
//             return;
//         }
//         solve(nums,output,index+1,ans);
//         int element=nums[index];
//         output.push_back(element);
//         solve(nums,output,index+1,ans);
//     }
//     vector<vector<int>> subsets(vector<int>& nums) {
//         vector<vector<int>> ans;
//         vector<int> output;
//         int index=0;
//         solve(nums,output,index,ans);
//         return ans;
//     }
// };

// Subsets using Bit Manipulation

// #include <bits/stdc++.h>
// using namespace std;
// // Function to find all subsets of given set. Any repeated subset is considered only once in the output
// vector<vector<int> > findPowerSet(vector<int>& nums)
// {
// 	// Size of array to set bit
// 	int bits = nums.size();
// 	// Total number of subsets = pow(2, sizeof(arr))
// 	unsigned int pow_set_size = pow(2, bits);
// 	// Sort to avoid adding permutation of the substring
// 	sort(nums.begin(), nums.end());
// 	vector<vector<int> > ans;
// 	// To store subset as a list toavoid adding exact duplicates
// 	vector<string> list;
// 	// Counter 000..0 to 111..1
// 	for (int counter = 0; counter < pow_set_size;
// 		counter++) {
// 		vector<int> subset;
// 		string temp = "";
// 		// Check for the current bit in the counter
// 		for (int j = 0; j < bits; j++) {
// 			if (counter & (1 << j)) {
// 				subset.push_back(nums[j]);
// 				// Add special character to separate integers
// 				temp += to_string(nums[j]) + '$';
// 			}
// 		}
// 		if (find(list.begin(), list.end(), temp)
// 			== list.end()) {
// 			ans.push_back(subset);
// 			list.push_back(temp);
// 		}
// 	}
// 	return ans;
// }
// int main()
// {
// 	vector<int> arr{ 10, 12, 12 };
// 	vector<vector<int> > power_set = findPowerSet(arr);
// 	for (int i = 0; i < power_set.size(); i++) {
// 		for (int j = 0; j < power_set[i].size(); j++)
// 			cout << power_set[i][j] << " ";
// 		cout << endl;
// 	}
// 	return 0;
// }

// Subsequences of String using Recursion

// #include <bits/stdc++.h>
// using namespace std;
// void solve(string str, string output, int index, vector<string> &ans) {
//   // base case
//   if (index >= str.length()) {
//     if (output.length() > 0) {
//       ans.push_back(output);
//     }
//     return;
//   }
//   // exclude
//   solve(str, output, index + 1, ans);
//   // include
//   char element = str[index];
//   output.push_back(element);
//   solve(str, output, index + 1, ans);
// }
// vector<string> subsequences(string str) {
//   // Write your code here
//   vector<string> ans;
//   string output = "";
//   int index = 0;
//   solve(str, output, index, ans);
//   return ans;
// }

// Subsequences of String using Bit Manipulation

// #include<bits/stdc++.h>
// using namespace std;
// string print(string s , int i){
// 	int j = 0;
// 	string sub;
// 	//finding where the bit is set
// 	while(i>0){
// 		if(i & 1){
// 			sub.push_back(s[j]); //pushing only when bit is set
// 		}
// 		j++; //always incrementing the index pointer
// 		i = i >> 1;
// 	}	
// 	return sub;
// }
// vector<string> createsubsets(string& s){	
// 	vector <string> res;
// 	for(int i = 1 ; i <= ((1 << s.size()) - 1) ; i++){
// 		//each time we create a subsequence for corresponding binary representation
// 		res.push_back(print(s,i));
// 	}
// 	return res;
// }
// int main(){
// 	string s = "abc";
// 	//vector of strings to store all sub-sequences
// 	vector <string> print = createsubsets(s);	
// 	//print function
// 	for(int i = 0 ; i < print.size() ; i++){
// 		for (int j = 0; j < print[i].size(); j++){
// 			cout << print[i][j]<<" ";
// 		}
// 		cout << endl;
// 	}
// 	return 0;
// }

// Letter Combinations of a Phone Number(Phone Keypad Problem)

// class Solution {
// public:
//     void solve(string digits,string output,int index,vector<string> &ans,string mapping[]){
//         if(index>=digits.length()){
//             ans.push_back(output);
//             return;
//         }
//         int number=digits[index]-'0';
//         string value=mapping[number];
//         for(int i=0;i<value.length();i++){
//             output.push_back(value[i]);
//             solve(digits,output,index+1,ans,mapping);
//             output.pop_back();
//         }
//     }
//     vector<string> letterCombinations(string digits) {
//         vector<string> ans;
//         if(digits.length()==0){
//             return ans;
//         }
//         string output="";
//         int index=0;
//         string mapping[10]={""," ","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
//         solve(digits,output,index,ans,mapping);
//         return ans;
//     }
// };

// Permutations of a string

// class Solution {
// public:
//     void solve(vector<int>& nums,vector<vector<int>> &ans,int index){
//         if(index>=nums.size()){
//             ans.push_back(nums);
//             return;
//         }
//         for(int i=index;i<nums.size();i++){
//             swap(nums[i],nums[index]);
//             solve(nums,ans,index+1);
//             swap(nums[i],nums[index]);
//         }
//     }
//     vector<vector<int>> permute(vector<int>& nums) {
//         vector<vector<int>> ans;
//         int index=0;
//         solve(nums,ans,index);
//         return ans;
//     }
// };

// Rat in a Maze Problem - I

class Solution{
    private:
    bool safe(int x ,int y , int n , vector<vector<int>> visited ,vector<vector<int>> &m ){
        if( ( x >= 0 && x < n ) && ( y >= 0 && y < n ) && visited[x][y] == 0 && m[x][y] == 1){
            return true; 
        }
        else{
            return false;
        }
    }
    void solve(vector<vector<int>> &m , int n ,vector<string>& ans , int x , int y ,vector<vector<int>> visited , string path){
        //base case
        if( x == n - 1 && y == n - 1 ){
            ans.push_back(path);
            return ;
        }
        //when you cover that index
        visited[x][y] = 1;
        // their are  choices     
        // 1st is Down
        int newx = x + 1;
        int newy = y;
        if( safe( newx , newy , n ,visited , m)){
            path.push_back('D');
            solve( m , n , ans , newx , newy , visited , path);
            path.pop_back();
        }
        // 1st is Left
         newx = x;
         newy = y - 1;
        if( safe( newx , newy , n ,visited , m)){
            path.push_back('L');
            solve( m , n , ans , newx , newy , visited , path);
            path.pop_back();
        }
        // 1st is Right
        newx = x;
        newy = y + 1;
        if( safe( newx , newy , n ,visited , m)){
            path.push_back('R');
            solve( m , n , ans , newx , newy , visited , path);
            path.pop_back();
        }
        // 1st is Up
         newx = x - 1;
         newy = y;
        if( safe( newx , newy , n ,visited , m)){
            path.push_back('U');
            solve( m , n , ans , newx , newy , visited , path);
            path.pop_back();
        }
        visited[x][y] = 0;
    }
    public:
    vector<string> findPath(vector<vector<int>> &m, int n) {
        vector<string>ans ;
        if( m [0][0] == 0){
            return ans;
        }
        int srcx = 0;
        int srcy = 0;
        // Make a visited 2D vector
        vector<vector<int>> visited = m;
        // make it default by all indeces by 0
        for( int i = 0; i < n; i++){
            for( int j = 0; j < n; j++){
                visited [i][j] = 0;
            }
        }
        string path = "";
        solve( m , n , ans , srcx , srcy , visited , path);
        sort(ans.begin() , ans.end());
        return ans;
    }
};
    
/************************************************************

    Following is the linked list node structure.
    
    class Node 
    {
        public:
        int data;
        Node* next;

        Node(int data) 
        {
            this->data = data;
            this->next = NULL;
        }
    };
    
************************************************************/    
    
// Reverse a Linked List

LinkedListNode<int> *reverseLinkedList(LinkedListNode<int> *head) 
{
    if(head == NULL || head->next == NULL){
        return head;
    }
    LinkedListNode<int>* prev=NULL;
    LinkedListNode<int>* curr=head;
    LinkedListNode<int>* forw=NULL;
    while(curr!=NULL){
        forw=curr->next;
        curr->next=prev;
        prev=curr;
        curr=forw;
    }
    return prev;
}

// Reverse a Linked List(Recursively)

LinkedListNode<int> *rev(LinkedListNode<int> *head) {
	  if (head == NULL || head->next == NULL){
	    return head;
	  }
LinkedListNode<int> *chotaHead = rev(head->next);
	  head->next->next = head;
	  head->next = NULL;
	  return chotaHead;
}
LinkedListNode<int> *reverseLinkedList(LinkedListNode<int> *head) {
    return rev(head);
}

// Reverse a Doubly Linked List

Node* reverseDLL(Node * head){
    Node *prev = NULL;
    Node *curr = head;
    Node *temp=NULL;
    while(curr!=NULL){
        temp = curr->prev;
        curr->prev = curr->next;
        curr->next = temp;
        prev = curr;
        curr = curr->prev;
    }
    return prev;
}

// Middle of a Linked List

int getLength(Node *head){
    int ans=0;
    while(head){
        ans++;
        head=head->next;
    }
    return ans;
}
Node *findMiddle(Node *head) {
    int n=getLength(head);
    int t=n/2;
    Node *ans=head;
    while(t--){
        ans=ans->next;
    }
    return ans;
}

// Reverse Nodes In K-Group

Node *krevgroup(Node *head, int n, int b[], int i)
{
    if (n<1 || head == NULL || head->next == NULL){
        return head;
    }
    Node *prev = NULL;
    Node *curr = head;
    Node *nxt = NULL;
    int cnt = 0;
    while(b[i] == 0 && i < n){ 
    	i++;
    }
    while (curr != NULL && cnt < b[i] && i < n  ){
        nxt = curr->next;
         curr->next = prev;
        prev = curr;
        curr = nxt;
        cnt++;
    }
    if (i >= n && curr != NULL){
        return head;
    }
    if (curr != NULL)
        head->next = krevgroup(nxt, n, b, i + 1);
    return prev;
}
Node *getListAfterReverseOperation(Node *head, int n, int b[]){
	return krevgroup(head,n,b,0);
}

// Circularly LinkedList

// Method-1
bool isCircularList(Node *head){
    //empty list
    if(head==NULL){
    	return head;
    }
    Node *temp=head->next;
    while(temp!=NULL && temp!=head){
          temp=temp->next;
    }
    if(temp==head){
          return true;
    }
    return false;
}

// Method-2
bool isCircular(Node* head){
    if(head==NULL){
        return 1;
    }
    Node* slow=head;
    Node* fast=head;
    while(fast!=NULL && fast->next!=NULL){
        slow=slow->next;
        fast=fast->next->next;
        if(slow==fast){
            if(slow==head){
                return 1;
            }
            else{
                return 0;
            }
        }
    }
    return 0;
}

// Method-3
bool hasCycle(ListNode *head){
	unordered_map<ListNode*,bool>map;
	ListNode *temp=head;
	while(temp!=NULL){
		if(map.find(temp)!=map.end())
			return ttrue;
		map[temp]=true;
		temp=temp->next;
	}
	return false;
}

// Detect and Remove Loop

// Method-1 for detection of loop
bool detectLoop(Node *head){
	if(head==NULL) return false;
	map<Noode*,bool> visited;
	Node *temp=head;
	while(temp!=NULL){
		if(visited[temp]==true){
			return true;
		}
		visited[temp]=true;
		temp=temp->next;
	}
	return false;
}

//this is to find cycle in the loop
Node* floydCycle(Node* head)
{
    if(head == NULL){
        return NULL;
    }
    Node* slow = head;
    Node* fast = head;
    while(slow!=NULL && fast!=NULL){
        fast = fast->next;
        if(fast!=NULL){
            fast = fast->next;
        }
        slow = slow->next;
        if(slow == fast){
            return slow;
        }
    }
    return NULL;
}
//this is to find first element from where loop started 
Node* loopFind(Node* head){
    if(head == NULL){
        return NULL;
    }
    Node* meet = floydCycle(head);
    if(meet == NULL){
        return NULL;
    }
    Node* slow = head;
    while(slow!= meet){
        slow = slow->next;
        meet = meet->next;
    }
    return slow;
}
//this is to remove the loop
Node *removeLoop(Node *head){
    if(head == NULL){
        return NULL;
    }
    Node* startLoop = loopFind(head);
    if(startLoop == NULL){
        return head;
    }
    Node* temp = startLoop;
    while(temp->next!= startLoop){
        temp = temp->next;
    }
    temp->next = NULL;
    return head;
}

// Remove Duplicates From a Sorted Linked List

Node * uniqueSortedList(Node * head) {
    if(head==NULL) return NULL;
    Node* curr=head;
    while(curr!=NULL){
        if(curr->next!=NULL && curr->data==curr->next->data){
            Node* next_next=curr->next->next;
            Node* nodeToDelete=curr->next;
            delete(nodeToDelete);
            curr->next= next_next;
        }
        else{
            curr=curr->next; 
        }
    }
    return head;
}

// Remove Duplicates from a Unsorted Linked List

// Method-1[Brute Force(T.C --> O(n^2),S.C --> O(1))]
Node *removeDuplicates(Node *head)
{
    if(head == NULL) return NULL;
    Node* curr = head;
    while(curr != NULL) {
        Node* temp = curr;
        while(temp -> next != NULL) {
            if(curr -> data == temp -> next -> data){
                Node* next_next = temp -> next -> next;
                Node* nodeToDelete = temp -> next;
                nodeToDelete -> next = NULL;
                delete nodeToDelete;
                temp -> next = next_next;
            }
            else
                temp = temp -> next;
        }
        curr = curr -> next;
    }
    return head;
}

// Method-2
Node *removeDuplicates(Node *head)
{
    if( head == NULL){
        return NULL;
    }
    unordered_map< int, bool> visited;
    Node *curr = head;
    while( curr -> next != NULL){
        visited[curr -> data ] = true;
        if( visited[curr -> next -> data] == true){
            curr -> next = curr -> next -> next;
        }
        else{
            curr = curr -> next;
        }
    }
    return head;
}

// Method-3(sort then use above question approach)

// Split LinkedList in two halves

void splitList(Node *head, Node **head1_ref, Node **head2_ref)
{
    // using two pointer approach fast and slow which is used to calculate middle node
    Node *fast=head->next;
    Node *slow = head;
    
    while(fast->next!=head){
        fast=fast->next;
        if(fast->next!=head){
            fast=fast->next;
        }
        slow=slow->next;
    }
    Node* temp=slow->next;
    slow->next=head;
    fast->next=temp;
    *head1_ref=head;
    *head2_ref=temp;
}

// Split Linked List in parts
		
class Solution {
public:
    vector<ListNode*> splitListToParts(ListNode* head, int k) {
        vector<ListNode*> ans;
        int len=0;
        ListNode *temp=head;
        while(temp!=NULL)
        {
            len++;
            temp=temp->next;
        }
        int size=len/k;
        int rem=len%k;
        temp=head;
        for(int i=0;i<k;i++)
        {
            ListNode *end=temp;
            if(rem>0)
            {
                int c=size;
                while(c--)
                {
                    end=end->next;
                }
                ListNode *x=end->next;
                end->next=NULL;
                ans.push_back(temp);
                temp=x;
                rem--;
            }
            else
            {
                if(size==0)
                {
                    ans.push_back(NULL);    
                }
                else
                {
                    int c=size-1;
                    while(c--)
                    {
                        end=end->next;
                    }
                    ListNode*x=end->next;
                    end->next=NULL;
                    ans.push_back(temp);
                    temp=x;
                }
            }
        }
        return ans;
    }
};	

// Sort 0s,1s and 2s in Linked List

// Method 1
class Solution
{
    public:
    //Function to sort a linked list of 0s, 1s and 2s.
    Node* segregate(Node *head) {
        int zeroCount=0,oneCount=0,twoCount=0;
        Node *temp=head;
        while(temp!=NULL){
            if(temp->data==0) zeroCount++;
            else if(temp->data==1) oneCount++;
            else if(temp->data==2) twoCount++;
            temp=temp->next;
        }
        temp=head;
        while(temp!=NULL){
            if(zeroCount!=0){
                temp->data=0;
                zeroCount--;
            }
            else if(oneCount!=0){
                temp->data=1;
                oneCount--;
            }
            else if(twoCount!=0){
                temp->data=2;
                twoCount--;
            }
            temp=temp->next;
        }
        return head;
    }
};

// Method 2
class Solution
{
    public:
    void insertAtTail(Node *&tail,Node *curr){
        tail->next=curr;
        tail=curr;
    }
    Node* segregate(Node *head) {
        Node *zeroHead=new Node(-1);
        Node *zeroTail=zeroHead;
        Node *oneHead=new Node(-1);
        Node *oneTail=oneHead;
        Node *twoHead=new Node(-1);
        Node *twoTail=twoHead;
        Node *curr=head;
        // created seperate list of 0s,1s and 2s
        while(curr!=NULL){
            int val=curr->data;
            if(val==0) insertAtTail(zeroTail,curr);
            else if(val==1) insertAtTail(oneTail,curr);
            else if(val==2) insertAtTail(twoTail,curr);
            curr=curr->next;
        }
        // merging above list
        if(oneHead->next!=NULL){
            zeroTail->next=oneHead->next;
        }
        else{
            zeroTail->next=twoHead->next;   
        }
        oneTail->next=twoHead->next;
        twoTail->next=NULL;
        // setup head
        head=zeroHead->next;
        // delete dummy nodes
        delete zeroHead;
        delete oneHead;
        delete twoHead;
        return head;
    }
};

// Merge two sorted arrays in a Linked List

Node<int>* solve( Node<int>* first , Node<int>* second){

    if( first -> next == NULL){
        first -> next = second;
        return first;
    }
    Node<int>* curr1 = first;
    Node<int>* next1 = curr1 -> next;
    Node<int>* curr2 = second;
    Node<int>* next2 = curr2 -> next;
    while( next1 != NULL and curr2 != NULL){
        if( (curr2 -> data >= curr1 -> data) and (curr2 -> data <= next1 -> data)){
            curr1 -> next = curr2;
            next2 = curr2 -> next;
            curr2 -> next = next1;
            curr1 = curr2;
            curr2 = next2;
        }
        else{
            curr1 = next1;
            next1 =  next1 -> next;

            if( next1 == NULL){
                curr1 -> next = curr2;
                return first;
            }
        }
    }
    return first;
}

Node<int>* sortTwoLists(Node<int>* first, Node<int>* second)
{
    if(first == NULL){
        return second;
    }
    if(second == NULL){
        return first;
    }

    if( first -> data <= second -> data){
        return solve( first , second );
    }
    else{
        return solve( second , first );
    }
}

// using recursion
Node<int>* sortTwoLists(Node<int>* first, Node<int>* second)
{
    if(first==NULL){
        return second;
    }
    if (second=NULL) {
        return first;
    }
    if(first->data<=second->data){
        first->next=sortTwoLists(first->next,second);
        return first;
    }
    else{
        second->next=sortTwoLists(first,second->next);
        return second;
    }
}

// Linked List is Palindrome or not

// Method 1
#include<vector>
class Solution{
  public:
    bool checkPalindrome(vector<int> arr){
        int n=arr.size();
        int s=0,e=n-1;
        while(s<=e){
            if(arr[s]!=arr[e]){
                return 0;
            }
            s++;
            e--;
        }
        return 1;
    }
    bool isPalindrome(Node *head)
    {
        vector<int> arr;
        Node *temp=head;
        while(temp!=NULL){
            arr.push_back(temp->data);
            temp=temp->next;
        }
        return checkPalindrome(arr);
    }
};

// Method 2
class Solution{
  public:
    Node *getMid(Node *head){
        Node *slow=head;
        Node *fast=head->next;
        while(fast!=NULL && fast->next!=NULL){
            fast=fast->next->next;
            slow=slow->next;
        }
        return slow;
    }
    Node *reverse(Node *head){
        Node *curr=head;
        Node *prev=NULL;
        Node *forward=NULL;
        while(curr!=NULL){
            forward=curr->next;
            curr->next=prev;
            prev=curr;
            curr=forward;
        }
        return prev;
    }
    bool isPalindrome(Node *head)
    {
        if(head->next==NULL){
            return true;    
        } 
        // find mid
        Node *mid=getMid(head);
        // reverse list after mid
        Node *temp=mid->next;
        mid->next=reverse(temp);
        // compare both halves
        Node *head1=head;
        Node *head2=mid->next;
        while(head2!=NULL){
            if(head1->data!=head2->data){
                return false;
            }
            head1=head1->next;
            head2=head2->next;
        }
        // form the same linkedlist given 
        temp=mid->next;
        mid->next=reverse(temp);
        return true;
    }
};

// Add two Numbers in a linked list

// Method-1
class Solution
{
    public:
    struct Node *reverse(Node *head){
        Node *curr=head;
        Node *prev=NULL;
        Node *forward=NULL;
        while(curr!=NULL){
            forward=curr->next;
            curr->next=prev;
            prev=curr;
            curr=forward;
        }
        return prev;
    }
    void insertAtTail(struct Node* &head, struct Node* &tail,int val){
        Node *temp=new Node(val);
        // empty list
        if(head==NULL){
            head=temp;
            tail=temp;
            return;
        }
        // non-empty list
        else{
            tail->next=temp;
            tail=temp;
        }
    }
    struct Node *add(struct Node* first, struct Node* second){
        Node *ansHead=NULL;
        Node *ansTail=NULL;
        int carry=0;
        while(first!=NULL && second!=NULL){
            int sum=carry+first->data+second->data;
            int digit=sum%10;
            // create node and add in answer linked list
            insertAtTail(ansHead,ansTail,digit);
            carry=sum/10;
            first=first->next;
            second=second->next;
        }
        while(first!=NULL){
            int sum=carry+first->data;
            int digit=sum%10;
            // create node and add in answer linked list
            insertAtTail(ansHead,ansTail,digit);
            carry=sum/10;
            first=first->next;
        }
        while(second!=NULL){
            int sum=carry+second->data;
            int digit=sum%10;
            // create node and add in answer linked list
            insertAtTail(ansHead,ansTail,digit);
            carry=sum/10;
            second=second->next;
        }
        while(carry!=0){
            int sum=carry;
            int digit=sum%10;
            // create node and add in answer linked list
            insertAtTail(ansHead,ansTail,digit);
            carry=sum/10;
        }
        return ansHead;
    }
    struct Node* addTwoLists(struct Node* first, struct Node* second)
    {
        // reverse the linked lists which are to be added
        first=reverse(first);
        second=reverse(second);
        // perform addition
        Node *ans=add(first,second);
        // reverse the answer linked list
        ans=reverse(ans);
        return ans;
    }
};

// Method-2(same method but less complicated)
class Solution
{
    public:
    struct Node *reverse(Node *head){
        Node *curr=head;
        Node *prev=NULL;
        Node *forward=NULL;
        while(curr!=NULL){
            forward=curr->next;
            curr->next=prev;
            prev=curr;
            curr=forward;
        }
        return prev;
    }
    void insertAtTail(struct Node* &head, struct Node* &tail,int val){
        Node *temp=new Node(val);
        // empty list
        if(head==NULL){
            head=temp;
            tail=temp;
            return;
        }
        // non-empty list
        else{
            tail->next=temp;
            tail=temp;
        }
    }
    struct Node *add(struct Node* first, struct Node* second){
        Node *ansHead=NULL;
        Node *ansTail=NULL;
        int carry=0;
        while(first!=NULL || second!=NULL || carry!=0){
            int val1=0;
            if(first!=NULL){
                val1=first->data;
            }
            int val2=0;
            if(second!=NULL){
                val2=second->data;
            }
            int sum=carry+val1+val2;
            int digit=sum%10;
            // create node and add in answer linked list
            insertAtTail(ansHead,ansTail,digit);
            carry=sum/10;
            if(first!=NULL){
                first=first->next;
            }
            if(second!=NULL){
                second=second->next;
            }
        }
        return ansHead;
    }
    struct Node* addTwoLists(struct Node* first, struct Node* second)
    {
        // reverse the linked lists which are to be added
        first=reverse(first);
        second=reverse(second);
        // perform addition
        Node *ans=add(first,second);
        // reverse the answer linked list
        ans=reverse(ans);
        return ans;
    }
};

// Add one to the number(Linked List)

// Method-1
class Solution
{
    public:
    Node* reverse(Node* head)
    {
        if(!head || !head->next)
            return head;
        Node* curr = head;
        Node* prev = NULL;
        Node* Next = head->next;
        while(curr->next!=NULL)
        {
            curr->next = prev;
            prev = curr;
            curr = Next;
            Next = Next->next;
        }
        curr->next = prev;
        return curr;
    }
    Node* addOne(Node *head) 
    {
        Node* newHead = reverse(head);
        Node* temp = newHead;
        while(temp->next != NULL && temp->data == 9)
        {
            temp->data = 0;
            temp = temp->next;
        }
        if(temp->data != 9)
            temp->data += 1;
        else if(temp->next == NULL && temp->data == 9)
        {
            temp->data = 0;
            temp->next = new Node(1);
        }
        return reverse(newHead);
    }
};

// Method-2
class Solution
{
    int recursiveAddition(Node*head)
    {
        if(head == NULL)
        {
            return 1;
        }
        int carry = recursiveAddition(head->next);
        int sum = head->data + carry;
        carry = sum / 10;
        sum = sum % 10;
        head->data = sum;
        return carry;
    }
    public:
    Node* addOne(Node *head) 
    {
        // return head of list after adding one
        int carry = recursiveAddition(head);
        if(carry == 0)
        {
            return head;
        }
        Node*temp = new Node(carry);
        temp->next = head;
        head = temp;
        return head;
    }
};

// Clone a Linked List with next and random pointers

// Method-1
class Solution
{
    public:
    Node *copyList(Node *head)
    {
        Node* temp = head;
        unordered_map <Node*, Node*> map;
        vector <Node*> vec;
        while(temp){
            Node* n = new Node(temp->data);
            vec.push_back(n);
            map[temp] = n;
            temp = temp->next;
        }
        for(int i=0; i<vec.size()-1; i++){
            vec[i]->next = vec[i+1];
        }
        vec[vec.size()-1] = NULL;
        temp = head;
        while(temp){
            map[temp]->arb = map[temp->arb];
            temp = temp->next;
        }
        return map[head];   
    }
};

// Method-2
class Solution
{
    public:
    Node *copyList(Node *head)
    {
        Node*current=head;
        while(current!=NULL){
        Node* temp = current->next;
        current->next = new Node(current->data);
        current->next->next = temp;
        current = temp;
        }
        current=head;
        
        //Setting random pointers to new nodes
    
        while(current!=NULL){
            
            current->next->arb = (current->arb) ? current->arb->next: current->arb;
            current = current->next->next;
        }
        
        // Separating both the linked lists
    
        Node* original = head;
        Node *copy  = head->next;
        Node* temp = copy;
        
        while(original!=NULL && copy!=NULL){
            original->next = original->next->next;
            copy->next = (copy->next!= NULL)?copy->next->next:copy->next;
            original = original->next;
            copy = copy->next;
        }
        return temp;
    }
};

// Merge Sort in Linked List

class Solution{
  public:
    //Function to sort the given linked list using Merge Sort.
    Node *middle(Node *head)
    {
        Node* slow=head;
        Node* fast=head->next;
        while(fast!=NULL && fast->next!=NULL)
        {
            slow=slow->next;
            fast=fast->next->next;
        }
        return slow;
    }
    Node *merge(Node* left,Node* right)
    {
        Node *curr=new Node(-1);
        Node *temp=curr;
        if(left==NULL)
        return right;
        if(right==NULL)
        return left;
        while(left!=NULL && right !=NULL)
        {
            if(left->data<right->data)
            {
                temp->next=left;
                temp=temp->next;
                left=left->next;
            }
            else
            {
                 temp->next=right;
                temp=temp->next;
                right=right->next;
            }
        }
        while(left!=NULL)
        {
             temp->next=left;
                temp=temp->next;
                left=left->next;
        }
        while(right!=NULL)
        {
             temp->next=right;
                temp=temp->next;
                right=right->next;
        }
        return curr->next;
    }
    Node* mergeSort(Node* head) {
        // your code here
        if(head==NULL || head->next==NULL)
        {
            return head;
        }
        Node *curr=head;
        Node *left=NULL;
        Node *right=NULL;
        Node* mid=middle(curr);
        left=head;
        right=mid->next;
        mid->next=NULL;
        left=mergeSort(left);
        right=mergeSort(right);
        Node *ans=merge(left,right);
        return ans;
    }
};

// Flatten a Linked List

void insert(Node *head,Node* val){
    Node* curr = head->bottom;
    Node* prev = head;
    while(prev){
        if(!curr or val->data < curr->data){
            prev->bottom = val;
            val->bottom = curr;
            return;
        }
        prev = curr;
        curr = curr->bottom;
    }
}
Node *flatten(Node *root)
{
    Node* head = root,*ans = root;
    root = root->next;
    while(root){
        Node* curr = root;
        while(curr){
            Node* next = curr->bottom;
            curr->bottom = nullptr;
            insert(head,curr);
            curr = next;
        }
        root = root->next;
    }
    return ans;
}

// Two Stacks

#include <bits/stdc++.h> 
class TwoStack {
public:
    int *arr;
    int top1;
    int top2;
    int size;
    // Initialize TwoStack.
    TwoStack(int s) {
        this->size=s;
        arr=new int[s];
        top1=-1;
        top2=s;
    }
    // Push in stack 1.
    void push1(int num) {
        if(top2-top1>1){
            top1++;
            arr[top1]=num;
        }
    }
    // Push in stack 2.
    void push2(int num) {
        if(top2-top1>1){
            top2--;
            arr[top2]=num;
        }
    }
    // Pop from stack 1 and return popped element.
    int pop1() {
        if(top1>=0){
            int ans=arr[top1];
            top1--;
            return ans;
        }
        else{
            return -1;
        }
    }
    // Pop from stack 2 and return popped element.
    int pop2() {
        if(top2<size){
            int ans=arr[top2];
            top2++;
            return ans;
        }
        else{
            return -1;
        }
    }
};

// Reverse a string using Stack

char* reverse(char *S, int len){
    stack<char> st;
    for(int i = 0;i<len;i++){
        st.push(S[i]);
    }
    int i = 0;
    while(!st.empty()){
        S[i++] = st.top();
        st.pop();
    }
    return S;
}

// Reverse a stack

class Solution{
    public:
    void Reverse(stack<int> &St){
       vector<int> s1;
       while(!St.empty()){
           int num=St.top();
           St.pop();
           s1.push_back(num);
       }
       for(int i=0;i<s1.size();i++){
           St.push(s1[i]);
       }
    }
};

// Delete middle element from stack

#include <bits/stdc++.h> 
void solve(stack<int>&inputStack,int count, int size){
    if(count==size/2){
        inputStack.pop();
        return;
    }
    int num=inputStack.top();
    inputStack.pop();
    solve(inputStack,count+1,size);
    inputStack.push(num);
}
void deleteMiddle(stack<int>&inputStack, int N){
	int count=0;
    solve(inputStack,count,N);
}

// Valid Parantheses

bool isValidParenthesis(string expression)
{
    stack<char> s;
    for (int i = 0; i < expression.length(); i++)
    {
        char ch = expression[i];
        if (ch == '(' || ch == '{' || ch == '[')
        {
            s.push(ch);
        }
        else
        {
            if (!s.empty())
            {
                char top = s.top();
            if ((ch == ')' && top=='(') || (ch == '}' && top== '{') || (ch==']' && top=='[')){
                    s.pop();
            }
            else{
                    return false;
            }
            }
            else
            {
            return false;
            }
        }
    }
    if (s.empty())
    {
        return true;
    }
    else
    {
        return false;
    }
}

// Insert an element at its bottom in the given stack

#include <bits/stdc++.h>
void solve(stack<int> &s,int x){
    if(s.empty()){
        s.push(x);
        return;
    }
    int num=s.top();
    s.pop();
    solve(s,x);
    s.push(num);
} 
stack<int> pushAtBottom(stack<int>& myStack, int x) {
    solve(myStack,x);
    return myStack;    
}

// Reverse a stack using recurison

void insertAtBottom(stack<int> &s,int element){
    if(s.empty()){
        s.push(element);
        return;
    }
    int num=s.top();
    s.pop();
    insertAtBottom(s, element);
    s.push(num);
}
void reverseStack(stack<int> &stack) {
    if(stack.empty()){
        return;
    }
    int num=stack.top();
    stack.pop();
    reverseStack(stack);
    insertAtBottom(stack,num);
}

// Sort a Stack

#include <bits/stdc++.h> 
void sortedInserted(stack<int> &stack,int num){
	if(stack.empty() || (!stack.empty() && stack.top()<num)){
		stack.push(num);
		return;
	}
	int n=stack.top();
	stack.pop();
	sortedInserted(stack, num);
	stack.push(n);
}
void sortStack(stack<int> &stack)
{
	if(stack.empty()){
		return;
	}
	int num=stack.top();
	stack.pop();
	sortStack(stack);
	sortedInserted(stack,num);
}

// Redundant brackets

#include <bits/stdc++.h> 
bool findRedundantBrackets(string &s)
{
    stack<char> st;
    for(int i=0;i<s.length();i++){
        char ch=s[i];
        if(ch=='(' || ch=='+' || ch=='-' || ch=='*' || ch=='/' ){
            st.push(ch);
        }
        else{
            if(ch==')'){
                bool isRedundant=true;
                while(st.top()!='('){
                    char top=st.top();
                    if(top=='+' || top=='-' || top=='*' || top=='/' ){
                        isRedundant=false;
                    }
                    st.pop();
                }
                if(isRedundant==true){
                    return true;
                }
                st.pop();
            }
        }
    }
    return false;
}

// Minimum cost to make string valid

#include <bits/stdc++.h> 
int findMinimumCost(string str) {
    //odd condition
    if(str.length()%2 == 1) {
        return -1;
    }
    stack<char> s;
    for(int i=0; i<str.length(); i++) {
        char ch = str[i];
        if (ch == '{') {
          s.push(ch);
        } 
        else {
          // ch is closed brace
          if (!s.empty() && s.top() == '{') {
            s.pop();
          } 
          else {
            s.push(ch);
          }
        }
    }
    //stack contains invalid expression
    int a = 0, b = 0;
    while(!s.empty()) {
      if(s.top() == '{') {
        b++;
      }
      else{
        a++;
      }
      s.pop();
    }    
    int ans = (a+1)/2 + (b+1)/2;
    return ans;
}

// Next smaller element

#include<stack>
vector<int> nextSmallerElement(vector<int> &arr, int n){
    stack<int> s;
    s.push(-1);
    vector<int> ans(n);
    for(int i=n-1;i>=0;i--){
        int curr = arr[i];
        while (s.top() >= curr) {
            s.pop();
        }
        ans[i] = s.top();
        s.push(curr);
    }
    return ans;
}

// Previous Smaller element

#include<stack>
vector<int> nextSmallerElement(vector<int> &arr, int n){
    stack<int> s;
    s.push(-1);
    vector<int> ans(n);
    for(int i=0;i<n;i++){
        int curr = arr[i];
        while (s.top() >= curr) {
            s.pop();
        }
        ans[i] = s.top();
        s.push(curr);
    }
    return ans;
}

// Largest Rectangular Area in a histogram

// Method-1 : Brute Force
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n=heights.size(),prev,next;
        long long maxi=0;
        for(int i=0;i<n;i++)
        {
            int c=1;
            prev=i-1;
            next=i+1;
            while(prev>=0 && heights[i]<=heights[prev]) //if prev>=current
            {
                c++;
                prev--;
            }
            while(next<n && heights[i]<=heights[next]) //if next>=current
            {
                c++;
                next++;
            }
            long long area=heights[i]*c;
            maxi=max(maxi,area);
            int t=heights[i];
            while(i<n && heights[i]==t) //for same heights
            {
                i++;          
            }
            i--;
            
        }
        return maxi;
    }
};

// Method-2 
#include <stack>
#include <climits>
vector<int> nextSmaller(vector<int> &arr, int n)
{
    stack<int> st;
    st.push(-1);
    vector<int> ans(n);
    for (int i = n - 1; i >= 0; i--)
    {
        int curr = arr[i];
        while (st.top() != -1 && arr[st.top()] >= curr)
        {
            st.pop();
        }
        ans[i] = st.top();
        st.push(i);
    }
    return ans;
}
vector<int> prevSmaller(vector<int>&arr,int n){
    stack<int> st;
    st.push(-1);
    vector<int> ans(n);
    for (int i = 0; i < n; i++)
    {
        int curr = arr[i];
        while (st.top() != -1 && arr[st.top()] >= curr)
        {
            st.pop();
        }
        ans[i] = st.top();
        st.push(i);
    }
    return ans;
 }
 int largestRectangle(vector < int > & heights) {
    int n = heights.size();
    vector<int> next(n);
    next = nextSmaller(heights, n);
    vector<int> prev(n);
    prev = prevSmaller(heights, n);
    int area = INT_MIN;
    for (int i = 0; i < n; i++)
    {
        int l = heights[i];
        if (next[i] == -1)
        {
            next[i] = n;
        }
        int b = next[i] - prev[i] - 1;
        int newArea = l * b;
        area = max(area, newArea);
    }
    return area;
 }

// Celebrity Problem

// Method-1 : Brute Force


// Method-2
#include <bits/stdc++.h> 
/*
    This is signature of helper function 'knows'.
    You should not implement it, or speculate about its implementation.
    bool knows(int A, int B); 
    Function 'knows(A, B)' will returns "true" if the person having
    id 'A' know the person having id 'B' in the party, "false" otherwise.
*/
int findCelebrity(int n) {
     stack<int>st;
     for(int i=0;i<n;i++)
     {
         st.push(i);
     }
     while(st.size() > 1)
     {
         int a = st.top();
         st.pop();
         int b = st.top();
         st.pop();
         if(knows(a,b))
         {
             st.push(b);
         }
         else
         {
             st.push(a);
         }
     }
     int candi = st.top();
     int celeb = 0;
     for(int i=0;i<n;i++)
     {
         if(knows(candi,i))
         celeb++;
     }
     if(celeb!=0)
     {
         return -1;
     }
     int people = 0;
     for(int i=0;i<n;i++)
     {
         if(knows(i,candi))
         people++;
     }
     if(people!= n-1)//all element should be 1 other than diagonal
     {
         return -1;
     }
     return candi;
}

// Max rectangle in binary matrix with all  1's

// Method-1
class Solution{
  public:
    int largestArea(vector<int>& arr)
    {
        int n = arr.size();
        stack<int> stk;
        stk.push(-1);
        int max_area=0;
        for(int i=0;i<n;i++)
        {
            while(stk.top()!=-1 && arr[stk.top()]>=arr[i])
            {
                int height = arr[stk.top()];
                stk.pop();
                int ls = stk.top();
                int rs = i;
                int width = rs-ls-1;
                max_area = max(max_area,width*height);
            }
            stk.push(i);
        }
        while(stk.top()!=-1)
        {
            int height = arr[stk.top()];
            stk.pop();
            int ls = stk.top();
            int rs = n;
            int width = rs-ls-1;
            max_area = max(max_area,width*height);
        }
        
        return max_area;
    }
    int maxArea(int M[MAX][MAX], int n, int m) {
        vector<int> arr(m,0);
        int ans=largestArea(arr);
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                if(M[i][j]==1) arr[j]++;
                else arr[j]=0;
            }
            ans = max(ans,largestArea(arr));
        }
        return ans;
    }
};

// Method-2
class Solution{
  private:
  vector<int> nextSmallerElement(int *arr, int n) {
        stack<int> s;
        s.push(-1);
        vector<int> ans(n);
        for(int i=n-1; i>=0 ; i--) {
            int curr = arr[i];
            while(s.top() != -1 && arr[s.top()] >= curr)
            {
                s.pop();
            }
            //ans is stack ka top
            ans[i] = s.top();
            s.push(i);
        }
        return ans;
    }
    vector<int> prevSmallerElement(int* arr, int n) {
        stack<int> s;
        s.push(-1);
        vector<int> ans(n);

        for(int i=0; i<n; i++) {
            int curr = arr[i];
            while(s.top() != -1 && arr[s.top()] >= curr)
            {
                s.pop();
            }
            //ans is stack ka top
            ans[i] = s.top();
            s.push(i);
        }
        return ans; 
    }    
  int largestRectangleArea(int* heights, int n) {
        //int n= heights.size();
        vector<int> next(n);
        next = nextSmallerElement(heights, n);
        vector<int> prev(n);
        prev = prevSmallerElement(heights, n);
        int area = INT_MIN;
        for(int i=0; i<n; i++) {
            int l = heights[i];
            
            if(next[i] == -1) {
                next[i] = n;
            }
             int b = next[i] - prev[i] - 1;
            int newArea = l*b;
            area = max(area, newArea);
        }
        return area;
    }
  public:
    int maxArea(int M[MAX][MAX], int n, int m) {
        //compute area for first row
        int area = largestRectangleArea(M[0], m);
        for(int i = 1; i<n; i++) {
            for(int j = 0; j<m; j++) {   
                //row udpate: by adding previous row's value
                if(M[i][j] != 0)
                    M[i][j] = M[i][j] + M[i-1][j];
                else
                    M[i][j] = 0;
            }
            //entire row is updated now
            area = max(area, largestRectangleArea(M[i],m));
            
        }
        return area;
    }
};

// N stacks

#include <bits/stdc++.h> 
class NStack
{
    int *arr;
    int *top;
    int *next;
    int n, s;
    int freespot;
public:
    // Initialize your data structure.
    NStack(int N, int S)
    {
        n = N;
        s = S;
        arr = new int[s];
        top = new int[n];
        next = new int[s];
        //top initialise
        for(int i=0; i<n; i++) {
            top[i] = -1;
        }
        //next initialise
        for (int i = 0; i < s; i++) {
          next[i] = i + 1;
        }
        // update last index value to -1
        next[s - 1] = -1;
        // initialise freespot
        freespot = 0;
    }
    // Pushes 'X' into the Mth stack. Returns true if it gets pushed into the stack, and false otherwise.
    bool push(int x, int m)
    {
        //check for overflow
        if(freespot == -1) {
            return false;
        }   
        //find index
        int index = freespot;
        //insert element into array
        arr[index] = x;
        //update freespot
        freespot = next[index];
        //update next;
        next[index] = top[m-1];
        //update top
        top[m-1] = index;
        return true;
    }
    // Pops top element from Mth Stack. Returns -1 if the stack is empty, otherwise returns the popped element.
    int pop(int m)
    {
        //check underflow condition
        if(top[m-1] == -1) {
            return -1;
        }   
        int index= top[m-1];
        top[m-1] = next[index];
        next[index] = freespot;
        freespot = index;
        return arr[index];
    }
};

// Get minimum element from the stack

#include<stack>
#include<limits.h>
class SpecialStack {
    stack<int> s;
    int mini = INT_MAX;
    public:  
    void push(int data) {
        //for first element
        if(s.empty()) {
            s.push(data);
            mini = data;
        }
        else
        {
         	if(data < mini) {
                s.push(2*data - mini);
                mini = data;
            }   
            else
            {
                s.push(data);
            }
        }
    }
    int pop() {
        if(s.empty()){
            return -1;
        }
        int curr = s.top();
        s.pop();
        if(curr > mini) {
            return curr;
        }
        else
        {
            int prevMin = mini;
            int val = 2*mini - curr;
            mini = val;
            return prevMin;
        }
    }
    int top() {
        if(s.empty())
            return -1;
        
        int curr = s.top();
        if(curr < mini) {
            return mini;
        }
        else
        {
            return curr;
        }
    }
    bool isEmpty() {
        return s.empty();
    }
    int getMin() {
        if(s.empty())
            return -1;
        
        return mini;
    }  
};

// Implementation of queue using STL

// #include<iostream>
// #include<queue>
// using namespace std;
// int main(){
//     queue<int> q;   
//     q.push(10);
//     cout<<"Front of queue is: "<<q.front()<<endl;;
//     q.push(7);
//     q.push(3);
//     cout<<"Size of the queue is: "<<q.size()<<endl;
//     q.pop();
//     cout<<"Front of queue is: "<<q.front()<<endl;
//     cout<<"Size of the queue is: "<<q.size()<<endl;
//     if(q.empty()){
//         cout<<"Queue is empty "<<endl;
//     }
//     else{
//         cout<<"Queue is not empty "<<endl;
//     }
//     return 0;
// }

// Implementation of queue using arrays

// #include <bits/stdc++.h> 
// class Queue {
//     int* arr;
//     int qfront;
//     int rear;
//     int size;
// public:
//     Queue() {
//         size = 100001;
//         arr = new int[size];
//         qfront = 0;
//         rear = 0;
//     }
//     bool isEmpty() {
//         if(qfront == rear){
//             return true;
//         }
//         else{
//           return false;
//         }
//     }
//     void enqueue(int data) {
//         if(rear == size){
//            cout<< "Queue is Full"<<endl;
//         }
//         else{
//             arr[rear]=data;
//             rear++;
//         }
//     }
//     int dequeue() {
//         if(qfront ==rear){
//             return -1;
//         }
//         else{
//             int ans = arr[qfront];
//             arr[qfront]= -1;
//             qfront++;
//               if(qfront ==rear){
//                 qfront = 0;
//                 rear = 0;
//             }
//             return ans;
//         }
//     }
//     int front() {
//        if(qfront ==rear){
//            return -1; 
//        }
//        else{
//            return arr[qfront];
//        }
//     }
// };

// Implementation of queue using linked list

// #include <bits/stdc++.h>
// using namespace std;
// struct QNode {
//     int data;
//     QNode* next;
//     QNode(int d){
//         data = d;
//         next = NULL;
//     }
// };
// struct Queue {
//     QNode *front, *rear;
//     Queue() { front = rear = NULL; }
//     void enQueue(int x){
//         // Create a new LL node
//         QNode* temp = new QNode(x);
//         // If queue is empty, then new node is front and rear both
//         if (rear == NULL) {
//             front = rear = temp;
//             return;
//         }
//         // Add the new node at the end of queue and change rear
//         rear->next = temp;
//         rear = temp;
//     }
//     // Function to remove a key from given queue q
//     void deQueue(){
//         // If queue is empty, return NULL.
//         if (front == NULL)
//             return;
//         // Store previous front and move front one node ahead
//         QNode* temp = front;
//         front = front->next;
//         // If front becomes NULL, then change rear also as NULL
//         if (front == NULL)
//             rear = NULL;
//         delete (temp);
//     }
// };
// int main(){
//     Queue q;
//     q.enQueue(10);
//     q.enQueue(20);
//     q.deQueue();
//     q.deQueue();
//     q.enQueue(30);
//     q.enQueue(40);
//     q.enQueue(50);
//     q.deQueue();
//     cout << "Queue Front : " << ((q.front != NULL) ? (q.front)->data : -1)<< endl;
//     cout << "Queue Rear : " << ((q.rear != NULL) ? (q.rear)->data : -1);
// }

// Circular Queue using array

#include <bits/stdc++.h> 
class CircularQueue{
    int size;
    int front;
    int rear;
    int *arr;
    public:
    CircularQueue(int n){
        size = n;
        arr = new int[size];
        front = -1;
        rear  =  -1;
    }
    // Enqueues 'X' into the queue. Returns true if it gets pushed into the stack, and false otherwise.
    bool enqueue(int value){
        if((front==0 && rear==size-1) || (rear == (front-1)%(size-1))){
            return false;
        }
        else if(front==-1){
            front=0; 
            rear=0;
        }
        else if(rear==size-1 && front!=0){
            rear = 0;
        }
        else{
            rear++;
        }
        arr[rear] = value;
        return true;
    }
    // Dequeues top element from queue. Returns -1 if the stack is empty, otherwise returns the popped element.
    int dequeue(){
        if(front==-1){
            return -1;
        }
        int ans=arr[front];
        arr[front]=-1;
        if(front==rear){
            front=-1;
            rear=-1;
        }
        else if(front==size-1){
            front=0;
        }
        else{
            front++;
        }
        return ans;
    }
};

// Circular queue using linked list

class MyCircularQueue {
public:
    int head, tail, size;
    vector<int> q;
    
    MyCircularQueue(int k) : head(-1), tail(-1), size(k), q(k) {}
    
    bool enQueue(int value) {
        if (isFull()) return false;
        if (tail == -1) head = tail = 0;
        else tail = (tail+1) % size;
        q[tail] = value;
        return true;
    }
    
    bool deQueue() {
        if (isEmpty()) return false;
        if (head == tail) head = tail = -1;
        else head = (head+1) % size;
        return true;
    }
    
    int Front() {
        return (isEmpty()) ? -1 : q[head];
    }
    
    int Rear() {
        return (isEmpty()) ? -1 : q[tail];
    }
    
    bool isEmpty() {
        return (head == -1);
    }
    
    bool isFull() {
        return ((head == 0 && tail == size-1) || (tail == head-1)); 
    }
};

// Input restricted queue

#include <iostream>
using namespace std;
// Maximum size of array or Input Restricted Queue
#define MAX 100

// A structure to represent a Input Restricted Queue
class Deque{
    int arr[MAX];
    int front;
    int rear;
    int size;
public:
    Deque(int size){
        front = -1;
        rear = 0;
        this->size = size;
    }
    // Operations on Input Restricted Queue
    void insertrear(int key);
    void deletefront();
    void deleterear();
    bool isFull();
    bool isEmpty();
    int getFront();
    int getRear();
};
// Checks whether Input Restricted Queue is full or not.
bool Deque::isFull()
{
    return ((front == 0 && rear == size - 1) || front == rear + 1);
}
// Checks whether Input Restricted Queue is empty or not.
bool Deque::isEmpty() { 
    return (front == -1); 
}
// function to inset element at rear end of Input Restricted Queue
void Deque::insertrear(int key)
{
    if (isFull())
    {
        cout << " Overflow\n " << endl;
        return;
    }
    // If queue is initially empty
    if (front == -1)
    {
        front = 0;
        rear = 0;
    }
    // Rear is at last position of queue
    else if (rear == size - 1)
        rear = 0;
    // Increment rear end by '1'
    else
        rear = rear + 1;
    // Insert current element into Deque
    arr[rear] = key;
}
// Deletes element at front end of Input Restricted Queue
void Deque::deletefront()
{
    // Check whether Deque is empty or not
    if (isEmpty())
    {
        cout << "Queue Underflow\n"
             << endl;
        return;
    }
    // Deque has only one element
    if (front == rear)
    {
        front = -1;
        rear = -1;
    }
    else
        // Back to initial position
        if (front == size - 1)
            front = 0;
        else
            // Increment front by '1' to remove current front value from Deque
            front = front + 1;
}
// Delete element at rear end of Input Restricted Queue
void Deque::deleterear()
{
    if (isEmpty())
    {
        cout << " Underflow\n"
             << endl;
        return;
    }
    // Deque has only one element
    if (front == rear)
    {
        front = -1;
        rear = -1;
    }
    else if (rear == 0)
        rear = size - 1;
    else
        rear = rear - 1;
}
// Returns front element of Input Restricted Queue
int Deque::getFront()
{
    // Check whether Deque is empty or not
    if (isEmpty())
    {
        cout << " Underflow\n"
             << endl;
        return -1;
    }
    return arr[front];
}
// Function return rear element of Input Restricted Queue
int Deque::getRear()
{
    // Check whether Deque is empty or not
    if (isEmpty() || rear < 0)
    {
        cout << " Underflow\n"
             << endl;
        return -1;
    }
    return arr[rear];
}
int main()
{
    Deque dq(5);
    // Function calls
    cout << "Insert element at rear end : 5 \n";
    dq.insertrear(5);
    cout << "insert element at rear end : 10 \n";
    dq.insertrear(10);
    cout << "insert element at rear end : 15 \n";
    dq.insertrear(15);
    cout << "Get rear element : "
         << " " << dq.getRear() << endl;
    dq.deleterear();
    cout << "After delete rear element new rear"
         << " become : " << dq.getRear() << endl;
    cout << "Get front element : " << dq.getFront() << endl;
    dq.deletefront();
    cout << "After delete front element new "
         << "front become : " << dq.getFront() << endl;
    return 0;
}

// Output restricted queue

#include <iostream>
using namespace std;
// Maximum size of array or Output Restricted Queue
#define MAX 100
// A structure to represent a Output Restricted Queue
class Deque
{
    int arr[MAX];
    int front;
    int rear;
    int size;
public:
    Deque(int size)
    {
        front = -1;
        rear = 0;
        this->size = size;
    }
    // Operations on Output Restricted Queue
    void insertfront(int key);
    void insertrear(int key);
    void deletefront();
    bool isFull();
    bool isEmpty();
    int getFront();
    int getRear();
};
// Checks whether Output Restricted Queue is full or not.
bool Deque::isFull()
{
    return ((front == 0 && rear == size - 1) || front == rear + 1);
}
// Checks whether Output Restricted Queue is empty or not.
bool Deque::isEmpty()
{
    return (front == -1);
}
// Function to insert element at front end of Output Restricted Queue
void Deque::insertfront(int key)
{
    // Check whether Deque if full or not
    if (isFull())
    {
        cout << "Overflow\n"
             << endl;
        return;
    }
    // If queue is initially empty
    if (front == -1)
    {
        front = 0;
        rear = 0;
    }
    // Front is at first position of queue
    else if (front == 0)
        front = size - 1;
    else
        // Decrement front end by '1'
        front = front - 1;
    // Insert current element into Deque
    arr[front] = key;
}
// Function to insert element at rear end of Output Restricted Queue
void Deque::insertrear(int key)
{
    if (isFull())
    {
        cout << " Overflow\n " << endl;
        return;
    }
    // If queue is initially empty
    if (front == -1)
    {
        front = 0;
        rear = 0;
    }
    // Rear is at last position of queue
    else if (rear == size - 1)
        rear = 0;
    // Increment rear end by '1'
    else
        rear = rear + 1;
    // Insert current element into Deque
    arr[rear] = key;
}
// Deletes element at front end of Output Restricted Queue
void Deque::deletefront()
{
    // Check whether Deque is empty or not
    if (isEmpty())
    {
        cout << "Queue Underflow\n"
             << endl;
        return;
    }
    // Deque has only one element
    if (front == rear)
    {
        front = -1;
        rear = -1;
    }
    else
        // Back to initial position
        if (front == size - 1)
            front = 0;
        else
            // Increment front by '1' to remove current front value from Deque
            front = front + 1;
}
// Returns front element of Output Restricted Queue
int Deque::getFront()
{
    // Check whether Deque is empty or not
    if (isEmpty())
    {
        cout << " Underflow\n"
             << endl;
        return -1;
    }
    return arr[front];
}
// Function to return rear element of Output Restricted Queue
int Deque::getRear()
{
    // Check whether Deque is empty or not
    if (isEmpty() || rear < 0)
    {
        cout << " Underflow\n"
             << endl;
        return -1;
    }
    return arr[rear];
}
int main()
{
    Deque dq(5);
    // Function calls
    cout << "Inserted element at rear end : 10 \n";
    dq.insertrear(10);
    cout << "Inserted element at rear end : 15 \n";
    dq.insertrear(15);
    cout << "Inserted element at front end : 5 \n";
    dq.insertfront(5);
    cout << "Get rear element : "
         << " " << dq.getRear() << endl;
    cout << "Get front element : " << dq.getFront() << endl;
    dq.deletefront();
    cout << "After delete front element new "
         << "front become : " << dq.getFront() << endl;
    return 0;
}

// Doubly Ended Queue (Deque)

#include <bits/stdc++.h>
class Deque
{
public:
    int *arr;
    int front;
    int rear;
    int size;
    // Initialize your data structure.
    Deque(int n)
    {
        size = n;
        front = -1;
        rear = -1;
        arr = new int[n];
    }
    // Pushes 'X' in the front of the deque. Returns true if it gets pushed into the deque, and false otherwise.
    bool pushFront(int x)
    {
        if (isFull())
        {
            // if full queue || if rear is just before the front
            return false;
        }
        else if (isEmpty()) // if insert first element
        {
            front = rear = 0;
        }
        else if (front == 0 && rear != size - 1)
        {
            front = size - 1;
        }
        else
        {
            front--;
        }
        arr[front] = x;
        return true;
    }
    // Pushes 'X' in the back of the deque. Returns true if it gets pushed into the deque, and false otherwise.
    bool pushRear(int x)
    {
        if (isFull())
        {
            // if full queue || if rear is just before the front
            return false;
        }
        else if (isEmpty()) // if insert first element
        {
            front = rear = 0;
        }
        else if (rear == size - 1 && front != 0)
        {
            rear = 0;
        }
        else
        {
            rear++;
        }
        arr[rear] = x;
        return true;
    }
    // Pops an element from the front of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.
    int popFront()
    {
        if (isEmpty())
        {
            return -1;
        }
        int ans = arr[front];
        arr[front] = -1;
        if (front == rear)
        {
            front = -1;
            rear = -1;
        }
        else if (front == size - 1)
        {
            front = 0;
        }
        else
            front++;
        return ans;
    }
    // Pops an element from the back of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.
    int popRear()
    {
        if (isEmpty())
            return -1;
        int ans = arr[rear];
        arr[rear] = -1;
        if (front == rear)
        {
            front = -1;
            rear = -1;
        }
        else if (rear == 0)
        {
            rear = size - 1;
        }
        else
            rear--;
        return ans;
    }
    // Returns the first element of the deque. If the deque is empty, it returns -1.
    int getFront()
    {
        if (isEmpty())
        {
            return -1;
        }
        return arr[front];
    }
    // Returns the last element of the deque. If the deque is empty, it returns -1.
    int getRear()
    {
        if (isEmpty())
        {
            return -1;
        }
        return arr[rear];
    }
    // Returns true if the deque is empty. Otherwise returns false.
    bool isEmpty()
    {
        if (front == -1)
            return true;
        return false;
    }
    // Returns true if the deque is full. Otherwise returns false.
    bool isFull(){
        if ((front == 0 && rear == size - 1) || (front != 0 && rear == (front - 1) % (size - 1)))
            return true;
        return false;
    }
};

// Queue Reversal 

// Method-1
queue<int> rev(queue<int> q)
{
    stack<int> s;
    while(!q.empty()){
        int element=q.front();
        q.pop();
        s.push(element);
    }
    while(!s.empty()){
        int element=s.top();
        s.pop();
        q.push(element);
    }
    return q;
}

// Method-2
void sol(queue<int>& q,queue<int>& s)
{
    if(q.empty())
        return ;
    int val = q.front();
    q.pop();
    sol(q,s);
    s.push(val);  
}
queue<int> rev(queue<int> q)
{
    queue<int> s;
    sol(q,s);
    return s;
}

// First negative integer in every window of size k

vector<long long> printFirstNegativeInteger(long long int A[], long long int N, long long int K) {
         deque<long long int> dq;
         vector<long long> ans;
         int negative = -1;  
         //process first window
         for(int i=0; i<K; i++) {
             if(A[i] < 0) {
                 dq.push_back(i);
             }
         }    
         //push ans for FIRST window
         if(dq.size() > 0) {
             ans.push_back(A[dq.front()]);
         }
         else
         {
             ans.push_back(0);
         }
         //now process for remaining windows
         for(int i = K; i<N; i++) {
             //first pop out of window element
             if(!dq.empty() && (i - dq.front())>=K ) {
                 dq.pop_front();
             }
             //then push current element
             if(A[i] < 0)
                dq.push_back(i);
            // put in ans
            if(dq.size() > 0) {
                 ans.push_back(A[dq.front()]);
            }
            else
            {
                ans.push_back(0);
            }
         }
         return ans;
 }
 
 // Reverse First K elements of Queue
 
queue<int> modifyQueue(queue<int> q, int k) {
    //algo:
    //first k element stack me daaldo  and queue se hatado
    // k element stack se nikalke wapas queue me daalde 
    // fer queue k (n-k) starting k elements, wapas queue me daalde
    stack<int> s;
    for(int i = 0; i<k; i++) {
        int val = q.front();
        q.pop();
        s.push(val);
    }
    while(!s.empty()) {
        int val = s.top();
        s.pop();
        q.push(val);
    }
    int t = q.size()-k;
    while(t--) {
        int val = q.front();
        q.pop();
        q.push(val);
    }
    return q;
}

// First non-repeating character in a stream

class Solution {
	public:
		string FirstNonRepeating(string A){
           unordered_map<char,int> mp;
           queue<char> q;
           string ans = "";
           
           for(int i = 0; i < A.length(); i++)
           {
               char ch = A[i];
               mp[ch]++;
               q.push(ch);
               
               while(!q.empty())
               {
                   if(mp[q.front()] > 1)
                        q.pop();
                    else{
                        ans.push_back(q.front());
                        break;
                    }
               }
               
               if(q.empty())
                    ans.push_back('#');
           }
           return ans;
        }
};
 
// Circular tour

class Solution{
public:
    //Function to find starting point where the truck can start to get through
    //the complete circle without exhausting its petrol in between.
    int tour(petrolPump p[],int n)
    {
       int deficit = 0;
       int balance = 0;
       int start = 0;
       for(int i=0; i<n; i++) {
           balance += p[i].petrol - p[i].distance;
           if(balance < 0) {
               start = i+1;
               deficit += balance;
               balance = 0;
           }
       }
       if(balance + deficit >=0) 
            return start;
        return -1;
    }
};

// Interleave the firt half of the queue with the second half

// Method-1
#include <bits/stdc++.h> 
void interLeaveQueue(queue < int > & q) {
    queue<int> newq;
    int n=q.size()/2;
    while(n--){
        newq.push(q.front());
        q.pop();
    }
    while(!newq.empty()){
        q.push(newq.front());
        newq.pop();
        int ele=q.front();
        q.pop();
        q.push(ele);
    }
}

// Method-2
#include <bits/stdc++.h> 
void interLeaveQueue(queue < int > & q) {
    stack<int> s;
    int n=q.size()/2;
    int count=0;
    while(count<n){
        s.push(q.front());
        q.pop();
        count++;
    }
    while(!s.empty()){
        q.push(s.top());
        s.pop();
    }
    count=0;
    while(count<n){
        int ele=q.front();
        q.push(ele);
        q.pop();
        count++;
    }
    count=0;
    while(count<n){
        s.push(q.front());
        q.pop();
        count++;
    }
    while(!s.empty()){
        int stackele=s.top();
        s.pop();
        q.push(stackele);
        int qele= q.front();
        q.pop();
        q.push(qele);
    }

}

// How to efficiently implement k Queues in a single array?

https://www.geeksforgeeks.org/efficiently-implement-k-queues-single-array/
#include <iostream>
#include <queue>
using namespace std;
class kQueue
{
public:
    int n;
    int k;
    int *arr;
    int *front;
    int *rear;
    int freespot;
    int *next;

public:
    kQueue(int n, int k)
    {
        this->n = n;
        this->k = k;
        front = new int[k];
        rear = new int[k];
        for (int i = 0; i < k; i++)
        {
            front[i] = -1;
            rear[i] = -1;
        }
        next = new int[n];
        for (int i = 0; i < n; i++)
        {
            next[i] = i + 1;
        }
        next[n - 1] = -1;
        arr = new int[n];
        freespot = 0;
    }
    void enqueue(int data,int qn){
        // overflow
        if(freespot==-1){
            cout<<"No empty space is present "<<endl;
            return;
        }
        // find first free index
        int index=freespot;
        // update freespot
        freespot=next[index];
        // check whether first element
        if(front[qn-1]==-1){
            front[qn-1]=index;
        }
        // link new element to the previous element
        else{
            next[rear[qn-1]]=index;
        } 
        // update next
        next[index]=-1;
        // update rear
        rear[qn-1]=index;
        // push element
        arr[index]=data;
    }
    int dequeue(int qn){
        // underflow
        if(front[qn-1]==-1){
            cout<<"Queue underflow"<<endl;
            return -1;
        }
        // find index to pop
        int index=front[qn-1];
        // front ko aage badhao
        front[qn-1]=next[index];
        // freeslots ko manage karo
        next[index]=freespot;
        freespot=index;
        return arr[index];
    }
};
int main()
{
    kQueue q(10,3);
    q.enqueue(10,1);
    q.enqueue(15,1);
    q.enqueue(20,2);
    q.enqueue(25,1);
    // cout<<q.dequeue(1)<<endl;
    // cout<<q.dequeue(2)<<endl;
    // cout<<q.dequeue(1)<<endl;
    // cout<<q.dequeue(1)<<endl; // output -> 10 20 15 25
    cout<<q.dequeue(1)<<endl;
    cout<<q.dequeue(2)<<endl;
    cout<<q.dequeue(1)<<endl;
    cout<<q.dequeue(1)<<endl;
    cout<<q.dequeue(1)<<endl; // output -> 10 20 15 25 Queue underflow -1
    return 0;
}

// Sum of minimum and maximum elements of all subarrays of size k.

#include<iostream>
#include<queue>
using namespace std;
int solve(int *arr, int n, int k) {
    deque<int> maxi(k);
    deque<int> mini(k);
    //Addition of first k size window
    for(int i=0; i<k; i++) {
        while(!maxi.empty() && arr[maxi.back()] <= arr[i])
            maxi.pop_back();
        while(!mini.empty() && arr[mini.back()] >= arr[i])
            mini.pop_back();
        maxi.push_back(i);
        mini.push_back(i);
    }
    int ans = 0;
    ans += arr[maxi.front()] + arr[mini.front()];
    //remaining windows ko process karlo
    for(int i=k; i<n; i++) {
        //next window
        //removal
        while(!maxi.empty() && i - maxi.front() >=k) {
            maxi.pop_front();
        }
        while(!mini.empty() && i - mini.front() >=k) {
            mini.pop_front();
        }
        //addition
        while(!maxi.empty() && arr[maxi.back()] <= arr[i])
            maxi.pop_back();
        while(!mini.empty() && arr[mini.back()] >= arr[i])
            mini.pop_back();
        maxi.push_back(i);
        mini.push_back(i);    
        ans += arr[maxi.front()] + arr[mini.front()];
    }
    return ans;
}

// Level Order Traversal in Binary Tree

#include <iostream>
#include <queue>
#include <stack>
using namespace std;
class node
{
public:
    int data;
    node *left;
    node *right;
    node(int d)
    {
        this->data = d;
        this->left = NULL;
        this->right = NULL;
    }
};
node *buildTree(node *root)
{
    int data;
    cout << "Enter the data:" << endl;
    cin >> data;
    root = new node(data);
    if (data == -1)
    {
        return NULL;
    }
    cout << "Enter the data for inserting in left of " << data << endl;
    root->left = buildTree(root->left);
    cout << "Enter the data for inserting in right of " << data << endl;
    root->right = buildTree(root->right);
    return root;
}
node *levelOrderTraversal(node *root)
{
    queue<node *> q;
    q.push(root);
    q.push(NULL);
    while (!q.empty())
    {
        node *temp = q.front();
        q.pop();
        if (temp == NULL)
        { // purana level complete traverse ho chuka hai
            cout << endl;
            if (!q.empty())
            { // queue still has some child nodes
                q.push(NULL);
            }
        }
        else
        {
            cout << temp->data << " ";
            if (temp->left)
            {
                q.push(temp->left);
            }
            if (temp->right)
            {
                q.push(temp->right);
            }
        }
    }
}
int main()
{
    node *root = NULL;
    // creating a tree
    root = buildTree(root);
    // level order
    cout << "Printing the level order traversal output " << endl;
    levelOrderTraversal(root);
    return 0;
}

// Reverse Level Order Traversal in Binary Tree

#include <iostream>
#include <queue>
#include <stack>
using namespace std;
class node
{
public:
    int data;
    node *left;
    node *right;
    node(int d)
    {
        this->data = d;
        this->left = NULL;
        this->right = NULL;
    }
};
node *buildTree(node *root)
{
    int data;
    cout << "Enter the data:" << endl;
    cin >> data;
    root = new node(data);
    if (data == -1)
    {
        return NULL;
    }
    cout << "Enter the data for inserting in left of " << data << endl;
    root->left = buildTree(root->left);
    cout << "Enter the data for inserting in right of " << data << endl;
    root->right = buildTree(root->right);
    return root;
}
void reverseLevelTraversal(node *root)
{
    queue<node *> q;
    q.push(root);
    q.push(NULL);
    // q.push(NULL);
    stack<node *> s;
    while (!q.empty())
    {
        node *temp = q.front();
        s.push(temp);
        q.pop();
        if (temp == NULL)
        {
            if (!q.empty())
            {
                q.push(NULL);
            }
        }
        else
        {
            if (temp->right)
            {
                q.push(temp->right);
            }
            if (temp->left)
            {
                q.push(temp->left);
            }
        }
    }
    while (!s.empty())
    {
        node *temp = s.top();
        s.pop();
        if (temp == NULL)
        {
            cout << endl;
        }
        else
        {
            cout << temp->data << " ";
        }
    }
}
int main()
{
    node *root = NULL;
    // creating a tree
    root = buildTree(root);
    // reverse level order
    cout << "Printing the reverse level order traversal output " << endl;
    reverseLevelTraversal(root);
    return 0;
}

// Inorder Level Traversal in Binary Tree (Left Node Right [LNR] )

// Method-1 ( Recursively )
#include <iostream>
#include <queue>
#include <stack>
using namespace std;
class node
{
public:
    int data;
    node *left;
    node *right;
    node(int d)
    {
        this->data = d;
        this->left = NULL;
        this->right = NULL;
    }
};
node *buildTree(node *root)
{
    int data;
    cout << "Enter the data:" << endl;
    cin >> data;
    root = new node(data);
    if (data == -1)
    {
        return NULL;
    }
    cout << "Enter the data for inserting in left of " << data << endl;
    root->left = buildTree(root->left);
    cout << "Enter the data for inserting in right of " << data << endl;
    root->right = buildTree(root->right);
    return root;
}
void inOrderTraversal(node *root){
    if(root==NULL){
        return;
    }
    inOrderTraversal(root->left);
    cout<<root->data<<" ";
    inOrderTraversal(root->right);
}
int main()
{
    node *root = NULL;
    // creating a tree
    root = buildTree(root);
    // inorder traversal
    inOrderTraversal(root);
    return 0;
}

// Method-2 ( Iteratively )
#include <iostream>
#include <queue>
#include <stack>
using namespace std;
class node
{
public:
    int data;
    node *left;
    node *right;
    node(int d)
    {
        this->data = d;
        this->left = NULL;
        this->right = NULL;
    }
};
node *buildTree(node *root)
{
    int data;
    cout << "Enter the data:" << endl;
    cin >> data;
    root = new node(data);
    if (data == -1)
    {
        return NULL;
    }
    cout << "Enter the data for inserting in left of " << data << endl;
    root->left = buildTree(root->left);
    cout << "Enter the data for inserting in right of " << data << endl;
    root->right = buildTree(root->right);
    return root;
}
void inOrderTraversal(node *root)
{
    stack<node *> s;
    node *curr = root;
    while (curr != NULL || s.empty() == false)
    {
        // Reach the leftmost node of the curr node
        while (curr != NULL)
        {
            // place pointer to a tree node on the stack before traversing the node's left subtree
            s.push(curr);
            curr = curr->left;
        }
        // curr must be NULL at this point
        curr = s.top();
        s.pop();
        cout << curr->data << " ";
        // we have visited the node and ist left subtree. Now, its right subtree turn
        curr = curr->right;
    }
}
int main()
{
    node *root = NULL;
    // creating a tree
    root = buildTree(root);
    // inorder traversal
    inOrderTraversal(root);
    return 0;
}

// Preorder Level Traversal in Binary Tree ( Node Left Right [NLR] )

// Method-1 ( Recursively )
#include <iostream>
#include <queue>
#include <stack>
using namespace std;
class node
{
public:
    int data;
    node *left;
    node *right;
    node(int d)
    {
        this->data = d;
        this->left = NULL;
        this->right = NULL;
    }
};
node *buildTree(node *root)
{
    int data;
    cout << "Enter the data:" << endl;
    cin >> data;
    root = new node(data);
    if (data == -1)
    {
        return NULL;
    }
    cout << "Enter the data for inserting in left of " << data << endl;
    root->left = buildTree(root->left);
    cout << "Enter the data for inserting in right of " << data << endl;
    root->right = buildTree(root->right);
    return root;
}
void PreOrderTraversal(node *root){
    if(root==NULL){
        return;
    }
    cout<<root->data<<" ";
    PreOrderTraversal(root->left);
    PreOrderTraversal(root->right);
}
int main()
{
    node *root = NULL;
    // creating a tree
    root = buildTree(root);
    // preorder traversal
    PreOrderTraversal(root);
    return 0;
}

// Method-2 ( Iteratively )
#include <iostream>
#include <queue>
#include <stack>
using namespace std;
class node
{
public:
    int data;
    node *left;
    node *right;
    node(int d)
    {
        this->data = d;
        this->left = NULL;
        this->right = NULL;
    }
};
node *buildTree(node *root)
{
    int data;
    cout << "Enter the data:" << endl;
    cin >> data;
    root = new node(data);
    if (data == -1)
    {
        return NULL;
    }
    cout << "Enter the data for inserting in left of " << data << endl;
    root->left = buildTree(root->left);
    cout << "Enter the data for inserting in right of " << data << endl;
    root->right = buildTree(root->right);
    return root;
}
void PreOrderTraversal(node *root)
{
    if (root == NULL)
        return;
    stack<node *> st;
    // start from root node (set current node to root node)
    node *curr = root;
    // run till stack is not empty or current is not NULL
    while (!st.empty() || curr != NULL)
    {
        // Print left children while exist and keep pushing right into the stack.
        while (curr != NULL)
        {
            cout << curr->data << " ";

            if (curr->right)
            {
                st.push(curr->right);
            }
            curr = curr->left;
        }
        // We reach when curr is NULL, so We take out a right child from stack
        if (st.empty() == false)
        {
            curr = st.top();
            st.pop();
        }
    }
}
int main()
{
    node *root = NULL;
    // creating a tree
    root = buildTree(root);
    // preorder traversal
    PreOrderTraversal(root);
    return 0;
}

// Postorder Level Traversal in Binary Tree ( Left Right Node [LRN] )

// Method-1 ( Recursively )
#include <iostream>
#include <queue>
#include <stack>
using namespace std;
class node
{
public:
    int data;
    node *left;
    node *right;
    node(int d)
    {
        this->data = d;
        this->left = NULL;
        this->right = NULL;
    }
};
node *buildTree(node *root)
{
    int data;
    cout << "Enter the data:" << endl;
    cin >> data;
    root = new node(data);
    if (data == -1)
    {
        return NULL;
    }
    cout << "Enter the data for inserting in left of " << data << endl;
    root->left = buildTree(root->left);
    cout << "Enter the data for inserting in right of " << data << endl;
    root->right = buildTree(root->right);
    return root;
}
void PostOrderTraversal(node *root){
    if(root==NULL){
        return;
    }
    PostOrderTraversal(root->left);
    PostOrderTraversal(root->right);
    cout<<root->data<<" ";
}
int main()
{
    node *root = NULL;
    // creating a tree
    root = buildTree(root);
    // postorder traversal
    PostOrderTraversal(root);
    return 0;
}

// Method-2 ( Iteratively )
#include <iostream>
#include <queue>
#include <stack>
using namespace std;
class node
{
public:
    int data;
    node *left;
    node *right;
    node(int d)
    {
        this->data = d;
        this->left = NULL;
        this->right = NULL;
    }
};
node *buildTree(node *root)
{
    int data;
    cout << "Enter the data:" << endl;
    cin >> data;
    root = new node(data);
    if (data == -1)
    {
        return NULL;
    }
    cout << "Enter the data for inserting in left of " << data << endl;
    root->left = buildTree(root->left);
    cout << "Enter the data for inserting in right of " << data << endl;
    root->right = buildTree(root->right);
    return root;
}
void PostOrderTraversal(node *root)
{
    if (root == NULL)
        return;
    // Create two stacks
    stack<node *> s1, s2;
    // push root to first stack
    s1.push(root);
    node *curr;
    // Run while first stack is not empty
    while (!s1.empty())
    {
        // Pop an item from s1 and push it to s2
        curr = s1.top();
        s1.pop();
        s2.push(curr);
        // Push left and right children of removed item to s1
        if (curr->left)
            s1.push(curr->left);
        if (curr->right)
            s1.push(curr->right);
    }
    // Print all elements of second stack
    while (!s2.empty())
    {
        curr = s2.top();
        s2.pop();
        cout << curr->data << " ";
    }
}
int main()
{
    node *root = NULL;
    // creating a tree
    root = buildTree(root);
    // postorder traversal
    PostOrderTraversal(root);
    return 0;
}

// Build a tree

#include <iostream>
#include <queue>
#include <stack>
using namespace std;
class node
{
public:
    int data;
    node *left;
    node *right;
    node(int d)
    {
        this->data = d;
        this->left = NULL;
        this->right = NULL;
    }
};
node *buildTree(node *root)
{
    int data;
    cout << "Enter the data:" << endl;
    cin >> data;
    root = new node(data);
    if (data == -1)
    {
        return NULL;
    }
    cout << "Enter the data for inserting in left of " << data << endl;
    root->left = buildTree(root->left);
    cout << "Enter the data for inserting in right of " << data << endl;
    root->right = buildTree(root->right);
    return root;
}
node *levelOrderTraversal(node *root)
{
    queue<node *> q;
    q.push(root);
    q.push(NULL);
    while (!q.empty())
    {
        node *temp = q.front();
        q.pop();
        if (temp == NULL)
        { // purana level complete traverse ho chuka hai
            cout << endl;
            if (!q.empty())
            { // queue still has some child nodes
                q.push(NULL);
            }
        }
        else
        {
            cout << temp->data << " ";
            if (temp->left)
            {
                q.push(temp->left);
            }
            if (temp->right)
            {
                q.push(temp->right);
            }
        }
    }
}
void buildFromLevelOrder(node *&root)
{
    queue<node *> q;
    cout << "Enter data for root:" << endl;
    int data;
    cin >> data;
    root = new node(data);
    q.push(root);
    while (!q.empty())
    {
        node *temp = q.front();
        q.pop();
        cout << "Enter left node for " << temp->data << endl;
        int leftData;
        cin >> leftData;
        if (leftData != -1)
        {
            temp->left = new node(leftData);
            q.push(temp->left);
        }
        cout << "Enter right node for " << temp->data << endl;
        int rightData;
        cin >> rightData;
        if (rightData != -1)
        {
            temp->right = new node(rightData);
            q.push(temp->right);
        }
    }
}
int main()
{
    node *root = NULL;
    buildFromLevelOrder(root);
    levelOrderTraversal(root);
    return 0;
}

// Count leaf nodes

void inOrderTraversal(BinaryTreeNode<int> *root, int &count) {
  // base case
  if (root == NULL) {
    return;
  }
  // leaf node
  inOrderTraversal(root->left, count);
  if (root->left == NULL && root->right == NULL) {
    count++;
  }
  inOrderTraversal(root->right, count);
}
int noOfLeafNodes(BinaryTreeNode<int> *root) {
  int count = 0;
  inOrderTraversal(root, count);
  return count;
}

// Height of binary tree ( Max depth of binary tree )

class Solution{
    public:
    int height(struct Node* node){
        //base case
        if(node==NULL){
            return 0;
        }
        int left=height(node->left);
        int right=height(node->right);
        int ans=max(left,right)+1;
        return ans;
    }
};

// Diameter of binary tree

// Method-1
class Solution{
    public:
    int height(Node*root)
    {   
    	 if(root==NULL)
         {
         return 0;
         }
         int h1=height(root->left);
         int h2=height(root->right);
         return (max(h1,h2)+1);
     }
    int diameter(Node* root) {
        if(root==NULL)
        {
            return 0;
        }
        int h1=height(root->left);
        int h2=height(root->right);
        int op1=h1+h2+1;
        int op2=diameter(root->left);
        int op3=diameter(root->right);
        return (max(op1,(max(op2,op3))));
    }
};

// Method-2
class Solution
{
public:
    pair<int,int> diameterFast(Node *root){
        if(root == NULL){
            pair<int,int>p = make_pair(0,0);
            return p;
        }
        pair<int,int> left = diameterFast(root->left);
        pair<int,int> right = diameterFast(root->right);
        
        int op1 = left.first;
        int op2 = right.first;
        int op3 = left.second + right.second + 1;
        
        pair<int,int>ans;
        ans.first = max(op1,max(op2,op3));
        ans.second = max(left.second, right.second)+1;
        return ans;
    }
    int diameter(Node* root) {
        
        return diameterFast(root).first;
    }
};

// Check for balanced tree

// Method-1
class Solution
{
public:
    int height(struct Node *node)
    {
        if (node == NULL)
        {
            return 0;
        }
        int left = height(node->left);
        int right = height(node->right);
        int ans = max(left, right) + 1;
        return ans;
    }
    bool isBalanced(Node *root)
    {
        if (root == NULL)
        {
            return 1;
        }
        bool left = isBalanced(root->left);
        bool right = isBalanced(root->right);
        bool diff = abs(height(root->left) - height(root->right)) <= 1;
        if (left && right && diff)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
};

// Method-2
class Solution
{
public:
    class Solution {
public:
    pair<bool,int> isBalancedFast(TreeNode *root){
        if(root == NULL){
            pair<bool,int> p = make_pair(true,0);
            return p;
        }
        pair<int,int> left = isBalancedFast(root->left);
        pair<int,int> right = isBalancedFast(root->right);
        
        bool leftAns=left.first;
        bool rightAns=right.first;
        
        bool diff = abs(left.second - right.second) <= 1;
        
        pair<bool,int> ans;
        ans.second=max(left.second,right.second)+1;
        
        if (leftAns && rightAns && diff)
        {
            ans.first=1;
        }
        else
        {
            ans.first=0;
        }
        
        return ans;
    }
    bool isBalanced(TreeNode* root) {
        return isBalancedFast(root).first;
    }
};

// Determine if two trees are identical or not

class Solution
{
    public:
    bool isIdentical(Node *r1, Node *r2)
    {
        if(r1==NULL && r2==NULL){
            return true;
        }
        if(r1==NULL && r2!=NULL){ 
            return false;
        }
        if(r1!=NULL && r2==NULL){ 
            return false;
        }
        if(r1->data!=r2->data){
            return false;
        }
        else{
            return (isIdentical(r1->left,r2->left) && isIdentical(r1->right,r2->right));
        }
    }
};

// Sum tree

// Method-1
int sumTree(TreeNode<int> *root) {
    if(root == NULL) return 0;
    return root->val + sumTree(root->left) + sumTree(root->right);
} 
bool isSumTree(TreeNode<int> *root)
{
    if(root == NULL) return true;
    if(root->left == NULL && root->right == NULL) return true;
    if(isSumTree(root->left) && isSumTree(root->right)) {
        int l = sumTree(root->left);
        int r = sumTree(root->right);
        if(root->val == (l+r)) return true;
        return false;
    }
    return false;
}

// Method-2
class Solution
{
    public:
    pair<bool,int> solve(Node* root){
        if(root==NULL){
            pair<bool,int>p=make_pair(true,0);
            return p;
        }
        if(root->left==NULL && root->right==NULL){
        pair<bool,int>p=make_pair(true,root->data);
        return p;
        }
        pair<bool,int> leftans=solve(root->left);
        pair<bool,int> rightans=solve(root->right);
        bool l=leftans.first;
        bool r=rightans.first;
        bool condn=root->data==leftans.second+ rightans.second;
        pair<bool,int> ans;
        if(l&&r&&condn){
            ans.first=true;
            ans.second=2*root->data;
        }
        else{
            ans.first=false;
        }
        return ans;   
    }
    bool isSumTree(Node* root)
    {
         return solve(root).first;
    }
};

// Zig-Zag Traversal Of Binary Tree

class Solution
{
public:
    vector<int> zigZagTraversal(Node *root)
    {
        vector<int> result;
        if (root == NULL)
        {
            return result;
        }
        queue<Node *> q;
        q.push(root);
        bool leftToRight = true;
        while (!q.empty())
        {
            int size = q.size();
            vector<int> ans(size);
            // level process
            for (int i = 0; i < size; i++)
            {
                Node *frontNode = q.front();
                q.pop();
                // normal insert or revrse insert
                int index = leftToRight ? i : size - i - 1;
                ans[index] = frontNode->data;
                if (frontNode->left)
                {
                    q.push(frontNode->left);
                }
                if (frontNode->right)
                {
                    q.push(frontNode->right);
                }
            }
            // direction change karni hai
            leftToRight = !leftToRight;
            for (auto i : ans)
            {
                result.push_back(i);
            }
        }
        return result;
    }
};

// Boundary Traversal Of Binary Tree

class Solution {
public:
    void traverseLeft(Node* root, vector<int> &ans) {
        //base case
        if( (root == NULL) || (root->left == NULL && root->right == NULL) )
            return ;
            
        ans.push_back(root->data);
        if(root->left)
            traverseLeft(root->left, ans);
        else
            traverseLeft(root->right, ans);
            
    }
    
    void traverseLeaf(Node* root, vector<int> &ans) {
        //base case
        if(root == NULL)
            return ;
            
        if(root->left == NULL && root->right == NULL) {
            ans.push_back(root->data);
            return;
        }
        
        traverseLeaf(root->left, ans);
        traverseLeaf(root->right, ans);
        
    }
    
    void traverseRight(Node* root, vector<int> &ans) {
        //base case
        if( (root == NULL) || (root->left == NULL && root->right == NULL) )
            return ;
        
        if(root->right)
            traverseRight(root->right, ans);
        else
            traverseRight(root->left, ans);
            
        //wapas aagye
        ans.push_back(root->data);
            
    }
    
    vector <int> boundary(Node *root)
    {
        vector<int> ans;
        if(root == NULL)
            return ans;
            
        ans.push_back(root->data);
        
        //left part print/store
        traverseLeft(root->left, ans);
        
        //traverse Leaf Nodes
        
        //left subtree
        traverseLeaf(root->left, ans);
        //right subtree
        traverseLeaf(root->right, ans);
        
        //traverse right part
        traverseRight(root->right, ans);
        
        return ans;
    }
};

// Vertical Order Traversal Of Binary Tree

class Solution
{
    public:
    vector<int> verticalOrder(Node *root)
    {
        map<int, map<int,vector<int> > > nodes;
        queue< pair<Node*, pair<int,int> > > q;
        vector<int> ans;
        
        if(root == NULL)
            return ans;
            
        q.push(make_pair(root, make_pair(0,0)));
        
        while(!q.empty()) {
            pair<Node*, pair<int,int> > temp = q.front();
            q.pop();
            Node* frontNode = temp.first;
            int hd = temp.second.first;
            int lvl = temp.second.second;
            
            nodes[hd][lvl].push_back(frontNode->data);
            
            if(frontNode->left)
                q.push(make_pair(frontNode->left, make_pair(hd-1, lvl+1) ));
                
            if(frontNode->right)
                q.push(make_pair(frontNode->right, make_pair(hd+1, lvl+1)));
        }
        
        for(auto i: nodes) {
            
            for(auto j:i.second) {
                
                for(auto k:j.second)
                {
                    ans.push_back(k);
                }
            }
        }
        return ans;
    }
};

// Top View of the Binary Tree

class Solution
{
    public:
    //Function to return a list of nodes visible from the top view 
    //from left to right in Binary Tree.
    vector<int> topView(Node *root)
    {
        vector<int> ans;
        if(root == NULL) 
        {
            return ans;
        }
        
        map<int,int> topNode;
        queue<pair<Node*, int> > q;
        
        q.push(make_pair(root, 0));
        
        while(!q.empty()) {
            pair<Node*, int> temp = q.front();
            q.pop();
            Node* frontNode = temp.first;
            int hd = temp.second;
            
            //if one value is present for a HD, then do nothing
            if(topNode.find(hd) == topNode.end())
                topNode[hd] = frontNode -> data;
                
            if(frontNode->left)
                q.push(make_pair(frontNode->left, hd-1));
            if(frontNode->right)
                q.push(make_pair(frontNode->right, hd+1));
        }
        
        for(auto i:topNode) 
        {
            ans.push_back(i.second);
        }
        return ans;
    }
};

// Bottom View of the Binary Tree

class Solution {
  public:
    vector <int> bottomView(Node *root) {
         vector<int> ans;
        if(root == NULL) 
        {
            return ans;
        }
        
        map<int,int> topNode;
        queue<pair<Node*, int> > q;
        
        q.push(make_pair(root, 0));
        
        while(!q.empty()) {
            pair<Node*, int> temp = q.front();
            q.pop();
            Node* frontNode = temp.first;
            int hd = temp.second;
            
            topNode[hd] = frontNode -> data;
                
            if(frontNode->left)
                q.push(make_pair(frontNode->left, hd-1));
            if(frontNode->right)
                q.push(make_pair(frontNode->right, hd+1));
        }
        
        for(auto i:topNode) 
        {
            ans.push_back(i.second);
        }
        return ans;
    }
};

// Left View of the Binary Tree

void solve(Node *root, vector<int> &ans, int level)
{
    // base case
    if (root == NULL)
    {
        return;
    }
    // we entered into a new level
    if (level == ans.size())
    {
        ans.push_back(root->data);
    }
    solve(root->left, ans, level + 1);
    solve(root->right, ans, level + 1);
}
vector<int> leftView(Node *root)
{
    vector<int> ans;
    solve(root, ans, 0);
    return ans;
}

// Right View of the Binary Tree

class Solution
{
    public:
    void solve(Node *root, vector<int> &ans, int level)
    {
        // base case
        if (root == NULL)
        {
            return;
        }
        // we entered into a new level
        if (level == ans.size())
        {
            ans.push_back(root->data);
        }
        solve(root->right, ans, level + 1);
        solve(root->left, ans, level + 1);
    }
    vector<int> rightView(Node *root)
    {
        vector<int> ans;
        solve(root, ans, 0);
        return ans;
    }
};

// Diagonal Traversal in Binary tree

vector<int> diagonal(Node *root)
{
   vector<int>ans;
   if(root==NULL)
   {
       return ans;
   }  
   queue<Node*>q;
   q.push(root);
   while(!q.empty())
   {
       Node* temp=q.front();
       q.pop();
       ans.push_back(temp->data);
       if(temp->left)
       {
           q.push(temp->left);
       }
       while(temp->right!=NULL)
       {
           temp=temp->right;
           ans.push_back(temp->data);
           if(temp->left)
           {
               q.push(temp->left);
           }
       }
   }
   return ans;
}

// Sum of the Longest Bloodline of a Tree (Sum of nodes on the longest path from root to leaf node)

class Solution
{
public:
    void solve(Node *root,int sum,int &maxSum,int len,int &maxLen){
        // base case
        if(root==NULL){
            if(len>maxLen){
                maxLen=len;
                maxSum=sum;
            }
            else if(len==maxLen){
                maxSum=max(sum,maxSum);
            }
            return;
        }
        sum=sum+root->data;
        solve(root->left,sum,maxSum,len+1,maxLen);
        solve(root->right,sum,maxSum,len+1,maxLen);
    }
    int sumOfLongRootToLeafPath(Node *root)
    {
        int len=0,maxLen=0,sum=0,maxSum=INT_MIN;
        solve(root,sum,maxSum,len,maxLen);
        return maxSum;
    }
};

// Lowest Common Ancestor in a Binary Tree

class Solution
{
    public:
    //Function to return the lowest common ancestor in a Binary Tree.
    Node* lca(Node* root ,int n1 ,int n2 )
    {
        // base case
        if(root==NULL){
            return NULL;
        }
        if(root->data==n1 || root->data==n2){
            return root;
        }
        Node *leftAns=lca(root->left,n1,n2);
        Node *rightAns=lca(root->right,n1,n2);
        if(leftAns!=NULL && rightAns!=NULL){
            return root;
        }
        else if(leftAns!=NULL && rightAns==NULL){
            return leftAns;
        }
        else if(leftAns==NULL && rightAns!=NULL){
            return rightAns;
        }
        else{
            return NULL;
        }
    }
};

// K sum paths

class Solution{
    public:
    void check(Node *root, int k, int &count, int sum, unordered_map<int, int> &mp) {
        if(root == NULL) 
            return;
        sum += root->data;
        count += mp[sum-k];
        if(sum == k)
            count++;
        mp[sum]++;
        check(root->left, k, count, sum, mp);
        check(root->right, k, count, sum, mp);   
        mp[sum]--;
    }
    int sumK(Node *root,int k)
    { 
        int count = 0;
        unordered_map<int, int> mp;
        check(root, k, count, 0, mp);
        return count;
    }
};

// Kth ancestor in a binary tree 

// Method-1
bool solve(Node *root,int &k, int node,int &ans){
    if(root == NULL) return false;
    
    if(root->data == node) return true;
    bool left = solve(root->left,k,node,ans);
    bool right = solve(root->right, k,node,ans);
    
    if(left||right){
        k--;
        if(k==0) ans = root->data;
        return true;
    }
    return false;
}
int kthAncestor(Node *root, int k, int node)
{
    int ans;
    solve(root,k,node,ans);
    if(k>0) return -1;         // If k is greater than required distance b/w nodes.
    return ans;
}

// Method-2
Node* solve(Node* root,int &k,int node){
    if(root==NULL){
        return NULL;
    }
    if(root->data==node){
        return root;
    }
    Node *leftAns=solve(root->left,k,node);
    Node *rightAns=solve(root->right,k,node);
    if(leftAns!=NULL && rightAns==NULL){
        k--;
        if(k==0){
            k=INT_MAX;
            return root;
        }
        return leftAns;
    }
    if(leftAns==NULL && rightAns!=NULL){
        k--;
        if(k==0){
            k=INT_MAX;
            return root;
        }
        return rightAns;
    }
    return NULL;
}
int kthAncestor(Node *root, int k, int node)
{
    Node* ans=solve(root,k,node);
    if((ans==NULL) || (ans->data==node)){
        return -1;   
    }
    else{
        return ans->data;
    }
}

// Maximum sum of non-adjacent nodes

class Solution{
  public:
    pair<int,int> solve(Node *root){
        if(root==NULL){
            pair<int,int> p=make_pair(0,0);
            return p;
        }
        pair<int,int> left=solve(root->left);
        pair<int,int> right=solve(root->right);
        pair<int,int> res;
        res.first=root->data+left.second+right.second;
        res.second=max(left.first,left.second)+max(right.first,right.second);
        return res;
    }
    int getMaxSum(Node *root) 
    {
        pair<int,int> ans=solve(root);
        return max(ans.first,ans.second);
    }
};

// Construct Tree from given Inorder and Preorder traversals

// Method-1
class Solution{
    public:
    int findposition(int in[],int element,int start,int end)
    {
        for(int i=start;i<=end;i++)
        {
            if(in[i]==element)
            return i;
        }
        return -1;
    }
    Node* solve(int in[],int pre[],int &index,int inorderstart,int inorderend,int n)
    {
        if(index>=n || inorderstart >inorderend){
            return NULL;
        }
        
        int element = pre[index++];
        Node* root = new Node(element);
        int position = findposition(in,element,inorderstart,inorderend);
        
        root->left=solve(in,pre,index,inorderstart,position-1,n);
        root->right=solve(in,pre,index,position+1,inorderend,n);
        
        return root;
    }
    Node* buildTree(int in[],int pre[], int n)
    {
        int preorderindex=0;
        Node* ans = solve(in,pre,preorderindex,0,n-1,n);
        return ans;
    }
};

// Method-2
class Solution{
    public:
    Node* solve(int in[], int pre[], int n, int &index, int s, int e, unordered_map<int, vector<int>> &m){
        if(index>=n || s>e)
            return NULL;
            
            int element = pre[index++];
            Node* root = new Node(element);
            int pos = -1;
            if(m[element][0] == INT_MIN){
                 pos = m[element][1];
                m[element][1] = INT_MIN;
            }
            else{
                pos = m[element][0];
                m[element][0] = INT_MIN;
            }
                
            root->left = solve(in, pre, n, index, s, pos-1, m);
            root->right = solve(in, pre, n, index, pos+1, e, m);
            
            return root;
    }
    
    Node* buildTree(int in[],int pre[], int n)
    {
        unordered_map<int, vector<int>>index;
        for(int i= 0; i<n; i++)
            index[in[i]].push_back(i);
            
            int preindex = 0;
            return solve(in, pre, n, preindex, 0, n-1, index);
    }
};

// Construct Tree from given Inorder and Postorder traversals

// Method-1
Node* solve(int in[], int post[], int inStart, int inEnd, int postStart, int postEnd) {
    if(inStart > inEnd){
        return NULL;
    }
    Node* root = new Node(post[postEnd]);
    int i = inStart;
    for(; i<= inEnd; i++) {
        if(in[i] == root->data)
            break;
    }
    int leftSize  = i - inStart;
    int rightSize = inEnd - i;
    root->left  = solve(in, post, inStart, i-1, postStart, postStart + leftSize - 1);
    root->right = solve(in, post, i+1, inEnd, postEnd - rightSize, postEnd-1);
    return root;
}
Node *buildTree(int in[], int post[], int n) {
    return solve(in, post, 0, n-1, 0, n-1);
}

// Method-2
Node*solve(int in[], int post[], int &index,int s,int e,int n,unordered_map<int,int>&mp)
{
    if(index<0 || s>e){
        return NULL;
    }
    int element=post[index--];
    Node*root=new Node(element);
    int pos=mp[element];
    root->right=solve(in,post,index,pos+1,e,n,mp);
    root->left=solve(in,post,index,s,pos-1,n,mp);
    return root;
}
Node *buildTree(int in[], int post[], int n) {
    unordered_map<int,int>mp;
    for(int i=0;i<n;i++)
    {
        mp[in[i]]=i;
    }
    int index=n-1;
    return solve(in,post,index,0,n-1,n,mp);
}

// Minimum Time To Burn A Tree

class Solution {
  public:
    // create mapping and return target node
    Node* createParentMapping(Node* root, int target,map<Node*,Node*> &nodeToParent){
        Node* res=NULL;
        queue<Node*> q;
        q.push(root);
        nodeToParent[root]=NULL;
        while(!q.empty()){
            Node* front=q.front();
            q.pop();
            if(front->data==target){
                res=front;
            }
            if(front->left){
                nodeToParent[front->left]=front;
                q.push(front->left);
            }
            if(front->right){
                nodeToParent[front->right]=front;
                q.push(front->right);
            }
        }
        return res;
    }
    int burnTree(Node* root,map<Node*,Node*> &nodeToParent){
        map<Node*,bool> visited;
        queue<Node*> q;
        q.push(root);
        visited[root]=true;
        int ans=0;
        while(!q.empty()){
            bool flag=0;
            int size=q.size();
            for(int i=0;i<size;i++){
                // processing neighbouring nodes
                Node* front=q.front();
                q.pop();
                if(front->left && !visited[front->left]){
                    flag=true;
                    q.push(front->left);
                    visited[front->left]=1;
                }
                if(front->right && !visited[front->right]){
                    flag=true;
                    q.push(front->right);
                    visited[front->right]=1;
                }
                if(nodeToParent[front] && !visited[nodeToParent[front]]){
                    flag=true;
                    q.push(nodeToParent[front]);
                    visited[nodeToParent[front]]=1;
                }
            }
            if(flag==1){
                ans++;
            }
        }
        return ans;
    }
    int minTime(Node* root, int target) 
    {
        map<Node*,Node*> nodeToParent;
        Node* targetNode=createParentMapping(root,target,nodeToParent);
        int ans=burnTree(targetNode,nodeToParent);
        return ans;
    }
};

// Morris Traversal ( T.C. => O(n) , S.C. => O(1) )

// Morris traversal for inorder traversal

#include <iostream>
using namespace std;
/* Node Structure in a threaded binary tree */
struct Node
{
    int value;
    struct Node *left;
    struct Node *right;
};
/* Function to traverse the binary tree without using any additional space */
void Morris(struct Node *root)
{
    struct Node *current, *prev;
    if (root == NULL)
        return;
    current = root;
    while (current != NULL)
    {
        if (current->left == NULL)
        {
            cout << current->value << "\t";
            current = current->right;
        }
        else
        {
            /* Find the previous node of the current node */
            prev = current->left;
            while (prev->right != NULL && prev->right != current)
                prev = prev->right;
            /* Make current node as the right child of its previous node */
            if (prev->right == NULL)
            {
                prev->right = current;
                current = current->left;
            }
            /* fix the right child of previous */
            else
            {
                prev->right = NULL;
                cout << current->value << "\t";
                current = current->right;
            }
        }
    }
}
/* Function allocates a new Node with the given value and the left and right pointers to NULL. */
struct Node *add_node(int value)
{
    struct Node *node = new Node;
    node->value = value;
    node->left = NULL;
    node->right = NULL;

    return (node);
}
int main()
{
    struct Node *root = add_node(20);
    root->left = add_node(40);
    root->right = add_node(60);
    root->left->left = add_node(80);
    root->left->right = add_node(100);
    Morris(root);
    return 0;
}

// Morris traversal for Preorder traversal
#include <bits/stdc++.h>
using namespace std;
class node
{
	public:
	int data;
	node *left, *right;
};
// Helper function that allocates a new node with the given data and NULL left and right pointers. 
node* newNode(int data)
{
	node* temp = new node();
	temp->data = data;
	temp->left = temp->right = NULL;
	return temp;
}
// Preorder traversal without recursion and without stack
void morrisTraversalPreorder(node* root)
{
	while (root)
	{
		// If left child is null, print the current node data. Move to right child.
		if (root->left == NULL)
		{
			cout<<root->data<<" ";
			root = root->right;
		}
		else
		{
			// Find inorder predecessor
			node* current = root->left;
			while (current->right && current->right != root)
				current = current->right;
			// If the right child of inorder predecessor already points to this node
			if (current->right == root)
			{
				current->right = NULL;
				root = root->right;
			}
			// If right child doesn't point to this node, then print this node and make right child point to this node
			else
			{
				cout<<root->data<<" ";
				current->right = root;
				root = root->left;
			}
		}
	}
}
// Function for Standard preorder traversal
void preorder(node* root)
{
	if (root)
	{
		cout<<root->data<<" ";
		preorder(root->left);
		preorder(root->right);
	}
}
int main()
{
	node* root = NULL;
	root = newNode(1);
	root->left = newNode(2);
	root->right = newNode(3);
	root->left->left = newNode(4);
	root->left->right = newNode(5);
	root->right->left = newNode(6);
	root->right->right = newNode(7);
	root->left->left->left = newNode(8);
	root->left->left->right = newNode(9);
	root->left->right->left = newNode(10);
	root->left->right->right = newNode(11);
	morrisTraversalPreorder(root);
	cout<<endl;
	preorder(root);
	return 0;
}

// Morris traversal for Postorder traversal

#include <bits/stdc++.h>
using namespace std;
struct TreeNode {
	int key;
	TreeNode* left;
	TreeNode* right;
	TreeNode(int data)
	{
		key = data;
		left = NULL;
		right = NULL;
	}
};
// Function to print vector
void print(vector<int>& ans)
{
	// Print the vector elements
	for (auto x : ans) {
		cout << x << " ";
	}
}
// Postorder traversal Without recursion and without stack
vector<int> postorderTraversal(TreeNode* root)
{
	vector<int> res;
	TreeNode* current = root;
	while (current != NULL) {
		// If right child is null, put the current node data in res. Move to left child.
		if (current->right == NULL) {
			res.push_back(current->key);
			current = current->left;
		}
		else {
			TreeNode* predecessor = current->right;
			while (predecessor->left != NULL
				&& predecessor->left != current) {
				predecessor = predecessor->left;
			}
			// If left child doesn't point to this node, then put in res this node and make left child point to this node
			if (predecessor->left == NULL) {
				res.push_back(current->key);
				predecessor->left = current;
				current = current->right;
			}
			// If the left child of inorder predecessor already points to this node
			else {
				predecessor->left = NULL;
				current = current->left;
			}
		}
	}
	// reverse the res
	reverse(res.begin(), res.end());
	return res;
}
int main()
{
	TreeNode* root = new TreeNode(10);
	root->left = new TreeNode(20);
	root->right = new TreeNode(30);
	root->right->left = new TreeNode(40);
	root->right->right = new TreeNode(50);
	cout << "Morris(postorder) Traversal: ";
	vector<int> ans = postorderTraversal(root);
	print(ans);
	return 0;
}

// Flatten a binary tree to Linked List

class Solution
{
    public:
    void flatten(Node *root)
    {
        Node* curr=root;
        while(curr!=NULL)
        {
            if(curr->left)
            {
                Node* pred=curr->left;
                while(pred->right){
                    pred=pred->right;
                }
                pred->right=curr->right;
                curr->right=curr->left;
                curr->left=NULL;
            }
            curr=curr->right;
        }   
    }
};

// Insertion in Binary Search Tree ( LevelOrder, ReverseLevelOrder, Inorder, Preorder, Postorder Traversals )

#include<iostream>
#include<queue>
#include<stack>
using namespace std;
class Node{
    public:
        int data;
        Node* left;
        Node* right;
    Node(int d){
        this->data=d;
        this->left=NULL;
        this->right=NULL;
    }
};
Node* levelOrderTraversal(Node *root)
{
    queue<Node *> q;
    q.push(root);
    q.push(NULL);
    while (!q.empty())
    {
        Node *temp = q.front();
        q.pop();
        if (temp == NULL)
        { // purana level complete traverse ho chuka hai
            cout << endl;
            if (!q.empty())
            { // queue still has some child nodes
                q.push(NULL);
            }
        }
        else
        {
            cout << temp->data << " ";
            if (temp->left)
            {
                q.push(temp->left);
            }
            if (temp->right)
            {
                q.push(temp->right);
            }
        }
    }
}
void reverseLevelTraversal(Node *root)
{
    queue<Node*> q;
    q.push(root);
    q.push(NULL);
    // q.push(NULL);
    stack<Node *> s;
    while (!q.empty())
    {
        Node *temp = q.front();
        s.push(temp);
        q.pop();
        if (temp == NULL)
        {
            if (!q.empty())
            {
                q.push(NULL);
            }
        }
        else
        {
            if (temp->right)
            {
                q.push(temp->right);
            }
            if (temp->left)
            {
                q.push(temp->left);
            }
        }
    }
    while (!s.empty())
    {
        Node *temp = s.top();
        s.pop();
        if (temp == NULL)
        {
            cout << endl;
        }
        else
        {
            cout << temp->data << " ";
        }
    }
}
void inOrderTraversal(Node *root){
    if(root==NULL){
        return;
    }
    inOrderTraversal(root->left);
    cout<<root->data<<" ";
    inOrderTraversal(root->right);
}
void PreOrderTraversal(Node *root){
    if(root==NULL){
        return;
    }
    cout<<root->data<<" ";
    PreOrderTraversal(root->left);
    PreOrderTraversal(root->right);
}
void PostOrderTraversal(Node *root){
    if(root==NULL){
        return;
    }
    PostOrderTraversal(root->left);
    PostOrderTraversal(root->right);
    cout<<root->data<<" ";
}
Node* insertIntoBST(Node* root,int d){
    if(root==NULL){
        root=new Node(d);
        return root;
    }
    if(d>root->data){
        // right part me insert karna hai
        root->right=insertIntoBST(root->right,d);
    }
    else{
        // left part me insert karna hai
        root->left=insertIntoBST(root->left,d);
    }
    return root;
}
void takeInput(Node* &root){
    int data;
    cin>>data;
    while(data!=-1){
        root=insertIntoBST(root,data);
        cin>>data;
    }
}
int main(){
    Node* root=NULL;
    cout<<"Enter data to create BST"<<endl;
    takeInput(root);
    cout<<"Level Order Traversal"<<endl;
    levelOrderTraversal(root);
    cout<<"Reverse Level Order Traversal "<<endl;
    reverseLevelTraversal(root);
    cout<<endl;
    cout<<"InOrder Traversal ";
    inOrderTraversal(root);
    cout<<endl;
    cout<<"PreOrder Traversal ";
    PreOrderTraversal(root);
    cout<<endl;
    cout<<"PostOrder Traversal ";
    PostOrderTraversal(root);
    cout<<endl;
    return 0;
}

// Search In BST

// Method-1
bool searchInBST(BinaryTreeNode<int> *root, int x) {
    if(root==NULL){
    	return false;
    }
    if(root->data==x){
    	return true;
    }
    if(root->data < x){
    	return searchInBST(root->right,x);
    }
    else{
    	return searchInBST(root->left,x);
    }
}

// Method-2
bool searchInBST(BinaryTreeNode<int> *root, int x) {
    BinaryTreeNode<int> *temp=root;
    while(temp!=NULL){
        if(temp->data==x){
            return true;
        }
        if(x > temp->data){
            temp=temp->right;
        } 
        else {
            temp=temp->left;
        }
    }
    return false;
}

// Maximum and Minimum element

#include<iostream>
#include<queue>
#include<stack>
using namespace std;
class Node{
    public:
        int data;
        Node* left;
        Node* right;
    Node(int d){
        this->data=d;
        this->left=NULL;
        this->right=NULL;
    }
};
Node* levelOrderTraversal(Node *root)
{
    queue<Node *> q;
    q.push(root);
    q.push(NULL);
    while (!q.empty())
    {
        Node *temp = q.front();
        q.pop();
        if (temp == NULL)
        { // purana level complete traverse ho chuka hai
            cout << endl;
            if (!q.empty())
            { // queue still has some child nodes
                q.push(NULL);
            }
        }
        else
        {
            cout << temp->data << " ";
            if (temp->left)
            {
                q.push(temp->left);
            }
            if (temp->right)
            {
                q.push(temp->right);
            }
        }
    }
}
void reverseLevelTraversal(Node *root)
{
    queue<Node*> q;
    q.push(root);
    q.push(NULL);
    // q.push(NULL);
    stack<Node *> s;
    while (!q.empty())
    {
        Node *temp = q.front();
        s.push(temp);
        q.pop();
        if (temp == NULL)
        {
            if (!q.empty())
            {
                q.push(NULL);
            }
        }
        else
        {
            if (temp->right)
            {
                q.push(temp->right);
            }
            if (temp->left)
            {
                q.push(temp->left);
            }
        }
    }
    while (!s.empty())
    {
        Node *temp = s.top();
        s.pop();
        if (temp == NULL)
        {
            cout << endl;
        }
        else
        {
            cout << temp->data << " ";
        }
    }
}
void inOrderTraversal(Node *root){
    if(root==NULL){
        return;
    }
    inOrderTraversal(root->left);
    cout<<root->data<<" ";
    inOrderTraversal(root->right);
}
void PreOrderTraversal(Node *root){
    if(root==NULL){
        return;
    }
    cout<<root->data<<" ";
    PreOrderTraversal(root->left);
    PreOrderTraversal(root->right);
}
void PostOrderTraversal(Node *root){
    if(root==NULL){
        return;
    }
    PostOrderTraversal(root->left);
    PostOrderTraversal(root->right);
    cout<<root->data<<" ";
}
Node* minVal(Node* root){
    Node* temp=root;
    while(temp->left!=NULL){
        temp=temp->left;
    }
    return temp;
}
Node* maxVal(Node* root){
    Node* temp=root;
    while(temp->right!=NULL){
        temp=temp->right;
    }
    return temp;
}
Node* insertIntoBST(Node* root,int d){
    if(root==NULL){
        root=new Node(d);
        return root;
    }
    if(d>root->data){
        // right part me insert karna hai
        root->right=insertIntoBST(root->right,d);
    }
    else{
        // left part me insert karna hai
        root->left=insertIntoBST(root->left,d);
    }
    return root;
}
void takeInput(Node* &root){
    int data;
    cin>>data;
    while(data!=-1){
        root=insertIntoBST(root,data);
        cin>>data;
    }
}
int main(){
    Node* root=NULL;
    cout<<"Enter data to create BST"<<endl;
    takeInput(root);
    cout<<"Level Order Traversal"<<endl;
    levelOrderTraversal(root);
    cout<<"Reverse Level Order Traversal "<<endl;
    reverseLevelTraversal(root);
    cout<<endl;
    cout<<"InOrder Traversal ";
    inOrderTraversal(root);
    cout<<endl;
    cout<<"PreOrder Traversal ";
    PreOrderTraversal(root);
    cout<<endl;
    cout<<"PostOrder Traversal ";
    PostOrderTraversal(root);
    cout<<endl;
    cout<<"Maximum Element: " << maxVal(root)->data <<endl;
    cout<<"Minimum Element: " << minVal(root)->data <<endl;
    return 0;
}

// Predecessor and Successor

// Find predecessor and successor in a BST

#include <iostream>
using namespace std;
// BST Node
struct Node
{
	int key;
	struct Node *left;
	struct Node *right;
	
	Node(int x){
	    key = x;
	    left = NULL;
	    right = NULL;
	}
};
int key=0;
// This function finds predecessor and successor of key in BST.
// It sets pre and suc as predecessor and successor respectively
void findPreSuc(Node* root, Node*& pre, Node*& suc, int key);
 void insert(struct Node *root,int n1,int n2,char lr)
 {
     if(root==NULL)
        return;
     if(root->key==n1)
     {
         switch(lr)
         {
          case 'L': root->left=new Node(n2);
                    break;
          case 'R': root->right=new Node(n2);
                    break;
         }
     }
     else
     {
         insert(root->left,n1,n2,lr);
         insert(root->right,n1,n2,lr);
     }
 }
// Driver program to test above functions
int main()
{
    /* Let us construct the tree shown in above diagram */
    int t,k;
    cin>>t;
    while(t--)
    {
    int n;
    cin>>n;
    struct Node *root=NULL;
    Node *pre=NULL;
    Node *suc=NULL;
    while(n--)
    {
        char lr;
        int n1,n2;
        cin>>n1>>n2;
        cin>>lr;
        if(root==NULL)
        {
            root=new Node(n1);
            switch(lr){
                    case 'L': root->left=new Node(n2);
                    break;
                    case 'R': root->right=new Node(n2);
                    break;
                    }
        }
        else
        {
            insert(root,n1,n2,lr);
        }
    }
   // Inorder(root);
    //Node * target =ptr;
    //printkdistanceNode(root, target, k);
    //cout<<endl;
    cin>>key;
    findPreSuc(root, pre, suc, key);
	if (pre != NULL)
	cout << pre->key;
	else
	cout << "-1";

	if (suc != NULL)
	cout <<" "<<suc->key<<endl;
	else
	cout << " "<<"-1"<<endl;
    }
	return 0;
}
// BST Node
struct Node
{
	int key;
	struct Node *left, *right;
};

Node *successor(Node *root, int key){
    Node *suc = NULL;
    while(root != NULL){
        if(key >= root->key){
            root = root->right;
        }
        else{
            suc = root;
            root = root->left;
        }
    }
    return suc;
}
Node *precessor(Node *root, int key){
    Node *pre = NULL;
    while(root != NULL){
        if(key <= root->key){
            root = root->left;
        }
        else{
            pre = root;
            root = root->right;
        }
    }
    return pre;
 }
// It sets pre and suc as predecessor and successor respectively
void findPreSuc(Node* root, Node*& pre, Node*& suc, int key)
{
    suc = successor(root,key);
    pre = precessor(root,key);
}

// Deletion in BST

#include<iostream>
#include<queue>
#include<stack>
using namespace std;
class Node{
    public:
        int data;
        Node* left;
        Node* right;
    Node(int d){
        this->data=d;
        this->left=NULL;
        this->right=NULL;
    }
};
Node* levelOrderTraversal(Node *root)
{
    queue<Node *> q;
    q.push(root);
    q.push(NULL);
    while (!q.empty())
    {
        Node *temp = q.front();
        q.pop();
        if (temp == NULL)
        { // purana level complete traverse ho chuka hai
            cout << endl;
            if (!q.empty())
            { // queue still has some child nodes
                q.push(NULL);
            }
        }
        else
        {
            cout << temp->data << " ";
            if (temp->left)
            {
                q.push(temp->left);
            }
            if (temp->right)
            {
                q.push(temp->right);
            }
        }
    }
}
void reverseLevelTraversal(Node *root)
{
    queue<Node*> q;
    q.push(root);
    q.push(NULL);
    // q.push(NULL);
    stack<Node *> s;
    while (!q.empty())
    {
        Node *temp = q.front();
        s.push(temp);
        q.pop();
        if (temp == NULL)
        {
            if (!q.empty())
            {
                q.push(NULL);
            }
        }
        else
        {
            if (temp->right)
            {
                q.push(temp->right);
            }
            if (temp->left)
            {
                q.push(temp->left);
            }
        }
    }
    while (!s.empty())
    {
        Node *temp = s.top();
        s.pop();
        if (temp == NULL)
        {
            cout << endl;
        }
        else
        {
            cout << temp->data << " ";
        }
    }
}
void inOrderTraversal(Node *root){
    if(root==NULL){
        return;
    }
    inOrderTraversal(root->left);
    cout<<root->data<<" ";
    inOrderTraversal(root->right);
}
void PreOrderTraversal(Node *root){
    if(root==NULL){
        return;
    }
    cout<<root->data<<" ";
    PreOrderTraversal(root->left);
    PreOrderTraversal(root->right);
}
void PostOrderTraversal(Node *root){
    if(root==NULL){
        return;
    }
    PostOrderTraversal(root->left);
    PostOrderTraversal(root->right);
    cout<<root->data<<" ";
}
Node* minVal(Node* root){
    Node* temp=root;
    while(temp->left!=NULL){
        temp=temp->left;
    }
    return temp;
}
Node* maxVal(Node* root){
    Node* temp=root;
    while(temp->right!=NULL){
        temp=temp->right;
    }
    return temp;
}
Node* deleteFromBST(Node* root,int val){
    if(root==NULL){
        return root;
    }
    if(root->data==val){
        // 0 child
        if(root->right==NULL && root->left==NULL){
            delete root;
            return NULL;
        }
        //1 child
        
        // left child
        if(root->left!=NULL && root->right==NULL){
            Node* temp=root->left;
            delete root;
            return temp;
        }
        // right child
        if(root->left==NULL && root->right!=NULL){
            Node* temp=root->right;
            delete root;
            return temp;
        }
        // 2 child
        if(root->left!=NULL && root->right!=NULL){
            int mini=minVal(root->right)->data;
            root->data=mini;
            root->right=deleteFromBST(root->right,mini);
            return root;
        }
    }
    else if(root->data > val){
        // left part me jana hai
        root->left=deleteFromBST(root->left,val);
    }
    else{
        // right part me jana hai
        root->right=deleteFromBST(root->right,val);
    }
}
Node* insertIntoBST(Node* root,int d){
    if(root==NULL){
        root=new Node(d);
        return root;
    }
    if(d>root->data){
        // right part me insert karna hai
        root->right=insertIntoBST(root->right,d);
    }
    else{
        // left part me insert karna hai
        root->left=insertIntoBST(root->left,d);
    }
    return root;
}
void takeInput(Node* &root){
    int data;
    cin>>data;
    while(data!=-1){
        root=insertIntoBST(root,data);
        cin>>data;
    }
}
int main(){
    Node* root=NULL;
    cout<<"Enter data to create BST"<<endl;
    takeInput(root);
    cout<<"Level Order Traversal"<<endl;
    levelOrderTraversal(root);
    cout<<"Reverse Level Order Traversal "<<endl;
    reverseLevelTraversal(root);
    cout<<endl;
    cout<<"InOrder Traversal ";
    inOrderTraversal(root);
    cout<<endl;
    cout<<"PreOrder Traversal ";
    PreOrderTraversal(root);
    cout<<endl;
    cout<<"PostOrder Traversal ";
    PostOrderTraversal(root);
    cout<<endl;
    cout<<"Maximum Element: " << maxVal(root)->data <<endl;
    cout<<"Minimum Element: " << minVal(root)->data <<endl;
    return 0;
}

// Check BST or not

// Method-1
bool isBST(BinaryTreeNode<int> *root, int min, int max){
    if(root==NULL){
        return true;
    }
    if(root->data>=min && root->data<=max){
        bool left=isBST(root->left, min, root->data);
        bool right=isBST(root->right, root->data, max);
        return left && right;
    }
    else{
        return false;
    }
}
bool validateBST(BinaryTreeNode<int> *root) {
    return isBST(root, INT_MIN, INT_MAX);
}

// Method-2
void inorder(BinaryTreeNode<int> *root, vector<int>& ans){
    if(root==NULL){
        return;
    }
    inorder(root->left, ans);
    ans.push_back(root->data);
    inorder(root->right, ans);
}
bool validateBST(BinaryTreeNode<int> *root) {
    vector<int> ans;
    int c=0;
    inorder(root, ans);
    if(is_sorted(ans.begin(), ans.end()))
        return true;
     else
        return false;
}

// Predecessor and Successor in BST

void helper(binaryTreeNode *root, int key,int &suc,int &pre) {
	if(root==NULL) {
		return;
	}
	if(root->data > key) {
		suc=root->data;
		helper(root->left,key,suc,pre);
	}
	else if(root->data < key) {
		pre=root->data;
		helper(root->right,key,suc,pre);
	}
	else {
		binaryTreeNode *tmp=root->right;
		while(tmp && tmp->left) {
			tmp=tmp->left;
		}
		if(tmp) {
			suc=tmp->data;
		}
		tmp=root->left;
		while(tmp && tmp->right) {
			tmp=tmp->right;
		}
		if(tmp) {
			pre=tmp->data;
		}
		return;
	}
}
vector<int> findPreSuc(binaryTreeNode *root, int key) {
	int pre=-1,suc=-1;
	helper(root,key,suc,pre);
	return {pre,suc};
}

// Find K-th smallest Element in BST

// Method-1
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        int i=0, ans=0;
        TreeNode *prev, *curr;

        //NULL check
        if(root == NULL){
            return -1;
        }
        curr = root;
        while(curr){
            if(curr->left == NULL){
                i++;
                if(i == k){
                    ans = curr->val; 
                }
                curr = curr->right;
            }
            else{
                prev = curr->left;
                while(prev->right != NULL && prev->right != curr){
                    prev = prev->right;
                }

                if(prev->right == NULL){
                    prev->right = curr;
                    curr = curr->left;
                }
                else{
                    prev->right = NULL;
                    i++;
                    if(i == k){
                        ans = curr->val;
                    }
                    curr = curr->right;
                }
            }
        }
        return ans;        
    }
};

// Method-2
int solve(BinaryTreeNode<int>* root, int &i, int k){
    //base case
    if(root == NULL){
        return -1;
    }//Inorder - LNR since it is sorted, we increment i when a node is found
    // Left
    int left = solve(root->left, i,k);
    if(left != -1){
        return left;
    }
    // Node
    i++;
    if (i == k) {
        return root->data;
    }
    // Right
    return solve(root->right, i,k);    
}
int kthSmallest(BinaryTreeNode<int>* root, int k) {
    int i =0;
    int ans = solve(root, i, k);
    return ans;
}

// Find K-th Largest Element in BST

int solve(TreeNode<int>* root,int &i,int k){
    //base case
        if(root == NULL){
            return -1;
        }//Inorder - LNR since it is sorted, we increment i when a node is found
        // Right
        int right = solve(root->right, i,k);
        if(right != -1){
            return right;
        }
        // Node
        i++;
        if (i == k) {
            return root->data;
        }
        // Left
        return solve(root->left, i,k);
}
int KthLargestNumber(TreeNode<int>* root, int k) 
{
    int i=0;
    int ans=solve(root,i,k);
    return ans;
}

// LCA of two nodes in a BST

TreeNode<int>* LCAinaBST(TreeNode<int>* root, TreeNode<int>* P, TreeNode<int>* Q)
{
	while(root != NULL){
        if(root->data < P->data && root->data < Q->data){
            root = root->right;
        }
        else if(root->data > P->data && root->data > Q->data){
            root = root->left;
        }
        else{ 
            return root;
        }
    }
}

// Two Sum in a BST

// Method-1
void inorder(BinaryTreeNode<int>* root,vector<int>&ans){
   if(root==NULL)
       return ;
   inorder(root->left,ans);
   ans.push_back(root->data);
   inorder(root->right,ans);
}
bool twoSumInBST(BinaryTreeNode<int>* root, int target) {
   vector<int> ans;
   inorder(root,ans);
   int size=ans.size();
   int start=0,end=size-1;
   while(start<end){
       if(ans[start]+ans[end] == target)
           return true;
       else if(ans[start]+ans[end] > target)
           end--;
       else
           start++;
   }
   return false;
}

// Flatten BST to a sorted List

void inorder(TreeNode<int>* root, vector<int> &in){
    if(root == NULL)
        return;
    inorder(root->left, in);
    in.push_back(root->data);
    inorder(root->right, in);
}
TreeNode<int>* flatten(TreeNode<int>* root)
{
    vector<int> in;
    inorder(root, in);
    int n = in.size();
    TreeNode<int>* newRoot = new TreeNode<int>(in[0]);
    TreeNode<int>* curr = newRoot;
    for(int i = 1; i < n; i++){
        TreeNode<int>* temp = new TreeNode<int>(in[i]);
        curr->right = NULL;
        curr->left = temp;
        curr = temp;
    }
    curr->left = NULL;
    curr->right = NULL;
    return newRoot;
}

// Normal BST to Balanced BST

void inorder(TreeNode<int>* root, vector<int> &inorderVal){
    if(root == NULL){
        return;
    }
    inorder(root->left, inorderVal);
    inorderVal.push_back(root->data);
    inorder(root->right, inorderVal);
}
TreeNode<int>* inorderToBST(int s, int e, vector<int> inorderVal){
    if(s > e){
        return NULL;
    }
    int mid = (s+e)/2;
    TreeNode<int>* root = new TreeNode<int>(inorderVal[mid]);
    root->left = inorderToBST(s, mid-1, inorderVal);
    root->right = inorderToBST(mid+1, e, inorderVal);
    return root;
}
TreeNode<int>* balancedBst(TreeNode<int>* root) {
    vector<int> inorderVal;
    inorder(root, inorderVal);
    return inorderToBST(0, inorderVal.size()-1, inorderVal);
}

// Preorder traversal of a BST

// Method-1
BinaryTreeNode<int>* inorderToBST(int s, int e, vector<int> &inorder)
{
    if(s>e)
    {
        return NULL;
    }
    int mid=(s+e)/2;
    BinaryTreeNode<int>* newRoot= new BinaryTreeNode<int>(inorder[mid]);
    newRoot->left=inorderToBST(s, mid-1, inorder);
    newRoot->right=inorderToBST(mid+1, e, inorder);
    return newRoot;
}
BinaryTreeNode<int>* preorderToBST(vector<int> &preorder) {
    sort(preorder.begin(), preorder.end());
    return inorderToBST(0,preorder.size()-1, preorder);
}

// Method-2
BinaryTreeNode<int>* solve(vector<int> &preorder, int mini, int maxi, int &i){
    if(i >= preorder.size()){
        return NULL;
    }
    if(preorder[i] < mini || preorder[i] > maxi){
        return NULL;
    }

    BinaryTreeNode<int>* root = new BinaryTreeNode<int>(preorder[i++]);
    root->left = solve(preorder, mini, root->data, i);
    root->right = solve(preorder, root->data, maxi, i);

    return root;
}
BinaryTreeNode<int>* preorderToBST(vector<int> &preorder) {
    // Write your code here.
    int mini = INT_MIN;
    int maxi = INT_MAX;

    int i = 0;
    return solve(preorder, mini, maxi, i);
}

// Method-3
BinaryTreeNode<int>* solve(vector<int> &preorder, int maxi, int &i){
    if(i == preorder.size() || preorder[i] > maxi){
        return NULL;
    }
    BinaryTreeNode<int>* root = new BinaryTreeNode<int>(preorder[i++]);
    root->left = solve(preorder, root->data, i);
    root->right = solve(preorder, maxi, i);

    return root;
}
BinaryTreeNode<int>* preorderToBST(vector<int> &preorder) {
    int maxi = INT_MAX;
    int i = 0;
    return solve(preorder, maxi, i);
}

// Merge two BST

// Method-1
void inorder(TreeNode<int>*root,vector<TreeNode<int>*>&v) {
    if(!root) {
        return;
    }
    inorder(root->left,v);
    v.push_back(root);
    inorder(root->right,v);
}

// The following function merges the inorder traversal of two trees
void merge(vector<TreeNode<int>*>&v1,vector<TreeNode<int>*>&v2,vector<TreeNode<int>*>&ans) {
    int i=0,j=0,k=0;
    while(i<v1.size() && j<v2.size()) {
        if(v1[i]->data<v2[j]->data) {
            ans[k]=v1[i++];
        }
        else {
            ans[k]=v2[j++];
        }
        ans[k]->left=NULL;
        ans[k]->right=NULL;
        k++;
    }
    while(i<v1.size()) {
        ans[k]=v1[i++];
        ans[k]->left=NULL;
        ans[k]->right=NULL;
        k++;
    }
    while(j<v2.size()) {
        ans[k]=v2[j++];
        ans[k]->left=NULL;
        ans[k]->right=NULL;
        k++;
    }
}
// The following function builds the merged tree from the merged inorder traversal 
TreeNode<int>*helper(vector<TreeNode<int>*>&ans,int start,int end) {
    if(start>end) {
        return NULL;
    }
    int mid=start+(end-start)/2;
    TreeNode<int> *root= ans[mid];
    if(start==end) {
        return root;
    }
    root->left=helper(ans,start,mid-1);
    root->right=helper(ans,mid+1,end);
    return root;
}
TreeNode<int> *mergeBST(TreeNode<int> *root1, TreeNode<int> *root2) {
    vector<TreeNode<int>*>v1,v2;
    inorder(root1,v1);
    inorder(root2,v2);
    vector<TreeNode<int>*>ans(v1.size()+v2.size());
    merge(v1,v2,ans);
    return helper(ans,0,ans.size()-1);
}

// Method-2
// function to convert BST to Doubly Linked List
void convertTOList(TreeNode<int>*root, TreeNode<int>*&head){
    if(!root)
        return;
    convertTOList(root->right, head);
    root->right=head;
    if(head){
        head->left=root;
    }
    head=root;
    convertTOList(root->left, head);
}
// merge two sorted Linked lists
TreeNode<int>* mergedList(TreeNode<int>*head1,TreeNode<int>*head2){
    TreeNode<int>* head=NULL;
    TreeNode<int>* tail =NULL;
    while(head1 && head2){
        if(head1->data<head2->data){
            if(head==NULL){
                head=head1;
                tail=head1;
                head1=head1->right;
            }
            else{
                tail->right=head1;
                head1->left=tail;
                tail=head1;
                head1=head1->right;
            }
        }
        else{
            if(head==NULL){
                head=head2;
                tail=head2;
                head2=head2->right;
            }
            else{
                tail->right=head2;
                head2->left=tail;
                tail=head2;
                head2=head2->right;
            }
        }
    }
    while(head1){
        tail->right=head1;
        head1->left=tail;
        tail=head1;
        head1=head1->right;
    }
    while(head2){
        tail->right=head2;
        head2->left=tail;
        tail=head2;
        head2=head2->right;
    }
    return head;
}
int count_nodes(TreeNode<int>*head){
    TreeNode<int>*temp=head;
    int count=0;
    while(temp){
        count++;
        temp=temp->right;
    }
    return count;
}
TreeNode<int>*lltoBST(TreeNode<int>*&head,int n){
    if(n<=0  || head==NULL)
        return NULL;
    TreeNode<int>*left =lltoBST(head,  n/2);
    TreeNode<int>*root =head;
    root->left=left;
    head=head->right;
    root->right =lltoBST(head, n-n/2-1);
    return root;
}
TreeNode<int> *mergeBST(TreeNode<int> *root1, TreeNode<int> *root2){
    // Convert BST TO Doubly
    TreeNode<int>* head1=NULL;
    convertTOList(root1, head1);
    head1->left=NULL;
    TreeNode<int>* head2=NULL;
    convertTOList(root2, head2);
    head2->left=NULL;
    // Merge the two Linked Lists
    TreeNode<int>*mergedHead = mergedList(head1, head2);
    // merge the two BST's
    return lltoBST(mergedHead, count_nodes(mergedHead)); 
}

// Largest BST in binary tree

void func(TreeNode<int>* root,int &size,int &max_num, int &min_num){
    if(root == NULL){
        size = 0;
        max_num = -100000;
        min_num = 100000;
        return;
    }
    if(root->left == NULL&&root->right == NULL){
        size = 1;
        max_num = root->data;
        min_num = root->data;
        return;
    }
    int size1,max_num1,min_num1,size2,max_num2,min_num2;
    func(root->left,size1,max_num1,min_num1);
    func(root->right,size2,max_num2,min_num2);
    if(root->data>max_num1&&root->data<min_num2){
        size = 1 + size1 + size2;
        max_num = max(root->data,max_num2);
        min_num = min(root->data,min_num1);
        return;
    }
    else{
        size = max(size1,size2);
        max_num = 100000;
        min_num = -100000;
        return;
    }
}
int largestBST(TreeNode<int>* root) 
{
    if(root == NULL)return -1;
    int size = 0;
    int max_num,min_num;
    func(root,size,max_num,min_num);
    return size;
}

// Insertion Deletion in Heap

#include <bits/stdc++.h>
using namespace std;
class heap
{
public:
    int arr[100];
    int size = 0;
    heap()
    {
        arr[0] = -1;
        size = 0;
    }
    void insert(int val)
    {
        size = size + 1;
        int index = size;
        arr[index] = val;
        while (index > 1)
        {
            int parent = index / 2;
            if (arr[parent] < arr[index])
            {
                swap(arr[parent], arr[index]);
                index = parent;
            }
            else
            {
                return;
            }
        }
    }
    void deleteFromHeap()
    {
        if (size == 0)
        {
            cout << "Nothing to delete" << endl;
            return;
        }
        // put last node element at root node
        arr[1] = arr[size];
        // remove last node
        size--;
        // put root node at correct position
        int i = 1;
        while (i < size)
        {
            int leftIndex = 2 * i;
            int rightIndex = 2 * i + 1;
            if (leftIndex < size && arr[i] < arr[leftIndex] && arr[leftIndex] > arr[rightIndex])
            {
                swap(arr[i], arr[leftIndex]);
                i = leftIndex;
            }
            else if (rightIndex < size && arr[i] < arr[rightIndex] && arr[leftIndex] < arr[rightIndex])
            {
                swap(arr[i], arr[rightIndex]);
                i = rightIndex;
            }
            else
            {
                return;
            }
        }
    }
    void print()
    {
        for (int i = 1; i <= size; i++)
        {
            cout << arr[i] << " ";
        }
        cout << endl;
    }
};
int main()
{
    heap h;
    h.insert(50);
    h.insert(55);
    h.insert(53);
    h.insert(52);
    h.insert(54);
    h.print();
    h.deleteFromHeap();
    h.print();
    return 0;
}

// Heapify Algorithm

#include <bits/stdc++.h>
using namespace std;
void heapify(int arr[], int n, int i)
{
    int largest = i;
    int leftChild = 2 * i;
    int rightChild = 2 * i + 1;
    if (leftChild < n && arr[largest] < arr[leftChild])
    {
        largest = leftChild;
    }
    if (rightChild < n && arr[largest] < arr[rightChild])
    {
        largest = rightChild;
    }
    if (largest != i)
    {
        swap(arr[largest], arr[i]);
        heapify(arr, n, largest);
    }
}
int main()
{
    int arr[6] = {-1, 54, 53, 55, 52, 50};
    int n = 5;
    for (int i = n / 2; i > 0; i--)
    {
        heapify(arr, n, i);
    }
    cout << "Printing the array" << endl;
    for (int i = 1; i <= n; i++)
    {
        cout << arr[i] << " ";
    }
    return 0;
}

// Build Min Heap

#include <bits/stdc++.h>
void heapify(vector<int> &arr, int n, int i) {
  int smallest = i;
  int leftChild = 2 * i + 1;
  int rightChild = 2 * i + 2;
  if (leftChild < n && arr[smallest] > arr[leftChild]) {
    smallest = leftChild;
  }
  if (rightChild < n && arr[smallest] > arr[rightChild]) {
    smallest = rightChild;
  }
  if (smallest != i) {
    swap(arr[smallest], arr[i]);
    heapify(arr, n, smallest);
  }
}
vector<int> buildMinHeap(vector<int> &arr) {
  int n = arr.size();
  for (int i = (n / 2) - 1; i >= 0; i--) {
    heapify(arr, n, i);
  }
  return arr;
}

// Build Max Heap

#include <bits/stdc++.h>
void heapify(vector<int> &arr, int n, int i) {
  int largest = i;
  int leftChild = 2 * i + 1;
  int rightChild = 2 * i + 2;
  if (leftChild < n && arr[largest] < arr[leftChild]) {
    largest = leftChild;
  }
  if (rightChild < n && arr[largest] < arr[rightChild]) {
    largest = rightChild;
  }
  if (largest != i) {
    swap(arr[largest], arr[i]);
    heapify(arr, n, largest);
  }
}
vector<int> buildMinHeap(vector<int> &arr) {
  int n = arr.size();
  for (int i = (n / 2) - 1; i >= 0; i--) {
    heapify(arr, n, i);
  }
  return arr;
}

// Heap Sort

// Method-1
class Solution
{
    public:
    void heapify(int arr[], int n, int i)  
    {
        int largest = i;
        int leftChild = 2 * i + 1;
        int rightChild = 2 * i + 2;
        if (leftChild < n && arr[largest] < arr[leftChild]) {
            largest = leftChild;
        }
        if (rightChild < n && arr[largest] < arr[rightChild]) {
            largest = rightChild;
        }
        if (largest != i) {
            swap(arr[largest], arr[i]);
            heapify(arr, n, largest);
        }
    }
    void buildHeap(int arr[], int n)  
    { 
        for (int i = (n / 2) - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
    }
    void heapSort(int arr[], int n)
    {
        buildHeap(arr,n);
        for(int i=n-1;i>=0;i--){
        //swap
        swap(arr[0],arr[i]);
        heapify(arr,i,0);
    }
};

// Method-2
#include <bits/stdc++.h>
vector<int> heapSort(vector<int>& arr, int n) {
	priority_queue<int>maxheap;
    //creating a maxheap
    for(int i=0;i<n;i++){
        maxheap.push(arr[i]);
    }    
    int index=n-1;
    //placing the maximum element at the end of array
    while( !maxheap.empty()){
        int max=maxheap.top();
        maxheap.pop();
        arr[index--]=max;        
    }
    return arr;
}

// Priority queue

#include <bits/stdc++.h>
#include<queue>
using namespace std;
int main()
{
    cout<<"Using priority queue here "<<endl;
    // maxHeap
    priority_queue<int> pq;
    pq.push(4);
    pq.push(2);
    pq.push(5);
    pq.push(3);
    cout<<"Element at the top "<<pq.top()<<endl;
    pq.pop();
    cout<<"Element at the top "<<pq.top()<<endl;
    cout<<"Size is "<<pq.size()<<endl;
    if(pq.empty()){
        cout<<"pq is empty"<<endl;
    }
    else{
        cout<<"pq is not empty"<<endl;
    }
    // minHeap
    priority_queue<int,vector<int>,greater<int>> minheap;
    minheap.push(4);
    minheap.push(2);
    minheap.push(5);
    minheap.push(3);
    cout<<"Element at the top "<<minheap.top()<<endl;
    minheap.pop();
    cout<<"Element at the top "<<minheap.top()<<endl;
    cout<<"Size is "<<minheap.size()<<endl;
    if(minheap.empty()){
        cout<<"pq is empty"<<endl;
    }
    else{
        cout<<"pq is not empty"<<endl;
    }
    return 0;
}

// Kth smallest number

class Solution{
    public:
    // arr : given array
    // l : starting index of the array i.e 0
    // r : ending index of the array i.e size-1
    // k : find kth smallest element and return using this function
    int kthSmallest(int arr[], int l, int r, int k) {
        priority_queue<int> pq;
        for(int i=0;i<k;i++){
            pq.push(arr[i]);
        }
        for(int i=k;i<=r;i++){
            if(arr[i]<pq.top()){
                pq.pop();
                pq.push(arr[i]);
            }
        }
        int ans=pq.top();
        return ans;
    }
};

// Kth largest number

// Method-1
class Solution{
public:	
	vector<int> kLargest(int arr[], int n, int k) {
	    vector<int> ans;
	    sort(arr,arr+n);
	    for(int i=n-1;i>=n-k;--i){
	        ans.push_back(arr[i]);
	    }
	    return ans;
	}
};

// Method-2
class Solution{
public:	
	vector<int> kLargest(int arr[], int n, int k) {
	   vector<int>v; 
       priority_queue<int>mheap;
       for(int i=0;i<n;i++){
           mheap.push(arr[i]);
       }
       for(int i=0;i<k;i++){
           v.push_back(mheap.top());
           mheap.pop();
       }
     return v;
    }
};

// Merge two binary max heaps

// Method-1
class Solution{
    public:
    void heapify(vector<int>&arr ,int n ,int i){
      int largest=i;
      int left = 2*i+1;
      int right =2*i+2;
      if(left<n && arr[largest]<arr[left]){
            largest=left;
      }
      if(right<n && arr[largest]<arr[right]){
          largest=right;
      }
      if(largest!=i){
           swap(arr[largest],arr[i]);
           heapify(arr,n,largest);
      }
    }
    vector<int> mergeHeaps(vector<int> &a, vector<int> &b, int n, int m) {
         vector<int>c;
         for(auto i:a)
	 	c.push_back(i);
         for(auto i:b)
	 	c.push_back(i);
        int N=m+n;
        for(int i=N/2-1 ;i>=0;--i){
             heapify(c,N,i);
        }
        return c;
    }
};

// Method-2
class Solution{
    public:
    vector<int> mergeHeaps(vector<int> &a, vector<int> &b, int n, int m) {
        priority_queue<int>pq;
        for(auto i:a){
            pq.push(i);
        }
        for(auto i:b){
            pq.push(i);
        }
        vector<int>ans;
        while(!pq.empty()){
            ans.push_back(pq.top());
            pq.pop();
        }
        return ans;
    }
};

// Is Binary tree Heap

class Solution {
  public:
      int countNodes(struct Node* root){
          if(root == NULL)
          return 0;
          int ans = 1 + countNodes(root->left) + countNodes(root->right);
          return ans;
      }
      bool isCBT(struct Node* root, int i, int cnt){
          if(root == NULL){
              return true;
          }
          if(i >= cnt){
              return false;
          }
          else{
              bool left = isCBT(root->left, 2*i+1, cnt);
              bool right = isCBT(root->right, 2*i+2, cnt);
              return (left && right);
          }
      }
      bool isMaxOrder(struct Node* root){
          if(root->left == NULL && root->right == NULL){
              return true;
          }
          if(root->right == NULL){
              return root->data > root->left->data;
          }
          else{
              bool left = isMaxOrder(root->left);
              bool right = isMaxOrder(root->right);
              return (left && right && root->data > root->left->data && root->data > root->right->data);
          }
      }
    bool isHeap(struct Node* tree) {
        int index = 0;
        int countNode = countNodes(tree);
        if(isCBT(tree, index, countNode) && isMaxOrder(tree)){
            return true;
        }
        else{
            return false;
        }
    }
};

// Minimum Cost of ropes

class Solution
{
    public:
    long long minCost(long long arr[], long long n) {
        long long cost=0;
        priority_queue<long long,vector<long long>,greater<long long>>pq;
        for(int i=0;i<n;i++){
            pq.push(arr[i]);
        }
        while(pq.size()>1){
            long long a=pq.top();
            pq.pop();
            long long b=pq.top();
            pq.pop();
            long long sum=a+b;
            cost+=sum;
            pq.push(sum);
            
        }
        return cost;
    }
};

// Convert BST to min heap

#include <bits/stdc++.h>
using namespace std;
// Structure of a node of BST
struct Node {
	int data;
	Node *left, *right;
};
// Helper function that allocates a new node with the given data and NULL left and right pointers. 
struct Node* getNode(int data)
{
	struct Node* newNode = new Node;
	newNode->data = data;
	newNode->left = newNode->right = NULL;
	return newNode;
}
// function prototype for preorder traversal of the given tree
void preorderTraversal(Node*);
// function for the inorder traversal of the tree so as to store the node values in 'arr' in sorted order
void inorderTraversal(Node* root, vector<int>& arr)
{
	if (root == NULL)
		return;
	// first recur on left subtree
	inorderTraversal(root->left, arr);
	// then copy the data of the node
	arr.push_back(root->data);
	// now recur for right subtree
	inorderTraversal(root->right, arr);
}
// function to convert the given BST to MIN HEAP performs preorder traversal of the tree
void BSTToMinHeap(Node* root, vector<int> arr, int* i)
{
	if (root == NULL)
		return;
	// first copy data at index 'i' of 'arr' to the node
	root->data = arr[++*i];
	// then recur on left subtree
	BSTToMinHeap(root->left, arr, i);
	// now recur on right subtree
	BSTToMinHeap(root->right, arr, i);
}
// utility function to convert the given BST to MIN HEAP
void convertToMinHeapUtil(Node* root)
{
	// vector to store the data of all the nodes of the BST
	vector<int> arr;
	int i = -1;
	// inorder traversal to populate 'arr'
	inorderTraversal(root, arr);
	// BST to MIN HEAP conversion
	BSTToMinHeap(root, arr, &i);
}
// function for the preorder traversal of the tree
void preorderTraversal(Node* root)
{
	if (!root)
		return;
	// first print the root's data
	cout << root->data << " ";
	// then recur on left subtree
	preorderTraversal(root->left);
	// now recur on right subtree
	preorderTraversal(root->right);
}
int main()
{
	// BST formation
	struct Node* root = getNode(4);
	root->left = getNode(2);
	root->right = getNode(6);
	root->left->left = getNode(1);
	root->left->right = getNode(3);
	root->right->left = getNode(5);
	root->right->right = getNode(7);
	// Function call
	convertToMinHeapUtil(root);
	cout << "Preorder Traversal:" << endl;
	preorderTraversal(root);
	return 0;
}

// K-th Largest Sum Subarray

// Method-1
#include <bits/stdc++.h> 
int getKthLargest(vector<int> &arr, int k)
{
    vector<int>ans;
    for(int i=0;i<arr.size();i++){   // O(n^2)
        int sum=0;
        for(int j=i;j<arr.size();j++){
            sum+=arr[j];
            ans.push_back(sum);
        }
    }
    sort(ans.begin(),ans.end());   // O(LlogL) l is length of ans array  L = n^2
    int n= ans.size();
    return ans[n-k];
}   

// Method-2
#include<queue>

int getKthLargest(vector<int> &arr, int k)
{
	priority_queue<int,vector<int>,greater<int>>mini;
	int n=arr.size();
	for(int i=0;i<n;i++){
		int sum=0;
		for (int j = i; j < n; j++) {
			sum += arr[j];
			if(mini.size()<k){
				mini.push(sum);
			}
			else{
				if(sum>mini.top()){
					mini.pop();
					mini.push(sum);
				}
			}
		}
	}
	return mini.top();
}

// Merge K Sorted Arrays

// Method-1
#include <bits/stdc++.h> 
vector<int> mergeKSortedArrays(vector<vector<int>>&kArrays, int k)
{
    vector<int>ans;
    for(int i=0;i<kArrays.size();i++){
        for(int j=0;j<kArrays[i].size();j++){
            ans.push_back(kArrays[i][j]);
        }
    }
    sort(ans.begin(),ans.end());
    return ans;
}

// Method-2
#include <bits/stdc++.h> 
class node{
    public:
        int data;
        int i;
        int j;  
    node(int data,int row,int col){
        this->data=data;
        i=row;
        j=col;
    }    
};
class compare{
    public:
        bool operator()(node*a,node*b){
            return a->data > b->data;
        }
};
vector<int> mergeKSortedArrays(vector<vector<int>>&kArrays, int k)
{
    priority_queue<node*, vector<node*>,compare > pq;
    // insert all first k elements of array
    for(int i=0;i<k;i++){
        node*temp=new node(kArrays[i][0],i,0);
        pq.push(temp);
    } 
    vector<int> ans;
    while(pq.size()>0){
        node* tp= pq.top();
        pq.pop();
        ans.push_back( tp->data );
        int i= tp->i;
        int j= tp->j;
        if (j + 1 < kArrays[i].size()) {
          node *next = new node(kArrays[i][j + 1], i, j + 1);
          pq.push(next);
        }
    }
    return ans;
}

// Merge k sorted lists

// Method-1
#include<bits/stdc++.h>
void solve(Node<int>*&tail,vector<int>&ans){
    int i=1;
    int n= ans.size();
    while(i!=n){
        Node<int>* temp= new Node<int>(ans[i]);
        tail->next=temp;
        tail=tail->next;
        i++;
    }
}
Node<int>* mergeKLists(vector<Node<int>*> &listArray)
{
    vector<int> ans;
    for(int i=0;i<listArray.size();i++){
        Node<int>* temp= listArray[i];
        while(temp!=NULL){
            ans.push_back( temp->data );
            temp=temp->next;
        }
    }
    sort(ans.begin(),ans.end());
    int n= ans.size();
    if(n==0) return NULL;
    Node<int>* head=new Node<int>(ans[0]);
    Node<int>* tail=head;
    solve(tail,ans);
    return head;
}

// Method-2
#include<queue>
#include<algorithm>
class compare{
    public:
    bool operator()(Node<int>*a,Node<int>*b){
        return a->data > b->data;
    }
};
Node<int>* mergeKLists(vector<Node<int>*> &listArray)
{
    priority_queue<Node<int>*,vector<Node<int>*>,compare>minheap;
    int k=listArray.size();
    if(k==0)
        return NULL;
    Node<int>*head=NULL;
    Node<int>*tail=NULL;
    //creating k heap with the head of k given Linked List
    for(int i=0;i<k;i++){        
        Node<int>*temp=listArray[i];
        if(temp!=NULL)
            minheap.push(temp);
        
    }
    while(minheap.size()>0){
        Node<int>*top=minheap.top();
        minheap.pop();
        if(top->next!=NULL){
            minheap.push(top->next);
        }
        //checking if its the 1st most element 
        if(head==NULL){
            head=top;
            tail=top;
        }
        //for rest of elements
        else{
            tail->next=top;
            tail=top;
        }
    }
    return head;
}

// Median in a stream

// Method-1
#include <bits/stdc++.h>
vector<int> findMedian(vector<int> &arr, int n){
    vector<int> nums, ans;
    for(int x=0; x<n; x++){
        nums.push_back(arr[x]);
        sort(nums.begin(), nums.end());
        int N = nums.size();
        if(N & 1){
            N--;
            ans.push_back(nums[N/2]);
        }else{
            N--;
            ans.push_back( (nums[N/2]+nums[(N/2)+1])/2 );
        }
    } 
    return ans;
}

// Method-2
#include<bits/stdc++.h>
int signum(int a, int b){
	if(a == b)
		return 0;	
	else if(a > b)
		return 1;
	else
		return -1;
}
void calMedian(int element, priority_queue<int> &maxi, 
	priority_queue<int, vector<int>, greater<int> > &mini, int &median){
		switch(signum(maxi.size(), mini.size())){
			case 0:
					if(element > median){
						mini.push(element);
						median = mini.top();
					}
					else{
						maxi.push(element);
						median = maxi.top();
					}
					break;
			case 1:
					if(element > median){
						mini.push(element);
						median = (mini.top() + maxi.top())/2;
					}
					else{
						mini.push(maxi.top());
						maxi.pop();
						maxi.push(element);
						median = (mini.top() + maxi.top())/2;
					}
					break;
			case -1:
					if(element > median){
						maxi.push(mini.top());
						mini.pop();
						mini.push(element);
						median = (mini.top() + maxi.top())/2;
					}
					else{
						maxi.push(element);
						median = (mini.top() + maxi.top())/2;
					}
					break;
		}
}
vector<int> findMedian(vector<int> &arr, int n){
	vector<int> ans;
	priority_queue<int, vector<int>, greater<int> > mini;
	priority_queue<int> maxi;
	int median = 0;
	for(int i = 0; i < n; i++){
		calMedian(arr[i], maxi, mini, median);
		ans.push_back(median);
	}
	return ans;
}

// Smallest Range From K Sorted List

#include<bits/stdc++.h>
class node{
    public:
        int data;
        int row;
        int col;

    node(int d, int r, int c){
        data = d;
        row = r;
        col = c;
    }
};
class compare{
    public:
        bool operator()(node* a, node* b){
            return a->data > b->data;
        }
};
int kSorted(vector<vector<int>> &a, int k, int n) {  
    int mini = INT_MAX, maxi = INT_MIN;
    priority_queue<node*, vector<node*>, compare> pq;
    for (int i=0; i<k; i++){
        int elem = a[i][0];
        mini = min(mini, elem);
        maxi = max(maxi, elem);
        pq.push(new node(elem, i, 0));
    }
    int start = mini, end = maxi;
    while (!pq.empty()){
        node* temp = pq.top();
        pq.pop();
        mini = temp->data;
        if (maxi-mini < end-start){
            start = mini;
            end = maxi;
        }
        if (temp->col+1 < n){
            maxi = max(maxi, a[temp->row][temp->col+1]);
            pq.push(new node(a[temp->row][temp->col+1], temp->row, temp->col+1));
        }
        else{
            break;
        }
    }
    return (end - start + 1);
}

// Rearrange string

// Method-1
#include <bits/stdc++.h> 
void reArrange(string &s, int size){
    for(int i = 0; i < size - 1; i++){
        if(s[i] == s[i+1]){
            int j = i + 1;
            while(s[i] == s[j]){
                j++;
            }
            swap(s[i + 1], s[j]);
        }
    }
}
string reArrangeString(string &s)
{
    int size = s.size();
	reArrange(s, size);
    return s;
}

// Method-2
#include <bits/stdc++.h> 
string reArrangeString(string &s)
{
    map<char,int> m;
    int n=s.size();
    for(int i=0;i<n;i++)
    	m[s[i]]++;
    vector<pair<int,char>> v;
    for(auto i:m)
    	v.push_back(make_pair(i.second,i.first));
    sort(v.begin(),v.end());
    reverse(v.begin(),v.end());
    int idx=0;
    for(auto i:v){
        int val=i.first;
        char key=i.second;
        if(val>n/2+n%2)return "not possible";
        while(val--){
            if(idx>=n)idx=1;
            s[idx]=key;
            idx+=2;
        }
    }
    return s;        
}

// Method-3
#include<bits/stdc++.h>
string reArrangeString(string &s)
{
    priority_queue<char> maxHeap;
	string ans="";
    int count=0;
    for(int i=0;i<s.length();i++) {
		char it = ans[ans.length()-1];
		if(it==s.at(i)) {
			maxHeap.push(s.at(i));
		}
		else {
			ans.push_back(s[i]);
			while(!maxHeap.empty()) {
				char topChar = maxHeap.top();
				it = ans[ans.length()-1];
				if(topChar!=it) {
					ans.push_back(topChar);
					maxHeap.pop();
				}else{
					break;
				}
			}
		}
    }
    while(!maxHeap.empty()) {
        char topChar = maxHeap.top();
		char it = ans[ans.length()-1];
        if(topChar!=it) {
            ans.push_back(topChar);
            maxHeap.pop();
		}
		else{
            break;
        }
	}
    if(maxHeap.empty()) {
        return ans;
    }
	else {
        return "not possible";
    }   
}

// Hashmap

#include<iostream>
#include<map>
#include<unordered_map>
using namespace std;
int main(){
    // creation
    // map<string,int> m; -> just to check map
    unordered_map<string,int> m;
    // insertion
    // 1
    pair<string,int> p = make_pair("krsna",3);
    m.insert(p);
    // 2
    pair<string,int> q("anjum",2);
    m.insert(q);
    // 3
    m["yunus"] = 3;
    // what will happen?
    m["yunus"] = 2;
    // Search
    cout<<m["yunus"]<<endl;
    cout<<m.at("krsna")<<endl;
    // cout<<m.at("unknownKey")<<endl; -> error
    cout<<m["unknownKey"]<<endl; // mapping <unknownKey,0> here
    cout<<m.at("unknownKey")<<endl;
    // size
    cout<<m.size()<<endl;
    // to check presence
    cout<<m.count("bro")<<endl;
    cout<<m.count("anjum")<<endl;
    // erase
    m.erase("yunus");
    cout<<m.size()<<endl;
    // Accesing map through iteration
    // 1
    for(auto i:m){
        cout<<i.first<<" "<<i.second<<endl;
    }
    // 2 -> Not in same order random order
    unordered_map<string,int> :: iterator it = m.begin();
    while(it!=m.end()){
        cout<<it->first<<" "<<it->second<<endl;;
        it++;
    }
    // 3 -> In same order
    // map<string,int> :: iterator it = m.begin();
    // while(it!=m.end()){
    //     cout<<it->first<<" "<<it->second<<endl;;
    //     it++;
    // }
    return 0;
}

// Maximum Frequency Number

int maximumFrequency(vector<int> &arr, int n)
{
    int maxFreq=0;
    int maxAns=0;
    unordered_map<int ,int>mp;
    for(int i=0;i<arr.size();i++){
        mp[arr[i]]++;
        maxFreq=max(maxFreq,mp[arr[i]]);
    }
    for(int i=0;i<arr.size();i++){
        if(maxFreq==mp[arr[i]]){
            maxAns=arr[i];
            break;
        }
    }
    return maxAns;
}

// Insertion , Searching and removal in Tries

#include<iostream>
using namespace std;
class TrieNode{
    public:
        char data;
        TrieNode* children[26];
        bool isTerminal;

        TrieNode(char ch){
            data=ch;
            for(int i=0;i<26;i++){
                children[i]=NULL;
            }
            isTerminal=false;
        }
};
class Trie{
    public: 
    TrieNode* root;
    Trie(){
        root=new TrieNode('\0');
    }
    void insertUtil(TrieNode* root,string word){
        // base case
        if(word.length()==0){
            root->isTerminal=true;
            return;
        }
        // assumption, word wil be in CAPS
        int index=word[0]-'A';
        TrieNode* child=new TrieNode('\0');
        // present
        if(root->children[index]!=NULL){
            child=root->children[index];
        }
        // absent
        else{
            child = new TrieNode(word[0]);
            root->children[index]=child;
        }   
        // Recursion
        insertUtil(child,word.substr(1));
    }
    void insertWord(string word){
        insertUtil(root,word);
    }
    bool searchUtil(TrieNode* root,string word){
        // base case
        if(word.length()==0){
            return root->isTerminal;
        }
        int index=word[0]-'A';
        TrieNode* child;
        // present
        if(root->children[index]!=NULL){
            child=root->children[index];
        }
        // absent
        else{
            return false;
        }
        // recursion
        return searchUtil(child,word.substr(1));
    }
    bool searchWord(string word){
        return searchUtil(root,word);
    }
    void removeUtil(TrieNode* root,string word){
        // base case
        if(word.length()==0){
            root->isTerminal=false;
            return;
        }
        // assumption, word wil be in CAPS
        int index=word[0]-'A';
        TrieNode* child;
        // present
        if(root->children[index]!=NULL){
            child=root->children[index];
        }
        // absent
        else{
            child = new TrieNode(word[0]);
            root->children[index]=child;
        }   
        // Recursion
        return removeUtil(child,word.substr(1));
    }
    void removeWord(string word){
        removeUtil(root,word);
        return;
    }
};
int main(){
    Trie *t=new Trie();
    t->insertWord("ARM");
    t->insertWord("DO");
    t->insertWord("TIME");
    cout<<"Present or not "<<t->searchWord("TIME")<<endl;
    cout<<"Present or not "<<t->searchWord("TIM")<<endl;
    t->removeWord("TIME");
    t->removeWord("DO");
    cout<<"Present or not "<<t->searchWord("TIME")<<endl;
    cout<<"Present or not "<<t->searchWord("TIM")<<endl;
    return 0;
}

// Implement a trie

class TrieNode{
    public:
        char data;
        TrieNode* children[26];
        bool isTerminal;

        TrieNode(char ch){
            data=ch;
            for(int i=0;i<26;i++){
                children[i]=NULL;
            }
            isTerminal=false;
        }
};
class Trie {
public:
    TrieNode* root;
    /** Initialize your data structure here. */
    Trie() {
        root=new TrieNode('\0');
    }
    void insertUtil(TrieNode* root,string word){
        // base case
        if(word.length()==0){
            root->isTerminal=true;
            return;
        }
        // assumption, word wil be in CAPS
        int index=word[0]-'a';
        TrieNode* child=new TrieNode('\0');
        // present
        if(root->children[index]!=NULL){
            child=root->children[index];
        }
        // absent
        else{
            child = new TrieNode(word[0]);
            root->children[index]=child;
        }   
        // Recursion
        insertUtil(child,word.substr(1));
    }
    /** Inserts a word into the trie. */
    void insert(string word) {
        insertUtil(root,word);
    }
    bool searchUtil(TrieNode* root,string word){
        // base case
        if(word.length()==0){
            return root->isTerminal;
        }
        int index=word[0]-'a';
        TrieNode* child;
        // present
        if(root->children[index]!=NULL){
            child=root->children[index];
        }
        // absent
        else{
            return false;
        }
        // recursion
        return searchUtil(child,word.substr(1));
    }
    /** Returns if the word is in the trie. */
    bool search(string word) {
        return searchUtil(root,word);
    }
    bool prefixUtil(TrieNode* root,string word){
        // base case
        if(word.length()==0){
            return true;
        }
        int index=word[0]-'a';
        TrieNode* child;
        // present
        if(root->children[index]!=NULL){
            child=root->children[index];
        }
        // absent
        else{
            return false;
        }
        // recursion
        return prefixUtil(child,word.substr(1));
    }
    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        return prefixUtil(root, prefix);
    }
};

// Longest Common Prefix

// Method-1
string longestCommonPrefix(vector<string> &arr, int n)
{
    string ans = arr[0];
    for(int i=1; i<n; i++) {
        string temp = "";
        int mini = min(ans.size(), arr[i].size());
        for(int j=0; j<mini; j++) {
            if(arr[i][j] == ans[j]) temp += ans[j];
            else break;
        }
        ans = temp;
    }
    return ans;
}

// Method-2
class Solution{
  public:
    string longestCommonPrefix (string arr[], int N)
    {
        string ans = "";
        bool match = true;
        for(int i=0;i<arr[0].length();i++) {
            char ch = arr[0][i];
            
            for(int j=1;j<N;j++) {
                if(ch != arr[j][i] || arr[j].length()<i) {
                    match = false;
                    break;
                }
            }
            if(match == false) {
                break;
            }
            else {
                ans.push_back(ch);
            }
        }
        if(ans.empty()) {
            return "-1";
        }
        return ans;
    }
};

// Method-3
 int min(int x,int y)
 {
      if(x>y)
      return y;
      else
      return x;
 }
 string longestCommonPrefix (string arr[], int N)
 {
 	int mini=INT_MAX;
        for(int i=0;i<N;i++)
            mini=min(mini,arr[i].length());  
        string ans="";
        unordered_map<char,int>mp;
               for(int i=0;i<mini;i++)
               {
                  for(int j=0;j<N;j++)
                  {
                      mp[arr[j][i]]++;
                  }
                  if(mp.size()==1){
                  for(auto &i:mp)
                    ans+=i.first;
                    mp.clear();
                  }
              }
              if(ans.length()!=0)
              return ans;
              else
              return "-1";   
 }
 
 // Method-4
 
class TrieNode
{	
    public:
    char data;
    TrieNode* children[26];
    int childCount;
    bool isTerminal;

    TrieNode(char ch)
    {
        data = ch;
        for(int i=0;i<26;i++){
		children[i]=NULL;
	}
	childCount = 0;
        isTerminal = false;
    }
};
   


 
 // Implement a phone directory using Trie
 
 #include <bits/stdc++.h> 
struct Node{
    Node *links[26];
    bool end = false;
    bool ifExists(char c){
        return links[c-'a']!=NULL;
    }
    //insert
    void put(char ch , Node *node){
        links[ch-'a'] = node;
    }
    //if exist return node
    Node *getNextNode(char ch){
      return  links[ch-'a'];
    }
    bool isNode(int i){
        return links[i]!=NULL;
    }
    bool End() { return end; }
    void setEnd() { 
        end = true; 
    }
};
class Trie{
       Node* root;
public:
    Trie() {
        root = new Node();
    }
    void insert(string& word) {
        Node* node = root;
        for (char ch : word) {
            if (!node->ifExists(ch)) {
                node->put(ch, new Node());
            }
            node = node->getNextNode(ch);
        }
        node->setEnd();
    }
    vector<string> getContactsDFS(string prefix) {
        vector<string> result;
        Node* node = root;
        for (char ch : prefix) {
            if (node->ifExists(ch)) {
                node = node->getNextNode(ch);
            } else {
                return result;
            }
        }
        dfsHelper(node, result, prefix);
        return result;
    }
    void dfsHelper(Node* node, vector<string>& result, string prefix) {
        if (node->End()) {
            result.push_back(prefix);
        }
        for (int i=0;i<26;i++) {
            if (node->isNode(i)) {
                char c = 'a' + i;
                dfsHelper(node->getNextNode(c), result, prefix + c);
            }
        }
    }
};
vector<vector<string>> phoneDirectory(vector<string>& arr, string &qStr)
{
    vector<vector<string>> ans;
    Trie t;
    for(string &str : arr) t.insert(str);
    for(int i=0;i<qStr.length();i++){
        vector<string> temp=t.getContactsDFS(qStr.substr(0,i+1));
        if(temp.size()) 
            ans.push_back(temp);
    }
    if(ans.size()==0) 
        return {{"No suggestions found"}} ;
    return ans;
}

// Rat in a maze problem

class Solution{
    private:
    bool safe(int x ,int y , int n , vector<vector<int>> visited ,vector<vector<int>> &m ){
        if( ( x >= 0 && x < n ) && ( y >= 0 && y < n ) && visited[x][y] == 0 && m[x][y] == 1){
            return true; 
        }
        else{
            return false;
        }
    }
    void solve(vector<vector<int>> &m , int n ,vector<string>& ans , int x , int y ,vector<vector<int>> visited , string path){
        //base case
        if( x == n - 1 && y == n - 1 ){
            ans.push_back(path);
            return ;
        }
        //when you cover that index
        visited[x][y] = 1;
        // their are  choices     
        // 1st is Down
        int newx = x + 1;
        int newy = y;
        if( safe( newx , newy , n ,visited , m)){
            path.push_back('D');
            solve( m , n , ans , newx , newy , visited , path);
            path.pop_back();
        }
        // 1st is Left
         newx = x;
         newy = y - 1;
        if( safe( newx , newy , n ,visited , m)){
            path.push_back('L');
            solve( m , n , ans , newx , newy , visited , path);
            path.pop_back();
        }
        // 1st is Right
        newx = x;
        newy = y + 1;
        if( safe( newx , newy , n ,visited , m)){
            path.push_back('R');
            solve( m , n , ans , newx , newy , visited , path);
            path.pop_back();
        }
        // 1st is Up
         newx = x - 1;
         newy = y;
        if( safe( newx , newy , n ,visited , m)){
            path.push_back('U');
            solve( m , n , ans , newx , newy , visited , path);
            path.pop_back();
        }
        visited[x][y] = 0;
    }
    public:
    vector<string> findPath(vector<vector<int>> &m, int n) {
        vector<string>ans ;
        if( m [0][0] == 0){
            return ans;
        }
        int srcx = 0;
        int srcy = 0;
        // Make a visited 2D vector
        vector<vector<int>> visited = m;
        // make it default by all indeces by 0
        for( int i = 0; i < n; i++){
            for( int j = 0; j < n; j++){
                visited [i][j] = 0;
            }
        }
        string path = "";
        solve( m , n , ans , srcx , srcy , visited , path);
        sort(ans.begin() , ans.end());
        return ans;
    }
};

// N queens

void addBoard(vector<vector<int>> &board, vector<vector<int>> &res){
    vector<int> temp;
    int n = board.size();
    for(int i=0; i<n; i++){
        for(int j=0; j<n; j++){
            temp.push_back(board[i][j]);
        }
    }
    res.push_back(temp);
}
void helper(int col, vector<vector<int>> &board, int n, vector<bool> &leftRow,
vector<bool> &leftUpperDiagonal, vector<bool> &leftLowerDiagonal, vector<vector<int>> &res){
    if(col == n){
        addBoard(board, res);
        return;
    }
    for(int row = 0; row < n; row++){
        if(!leftRow[row] && !leftLowerDiagonal[row+col] && !leftUpperDiagonal[n-1+col-row]){
            board[row][col] = 1;
            leftRow[row] = true;
            leftLowerDiagonal[row+col] = true;
            leftUpperDiagonal[n-1+col-row] = true;
            helper(col+1, board, n, leftRow, leftUpperDiagonal, leftLowerDiagonal, res);
            leftRow[row] = false;
            leftLowerDiagonal[row+col] = false;
            leftUpperDiagonal[n-1+col-row] = false;
            board[row][col] = 0;
        }
    }
}
vector<vector<int>> solveNQueens(int n) {
    vector<bool> leftRow(n, false);
    vector<bool> leftUpperDiagonal(2*n-1, false);
    vector<bool> leftLowerDiagonal(2*n-1, false);
    vector<vector<int>> res, board(n, vector<int> (n, 0));
    helper(0, board, n, leftRow, leftUpperDiagonal, leftLowerDiagonal, res);
    return res;
}

// Sudoku Solver

#include <bits/stdc++.h> 
bool isValid(vector<vector<int>> &sudoku, int row, int col, int digit){
    for(int i=0; i<9; i++){
        if(sudoku[row][i] == digit) return false;
        if(sudoku[i][col] == digit) return false;
        if(sudoku[3*(row/3)+i/3][3*(col/3)+i%3] == digit) return false;
    }
    return true;
}
bool solve(vector<vector<int>> &sudoku){
    for(int i=0; i<9; i++){
        for(int j=0; j<9; j++){
            if(sudoku[i][j] == 0){
                for(int d=1; d<=9; d++){
                    if(isValid(sudoku, i, j, d)){
                        sudoku[i][j] = d;
                        if(solve(sudoku)) return true;
                        else{
                            sudoku[i][j] = 0;
                        }
                    }
                }
                return false;
            }
        }
    }
    return true;
}
void solveSudoku(vector<vector<int>>& sudoku)
{
    solve(sudoku);
}

// Adjacency Matrix

#include <bits/stdc++.h>
using namespace std;
int main()
{
	// n is the number of vertices
	// m is the number of edges
	int n, m;
	cin >> n >> m;
	int adjMat[n + 1][n + 1];
	for (int i = 0; i < m; i++) {
		int u, v;
		cin >> u >> v;
		adjMat[u][v] = 1;
		adjMat[v][u] = 1;
		// for a directed graph with an edge pointing from u to v,we just assign adjMat[u][v] as 1
	}
	return 0;
}

// Adjacency List

// Method-1
class Solution {
  public:
    vector<vector<int>> printGraph(int V, vector<int> adj[]) {
        vector<vector<int>> ans;
        for(int i = 0 ; i < V ;i ++){
            vector<int> row;
            row.push_back(i);
            for(int j = 0 ; j < adj[i].size() ; j++){
                row.push_back(adj[i][j]);
            }
            ans.push_back(row);
        }
        return ans;
    }
};

// Method-2
#include<iostream>
#include<unordered_map>
#include<list>
using namespace std;
template <typename T>
class graph{
	public:
	unordered_map<T,list<T>> adj;
	void addEdge(T u,T v,bool direction){
		// direction = 0 -> undirected
		// direction = 1 -> directed
		// create and edge from u to v;
		adj[u].push_back(v);
		if(direction==0){
			adj[v].push_back(u);
		}
	}
	void printAdjList(){
		for(auto i:adj){
			cout<<i.first<<" -> ";
			for(auto j:i.second){
				cout<<j<<" , ";
			}
			cout<<endl;
		}
	}
};
int main(){
	int n,m;
	cout<<"Enter the number of nodes:";
	cin>>n;
	cout<<"Enter the number of edges:";
	cin>>m;
	graph<int> g;
	for(int i=0;i<m;i++){
		int u,v;
		cin>>u>>v;
		// creating an undirected graph
		g.addEdge(u,v,0);
	}
	// printing graph
	g.printAdjList();
	return 0;
}

// Creating and Printing

#include <bits/stdc++.h> 
vector < vector < int >> printAdjacency(int n, int m, vector < vector < int >> & edges) {
    vector<int>ans[n];
    for(int i=0; i<m; i++)
    {
        int u=edges[i][0];
        int v=edges[i][1];
        ans[u].push_back(v);
        ans[v].push_back(u);
    }
    vector < vector < int >> adj(n);
    for(int i=0; i<n; i++) {
        adj[i].push_back(i);
        for (int j=0; j < ans[i].size(); j++) {
            adj[i].push_back(ans[i][j]);
        }
    }
    return adj;

}

// BFS Traversal ( Breadth First Search )

// Method-1
#include <bits/stdc++.h> 
void prepAdjList(unordered_map<int, set<int>> &adjlist, 
vector<pair<int, int>> &edges) {
    for (int i = 0; i < edges.size(); i++) {
        int u = edges[i].first;
        int v = edges[i].second;
        adjlist[u].insert(v);
        adjlist[v].insert(u);
    }
}
void bfs(unordered_map<int, set<int>> &adjlist, unordered_map<int, bool> &visited,vector<int> &ans, int node) {
    queue<int> q;
    q.push(node);
    visited[node] = 1;
    while (!q.empty()) {
        int frontNode = q.front();
        q.pop();
        ans.push_back(frontNode);
        for (auto i : adjlist[frontNode]) {
            if (!visited[i]) {
                q.push(i);
                visited[i] = 1;
            }
        }
    }
} 
vector<int> BFS(int vertex, vector<pair<int, int>> edges)
{
    unordered_map<int, set<int> > adjlist;
    unordered_map<int, bool> visited;
    vector<int> ans;
    prepAdjList(adjlist, edges);
    //traverse the tree
    for (int i = 0; i < vertex; i++) {
        if (!visited[i]) {
            bfs (adjlist, visited, ans, i);
        }
    }
    return ans;
}

// Method-2
class Solution {
  public:
    vector<int> bfsOfGraph(int V, vector<int> adj[]) {
        vector<int> res;
        bool visited[V+1];
        for(int i=0; i<V; ++i)
            visited[i] = false;
        queue<int> q;
        q.push(0);
        res.push_back(0);
        visited[0] = true;
        while(!q.empty()) {
            auto u = q.front();
            q.pop();
            for(int v : adj[u]) {
                if(!visited[v]) {
                    visited[v] = true;
                    q.push(v);
                    res.push_back(v);
                }
            }
        }
        return res;
    }
};

// DFS ( Depth First Search )

// Method-1
class Solution {
    // let's write the steps to make a dfs
    // at first write the algorithm for dfs and make it private
    // inside the dfs we do like;
    // at first we pass the necessary parameters
    // we make visited of the fist node to 1; i.e.vis[node]=1;
    // we even store the nodes in the list ;i.e ls.push_back(node)
    // then we have to iterate through the each node to find its adjacent nodes;i.e. 
    // for(auto it: adj[node])
    // inside the for loop we check for whether the node is visted or not
    // if the not is not visited we continue the dfs ;i.e.dfs(it,adj,vis,ls)
    // after the we write the necessary code in the public of the class 
    // we first initialize all the necessary variables which are passed in the dfs call
    // and in the last we return the list; i.e. return ls
    private:
    void dfs(int node,vector<int>adj[],int vis[],vector<int>&ls)
    {
       vis[node]=1;
       ls.push_back(node);
       for(auto it: adj[node])
       {
           if(!vis[it])
           {
               dfs(it,adj,vis,ls);
           }
       }
    }
    public:
    vector<int> dfsOfGraph(int V, vector<int> adj[]) {
        int vis[V]={0};
        vector<int> ls;
        int i=0;
        dfs(i,adj,vis,ls);  
        return ls;
    }
};

// Method-2
#include<bits/stdc++.h>
void dfs(int node, unordered_map<int,bool>&visited,unordered_map<int,list<int>>&adj, vector<int>&component)
{
    component.push_back(node);
    visited[node]=true;
    // hr connected node k liye recursive call
    for(auto i:adj[node] )
    {
        if(!visited[i])
        {
            dfs(i,visited,adj,component);
        }
    }
}
vector<vector<int>> depthFirstSearch(int V, int E, vector<vector<int>> &edges)
{
    //prepared adjList
    unordered_map<int,list<int>>adj;
    for(int i=0; i<edges.size() ; i++)
    {
        int u=edges[i][0];
        int v=edges[i][1];
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    vector<vector<int>> ans;
    unordered_map<int,bool>visited;
    // for of all node all dfs ,if not visited
    for(int i=0; i<V; i++ )
    {
        if(!visited[i])
        {
            vector<int>component;
            dfs(i,visited,adj,component);
            ans.push_back(component);
        }
    }
    return ans;
}

// Cycle Detection in undirected graphs

// Method-1
#include<bits/stdc++.h>
bool bfs( vector<int> adj[],vector<int> &vis,int node){
    queue <pair<int,int>> q;
    vis[node]=1;
    q.push({node,-1});
    while(!q.empty()){
        int node=q.front().first;
        int parent=q.front().second;
        q.pop();
        for(auto x:adj[node]){
            if(!vis[x])
            {
                vis[x]=1;
                q.push({x,node});
            }
            else if(x!=parent)
            return 1;
        }
    }
    return 0;
}
string cycleDetection (vector<vector<int>>& edges, int n, int m)
{   
    vector<int> adj[n+1];
    for(int i=0;i<m;i++){
        adj[edges[i][0]].push_back(edges[i][1]);
        adj[edges[i][1]].push_back(edges[i][0]);
    }
    vector<int> vis(n+1,0);
    for(int i=1;i<=n;i++){
        if(!vis[i]){
            if(bfs(adj,vis,i)) {
                return "Yes";
            }
        }
        
    }
    return "No";
}

// Method-2 ( Using DFS )
#include<bits/stdc++.h>
bool dfs(unordered_map<int,set<int>>&adj,unordered_map<int,bool>&vis,int node,int parent){
    vis[node]=1;
    for(int i:adj[node]){
        if((vis[i] && i!=parent) || (!vis[i] && dfs(adj,vis,i,node)) ){
            return 1;
        }
    }
    return 0;
}
string cycleDetection (vector<vector<int>>& edges, int n, int m){
    unordered_map<int,set<int>>adj;
    unordered_map<int,bool>vis;
    // Create a adjacency list
    for(int i=0;i<m;i++){
        adj[edges[i][0]].insert(edges[i][1]);
        adj[edges[i][1]].insert(edges[i][0]); 
    }
    // Traverse over all vertices and check for cyclic BFS
    for(int i=1;i<=n;i++){
        if(!vis[i] && dfs(adj,vis,i,-1)){
            return "Yes";
        }
    }
    return "No";
}

// Method 3 ( Using BFS )
#include<bits/stdc++.h>
bool cyclicBFS(unordered_map<int,set<int>>&adj,unordered_map<int,bool>&vis,int node){
    unordered_map<int,int>parent;
    queue<int>q;
    q.push(node),vis[node]=1,parent[node]=-1;
    while(!q.empty()){
        int front=q.front();
        q.pop();
        for(int i:adj[front]){
            if(vis[i] && i!=parent[front]){
                return 1;
            }
            if(!vis[i]){
                q.push(i),vis[i]=1,parent[i]=front;
            }
        }
    }
    return 0;
}
string cycleDetection (vector<vector<int>>& edges, int n, int m){
    unordered_map<int,set<int>> adj;
    unordered_map<int,bool> vis;
    // Create a adjacency list
    for(int i=0;i<m;i++){
        adj[edges[i][0]].insert(edges[i][1]);
        adj[edges[i][1]].insert(edges[i][0]); 
    }
    // Traverse over all vertices and check for cyclic BFS
    for(int i=1;i<=n;i++){
        if(!vis[i] && cyclicBFS(adj,vis,i)){
            return "Yes";
        }
    }
    return "No";
}

// Cycle detection in directed graph

// Method-1
#include <bits/stdc++.h>
bool cycle(int src, unordered_map<int, list<int>> &adj, unordered_map<int, bool> &visited, unordered_map<int, bool> &dfsCheck) {
  visited[src] = true;
  dfsCheck[src] = true;
  for (auto side : adj[src]) {
    if (!visited[side]) {
      bool ans = cycle(side, adj, visited, dfsCheck);
      if (ans)
        return true;
    } else if (dfsCheck[side]) {
      return true;
    }
  }
  dfsCheck[src] = false;
  return false;
}
int detectCycleInDirectedGraph(int n, vector<pair<int, int>> &edges) {
  unordered_map<int, list<int>> adj;
  for (int i = 0; i < edges.size(); i++) {
    int u = edges[i].first;
    int v = edges[i].second;
    adj[u].push_back(v);
  }
  unordered_map<int, bool> dfsCheck;
  unordered_map<int, bool> visited;
  for (int i = 1; i < n; i++) {
    if (!visited[i]) {
      bool ans = cycle(i, adj, visited, dfsCheck);
      if (ans == 1)
        return true;
    }
  }
  return false;
}

// Method-2
#include<bits/stdc++.h>
bool DFS(int node,unordered_map<int,bool> &vis,unordered_map<int,bool> &dfsvis,unordered_map<int,list<int>> &adj){
    vis[node] = 1;
    dfsvis[node] = 1;
    for(auto i:adj[node]){
      if(!vis[i]){
        bool present = DFS(i,vis,dfsvis,adj);
        if(present) return 1;
      }
      else if(dfsvis[i])
      // if Both vis & dfsvis of node is True then loop is present
       return 1;
    }
    dfsvis[node] = 0;
    return 0;
}
int detectCycleInDirectedGraph(int n,vector<pair<int,int>>&edges){
  //preparing adjacency list
  unordered_map<int,list<int>> adj;
  for(int i = 0;i<edges.size();i++){
    int u = edges[i].first;
    int v = edges[i].second;
    // directed graph
    adj[u].push_back(v);
  }
  unordered_map<int,bool> vis;
  unordered_map<int,bool> dfsvis;
  for(int i =1;i<=n;i++){
    if(!vis[i]){
      bool present = DFS(i,vis,dfsvis,adj);
      if(present) return 1;
    }
  }
  return 0;
}

// Topological Sort

// Method-1
// topology sort using bfs i.e KAHN'S algorithm
vector<int> topologicalSort(vector<vector<int>> &edges, int v, int e)
{
    //create adj list
     unordered_map<int,list<int>>adj;
    for(int i=0;i<e;i++)
    {
        int u=edges[i][0];
        int v=edges[i][1];
        adj[u].push_back(v);
    }
    //store indegree of nodes
    vector<int>indegree(v);
    for(auto i:adj)
    {
        for(auto j:i.second)
        {
            indegree[j]++;
        }
    }
    //0 indegree the push in queue;
    queue<int>q;
    for(int i=0;i<v;i++)
    {
        if(indegree[i]==0)
        {
            q.push(i);
        }
    }
    //update indegree
    vector<int>ans;
    while(!q.empty())
    {
        int front=q.front();
        q.pop();
        ans.push_back(front);
        for(auto i:adj[front])
        {
            indegree[i]--;
            if(indegree[i]==0)
            {
                q.push(i);
            }
        }
    }
    return ans;
}

// Method-2
#include<bits/stdc++.h>
//TopologySort using dfs
void toposort(int node,vector<bool> &visited,stack<int> &s,unordered_map<int,list<int>> &adj)
{
    visited[node]=1;
    for(auto i:adj[node])
    {
        if(!visited[i])
        {
            toposort(i,visited,s,adj);
        }
    }
    s.push(node);
}

vector<int> topologicalSort(vector<vector<int>> &edges, int v, int e)  {
  
    unordered_map<int,list<int>>adj;
    for(int i=0;i<e;i++)
    {
        int u=edges[i][0];
        int v=edges[i][1];
        adj[u].push_back(v);
    }
    vector<bool>visited(v);
    stack<int>s;
    for(int i=0;i<v;i++)
    {
        if(!visited[i])
        {
            toposort(i,visited,s,adj);
        }
    }
    vector<int>ans;
    while(!s.empty())
    {
        ans.push_back(s.top());
        s.pop();
    }
    return ans;
}

// Shortest Path in an undirected graph

#include<bits/stdc++.h>
vector<int> shortestPath( vector<pair<int,int>> edges , int n , int m, int s , int t){
    // ADJ LIST
    unordered_map<int,list<int>>adj;
    for(int i=0; i<edges.size();i++)
    {
        int u=edges[i].first;
        int v= edges[i].second;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    //do bfs
    unordered_map<int,bool>visited;
    unordered_map<int,int>parent;
    queue<int>q;
    q.push(s);
    parent[s]=-1;
    visited[s]=true;
    while(!q.empty())
	{
        int front=q.front();
        q.pop();
        for(auto neighbour :adj[front])
        {
            if(!visited[neighbour])	
            {
                visited[neighbour]=true;
                parent[neighbour]=front;
                q.push(neighbour);
			}
        }
    }
    // prepare short path
    vector<int>ans;
    int currentnode= t;
    ans.push_back(t);
    while(currentnode!=s)
    {
        currentnode=parent[currentnode];
        ans.push_back(currentnode);
    }
    reverse(ans.begin(),ans.end());
    return ans;
}

// Shortest Path in an directed graph

#include <bits/stdc++.h>
using namespace std;
// Graph class implemented using an adjacency list
class Graph{
public:
    int V;  // Number of Vertices
    int E;  // Number of Edges
    vector<pair<int, int>> *adj; // adjacency list
    Graph(int num_vertices, int num_edges){
        this->V = num_vertices
        this->E = num_edges;
        this->adj = new vector<pair<int, int>>[num_vertices];
    }
    // function to add Edge
    void addEdge(int u, int v, int w){
        adj[u].push_back({v, w});
    }
    // function that returns the topSort ordering of nodes in a graph
    vector<int> topSort(int src){
        //inDegree vector
        vector<int> indegree(V, 0);
        // update the indegree of each node in the graph
        for(int i=0;i<V;++i){
            for(pair<int, int> node:this->adj[i]){
                indegree[node.first]++;
            }
        }
        // queue 
        queue<int> q;
        // push all nodes with 0 in degree in the queue
        for(int i=0;i<V;++i){
            if(indegree[i]==0)
                q.push(i);
        }
        // vector to store topSortOrdering        
        vector<int> topSortOrdering;
        // run until queue is empty
        while(!q.empty()){
            // pop the front node
            int u = q.front();
            q.pop();
            // since it has 0 indegree it will occur before all elements  with non-0 indegree currently
            topSortOrdering.push_back(u);
            // decrement the indegree of adjacent nodes of the popped node by 1
            for(pair<int, int> node:this->adj[u]){
                indegree[node.first]--;
                // if the indegree of the node is 0
                if(indegree[node.first]==0){
                    // push it to the queue
                    q.push(node.first);
                }
            }
        }
        // return the topSortOrdering        
        return topSortOrdering;
    }
    //find all the shortest path distances
    void findShortestPathInDAG(int src){
        // distance vector from the src node
        vector<int> distances(V, INT_MAX);
        // find the topSort ordering        
        vector<int> topSortOrdering = topSort(src);
        // initially mark the distance from the source node to itself as 0
        distances[src]=0;
        // for each vertex in topSortOrdering
        for(int x:topSortOrdering){
            // if current vertex weight is not INT_MAXinity
            if(distances[x]!=INT_MAX){
                // traverse all the adjacent Edges
                for(pair<int, int> adjNode : this->adj[x]){
                    // relax the edges
                    if(distances[adjNode.first] > distances[x]+adjNode.second){
                        distances[adjNode.first] = distances[x]+adjNode.second;
                    }
                }   
            }
        }
        // print the final distances
        cout<<"The distances from the src node are: ";
        for(int i=0;i<V;++i){
            if(distances[i]==INT_MAX) cout<<"INF ";
            else cout<<distances[i]<<" ";
        }
    }
};
int main() {
    // Number of Edges and Vertices
    int num_vertices = 6;
    int num_edges = 9;
    Graph G(num_vertices, num_edges); // Graph G   
    // add all edges to graph
    G.addEdge(1, 3, 6);
    G.addEdge(1, 2, 2);
    G.addEdge(0, 1, 5);
    G.addEdge(0, 2, 3);
    G.addEdge(3, 4, -1);
    G.addEdge(2, 4, 4);
    G.addEdge(2, 5, 2);
    G.addEdge(2, 3, 7);
    G.addEdge(4, 5, -2);
    // compute the Shortest_path
    int src = 1; 
    G.findShortestPathInDAG(src);
    return 0;
}

// Djikstra's Algorithm

#include <bits/stdc++.h> 
vector<int> dijkstra(vector<vector<int>> &vec, int V, int edges, int S) {
    // create adjacency List
    unordered_map<int,list<pair<int,int>>>adj;
    for(int i= 0;i<edges;i++){
        int u = vec[i][0];
        int v = vec[i][1];
        int wt = vec[i][2];
        adj[u].push_back({v,wt});
        adj[v].push_back({u,wt});
    }
    vector<int>dist(V,INT_MAX);
    set<pair<int,int>>st;
    dist[S] = 0;
    st.insert({0,S});
    while(!st.empty()){
        auto it = *(st.begin());
        int NodeDist= it.first;
        int u = it.second;
        st.erase(it);
        for(auto i:adj[u]){
            int edgeWt = i.second;
            int adjNode = i.first;
            if(NodeDist+ edgeWt< dist[adjNode]){
                if(dist[adjNode] != INT_MAX)
                        st.erase({dist[adjNode], adjNode});
                    dist[adjNode] = NodeDist+ edgeWt;
                    st.insert({dist[adjNode],adjNode});
            }
        }
    }
    return dist;
}

// Prim's Algorithm for Minimum Spanning Tree

#include <bits/stdc++.h> 
vector<pair<pair<int, int>, int>> calculatePrimsMST(int n, int m, vector<pair<pair<int, int>, int>> &g)
{ 
    vector<pair<int, int>> adj[n+1];
    for(auto it: g){
        adj[it.first.first].push_back({it.first.second, it.second});
        adj[it.first.second].push_back({it.first.first, it.second});
    }
    priority_queue<pair<pair<int, int>, int>, vector<pair<pair<int, int>, int>>, greater<pair<pair<int, int>, int>>> pq;
        vector<int> vist(n+1, 0);
        vector<pair<pair<int, int>, int>> mst;
        // {wt, node}
        pq.push({{0, 1}, -1}); 
        while(!pq.empty()){
            auto it = pq.top();
            pq.pop();
            int wt = it.first.first;
            int node = it.first.second;
            int parent = it.second;
            if(vist[node] == 1) continue; // if already visisted
            vist[node] = 1; // else mark it visited only after popping out of the min-heap
            if(parent != -1) mst.push_back({{parent, node}, wt});
            // sum += wt; // add the edge weight to sum
            for(auto it: adj[node]){
                int adjNode = it.first;
                int edgwt = it.second;
                
                if(!vist[adjNode])
                    pq.push({{edgwt, adjNode}, node});
            }
        }
    return mst;
}

// Kruskal's Algorithm

#include<bits/stdc++.h>
void make_set(int v, vector <int> &parent, vector <int> &rank) {
    parent[v] = v;
    rank[v] = 0;
}

// Returns the parent of the set that contains the element v.
int find_set(int v, vector <int> &parent) {
    if (v == parent[v]) {
        // Current element is the parent of its set.
        return v;
    } else {
        // Using path compression technique.
        return parent[v] = find_set(parent[v], parent);
    }
}

// Merges the two specified sets.
void union_sets(int a, int b, vector <int> &parent, vector <int> &rank) {
    // Find the parent of both elements.
    a = find_set(a, parent);
    b = find_set(b, parent);

    if (a != b) {
        if (rank[a] < rank[b]) {
            // Swap.
            swap(a, b);
        }
        parent[b] = a;
        if (rank[a] == rank[b]) {
            rank[a]++;
        }
    }
}

// Custom comparator to sort the edges.
bool compare(vector <int> const &a, vector <int> const &b) {
    return a[2] < b[2];
}

int kruskalMST(int n, int m, vector <vector<int> > &graph) {
    // Parent and rank arrays to be used in DSU.
    vector <int> parent(n);
    vector <int> rank(n);

    for (int i = 1; i <= n; i++) {
        // Create a new set for each node.
        make_set(i, parent, rank);
    }

    // To store the weight of MST.
    int cost = 0;

    // Sort the edges in ascending order by its weight.
    sort(graph.begin(), graph.end(), compare);

    // Start traversign through the edges.
    for (auto edge: graph) {
        // Check if both vertices of current edge belong to different sets(subtrees).
        if (find_set(edge[0], parent) != find_set(edge[1], parent)) {
            // Add the weight of the current edge.
            cost = cost + edge[2];

            // Merge the two sets(subtrees).
            union_sets(edge[0], edge[1], parent, rank);
        }
    }
    return cost;
}

// Bridge in a graph

#include <bits/stdc++.h>
void dfs(int node, vector<vector<int>> &result, vector<int> &low,
         vector<int> &disc, int &timer, unordered_map<int, list<int>> &adj,
         int parent, unordered_map<int, bool> &vis) {
    vis[node] = true;
    low[node] = disc[node] = timer++;

    for (auto nebr : adj[node]) {
        if (nebr == parent) {
            continue;
        }
        if (!vis[nebr]) {
            dfs(nebr, result, low, disc, timer, adj, node, vis);
            low[node] = min(low[node], low[nebr]); // check bridges
            if (low[nebr] > disc[node]) {
                vector<int> ans;
                ans.push_back(node);
                ans.push_back(nebr);
                result.push_back(ans);
            }
        } 
        else { // back edges
            low[node] = min(low[node], disc[nebr]);
        }
    }
}
vector<vector<int>> findBridges(vector<vector<int>> &edges, int v, int e) {
  unordered_map<int, list<int>> adj;
  for (int i = 0; i < edges.size(); i++) {
    int u = edges[i][0];
    int v = edges[i][1];

    adj[u].push_back(v);
    adj[v].push_back(u);
  }

  int timer = 0;
  vector<int> low(v);
  vector<int> disc(v);
  int parent = -1;
  unordered_map<int, bool> vis;

  for (int i = 0; i < v; i++) {
    low[i] = -1;
    disc[i] = -1;
  }

  vector<vector<int>> result; // dfs
  for (int i = 0; i < v; i++) {
    if (!vis[i]) {
      dfs(i, result, low, disc, timer, adj, parent, vis);
    }
  }

  return result;
}

// Articulation Points in a graph

#include <bits/stdc++.h>
using namespace std;
// A function to add edges in the graph.
void addEdge(vector<vector<int>> &adj, int u, int v)
{
    adj[u].push_back(v);
    adj[v].push_back(u);
}

void APUtil(vector<vector<int>> &adj, vector<bool> &visited, vector<int> &disc, vector<int> &low, int &time, int u, int parent, vector<bool> &AP)
{
    // To count the children in the DFS Tree.
    int child = 0;
    visited[u] = true;

    // Initialise the discovery time and the low value for u.
    disc[u] = ++time;
    low[u] = time;

    for (auto v : adj[u]) {
        // If v is not visited yet, make it a child of u in the DFS tree and repeat for it.
        if (!visited[v]) {
            child++;
            APUtil(adj, visited, disc, low, time, v, u, AP);

            // Check if the subtree rooted at v has a back edge to the ancestors of u.
            low[u] = min(low[u], low[v]);

            // If u is not the root and the low value of one of its children is more than the discovery time value of u.
            if (low[v] >= disc[u] && parent != -1)
                AP[u] = true;
        }

        // Update low value of u for the parent function calls.
        else if (v != parent)
            low[u] = min(low[u], disc[v]);
    }

    // Case 1, if u is the root of the DFS tree and has more than one child.
    if (parent == -1 && child > 1)
        AP[u] = true;
}

void AP(vector<vector<int>> &adj, int V)
{
    vector<int> disc(V);

    vector<int> low(V);

    vector<bool> visited(V, false);

    vector<bool> AP(V, false); 
    int time = 0;
    int par = -1;

    // Using the for loop so that the code works for disconnected the graph.
    for (int u = 0; u < V; ++u){
         if (!visited[u])
             APUtil(adj, visited, disc, low, time, u, par, AP);
    }

    // Printing the Articulation points.
    for (int i = 0; i < V; i++){
        if (AP[i] == true)
            cout << i << " ";
    }
}

int main()
{
    cout << "Articulation points: ";
    int V = 5;
    int E = 6;
    vector<vector<int>> adj(V);
    addEdge(adj, 1, 0);
    addEdge(adj, 0, 4);
    addEdge(adj, 1, 4);
    addEdge(adj, 2, 3);
    addEdge(adj, 2, 4);
    addEdge(adj, 3, 4);
    AP(adj, V);
    return 0;
}

// Kosaraju's Algorithm

#include <bits/stdc++.h> 
    void dfs(int node,vector<int>adj[],stack<int>&st,vector<int>&vis){
        vis[node]=1;
        for(auto it:adj[node]){
            if(!vis[it])
                dfs(it,adj,st,vis);
        }
        st.push(node);
    }
        void dfsStep3(int node,vector<int>adjT[],vector<int>&vis){
            vis[node]=1;
            for(auto it:adjT[node])
                if(!vis[it])
                    dfsStep3(it,adjT,vis);
        }
        void getAdjacencyList(vector<vector<int>> &edges, int e, vector<int> adj[]){
    for(int i=0; i<e; i++){
        int u = edges[i][0];
        int v = edges[i][1];
        adj[u].push_back(v);
    }
}
int stronglyConnectedComponents(int V, vector<vector<int>> &edges)
{
        //step 1 sort all the edges acc to finishing time
	vector<int> adj[V];
	int e = edges.size();
    getAdjacencyList(edges, e, adj);

        vector<int>vis(V,0);
        stack<int>st;
        for(int i =0;i<V;i++){
            if(!vis[i])
                dfs(i,adj,st,vis);
        }
    //step 2 reverse Graph
    vector<int>adjT[V];//denotes transpose adjacency list or reversed one
    for(int i=0;i<V;i++){
        vis[i] = 0; //hum bus yaha ye is liye kar rahe take vis array fir se re use kar sake
        for(auto it:adj[i]){
            //currently i is connected to it or i->it
            // now we want it ->i
            adjT[it].push_back(i);
        }
    }
    //step-3
    int sccCount=0;
    while(!st.empty()){
        int node = st.top();
        st.pop();
        if(!vis[node]){
            sccCount++;
            dfsStep3(node,adjT,vis);
        }
    }
    return sccCount;
}

// Bellman Ford Algorithm

#include <bits/stdc++.h> 
int bellmonFord(int n, int m, int src, int dest, vector<vector<int>> &edges) {
    vector<int> dist(n+1, 1e9);
    dist[src] = 0;
    for (int i=1; i<=n; i++){
        for (int j=0; j<m; j++){
            int u = edges[j][0];
            int v = edges[j][1];
            int wt = edges[j][2];
            if (dist[u] != 1e9 && ((dist[u]+wt) < dist[v])){
                dist[v] = dist[u]+wt;
            }
        }
    }
    return dist[dest];

    // if -ve cycle is present
    // bool flag = 0;
    // for (int j=0; j<m; j++){
    //     int u = edges[j][0];
    //     int v = edges[j][1];
    //     int wt = edges[j][2];
    //     if (dist[u] != 1e9 && ((dist[u]+wt) < dist[v])){
    //         bool flag = 1;
    //     }
    // }
    // if (flag == 0){
    //     return dist[dest];
    // }
    // return -1;
}

// Dynamic Programming
// Method-1 => Top - Down Approach -> Recursion + Memoization
// Method-2 => Bottom - Up -> Tabulation

// Fibonacci Series

// USING TOP -DOWN
// #include<bits/stdc++.h>
// using namespace std;
// int fib(int n,vector<int> &dp){
//         if(n <= 1){
//                 return n;
//         }
//         if(dp[n] != -1)return dp[n];
//         dp[n] = fib(n-1,dp)+fib(n-2,dp);
//         return dp[n];
// }
// int main()
// {
//      int n;
//      cin>>n;
//      vector<int> dp(n+1,-1);
//      for(int i=0;i<n;i++)
//              dp[i] = -1;
//      cout<<fib(n,dp);
//      return 0;
// }

//USING BOTTOM'S UP....
// #include<bits/stdc++.h>
// using namespace std;
// int main()
// {
//         int n;
//         cin >> n;
//         vector<int> dp(n+1);
//         dp[0] =0;
//         dp[1] =1;
//         for(int i=2;i<=n;i++){
//             dp[i] = dp[i-1] + dp[i-2];
//         }
//         cout<<dp[n] << endl;
// }

// Space Optimized Solution

#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	cin>>n;
	int prev1=0;
	int prev2=1;
	if(n==0) return prev1;
	for(int i=2;i<=n;i++){
		int curr=prev1+prev2;
		prev1=prev2;
		prev2=curr;
	}
    cout<<prev2<<endl;
}

// Minimmum cost climbing stairs

// Top-Down Approach
#include <bits/stdc++.h>
#define mod 1000000007
int f(int i, vector<long long> &dp, int n) {
  if (i == n)
    return 1;
  if (i > n)
    return 0;
  if (dp[i] != -1)
    return dp[i];
  return dp[i] = (f(i + 1, dp, n) + f(i + 2, dp, n)) % mod;
}
int countDistinctWays(int n) {
  vector<long long> dp(n + 1, -1);
  return f(0, dp, n);
}

// Bottom-Up Approach
#include <bits/stdc++.h> 
#define mod 1000000007

int countDistinctWays(int nStairs) {
     vector<int>dp(nStairs+1,-1);
   dp[0]=1;
   dp[1]=1;
   for(int i=2;i<=nStairs;i++)
   {
       int steps=dp[i-1]%mod;
   int step1=dp[i-2]%mod;
    dp[i]=steps+step1;
   }
   return dp[nStairs]%mod;
}

// Space Optimized
#include <bits/stdc++.h> 
#define mod 1000000007
int countDistinctWays(int nStairs) {
    int n=nStairs;
    int prev1=1;
    int prev2=1;
    int curr;
    if(n==1 || n==0)
        return 1;
    for(int i=2;i<=n;i++){
        curr=(prev1+prev2)%mod;
        prev1=prev2;
        prev2=curr;
    }
    return curr%mod;
}

// Minimum Number of coins

1. Naive Recursive approach (TLE)
Time complexity: O(2^n)
Space complexity: Stack Space
class Solution {
public:
    int count(vector<int>&coins, int amount, int n){
        if(amount==0) return 0;
        if(n==0 && amount>0) return INT_MAX-1;
        int res=0;
        if(amount>=coins[n-1]){
            int take=1+count(coins, amount-coins[n-1], n);
            int dontTake=count(coins, amount, n-1);
            res=min(take, dontTake);
        }
        else{
            res=count(coins, amount, n-1);
        } 
        return res;
    }
    int coinChange(vector<int>& coins, int amount) {
        if(amount == 0) return 0;
        int n=coins.size();
        int res= count(coins, amount, n);
        if(res==INT_MAX-1) return -1;
        else return res;
    }
};
2. Memoization(DP-TLE)
Time complexity: O(N*amount)
Space complexity: O(N*amount)+Stack Space
class Solution {
public:
    int count(vector<int>&coins, int amount, int n, vector<vector<int>>&memo){
        if(amount==0) return 0;
        if(n==0 && amount>0) return INT_MAX-1;
        int res=0;
        if(amount>=coins[n-1]){
            int take=1+count(coins, amount-coins[n-1], n, memo);
            int dontTake=count(coins, amount, n-1, memo);
            res=min(take, dontTake);
        }
        else{
            res=count(coins, amount, n-1, memo);
        } 
        return memo[n][amount]=res;
    }
    int coinChange(vector<int>& coins, int amount) {
        if(amount == 0) return 0;
        if(coins.size()==1 && coins[0]>amount) return -1;
        int n=coins.size();
        vector<vector<int>>memo(n+1, vector<int>(amount+1, -1));
        int res= count(coins, amount, n, memo);
        if(res==INT_MAX-1) return -1;
        else return res;
    }
};
3. Tabulation(DP)
Time complexity: O(N*amount)
Space complexity: O(N*amount)
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        if(amount == 0) return 0;
        int n=coins.size();
        vector<vector<int>>dp(n+1, vector<int>(amount+1, -1));
        for(int i=0;i<=n;i++){
            dp[i][0]=0;
        }
        for(int i=1;i<=amount;i++){
            dp[0][i]=INT_MAX-1;
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=amount;j++){
                if(j>=coins[i-1]) dp[i][j]=min(1+dp[i][j-coins[i-1]], dp[i-1][j]);
                else dp[i][j]=dp[i-1][j];
            }
        }
        int res= dp[n][amount];
        if(res==INT_MAX-1) return -1;
        else return res;
    }
};
4. Optimized Space (BEST Approach)
Time complexity: O(N*amount)
Space complexity: O(amount)
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        if(amount == 0) return 0;
        int n=coins.size();
        vector<int>dp(amount+1);
        dp[0]=0;
        for(int i=1;i<=amount;i++){
            dp[i]=INT_MAX-1;
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=amount;j++){
                if(j>=coins[i-1]) dp[j]=min(1+dp[j-coins[i-1]], dp[j]);
                else dp[j]=dp[j];
            }
        }
        int res= dp[amount];
        if(res==INT_MAX-1) return -1;
        else return res;
    }
};

// Max Sum of non-adjacent elements

// Recursion
#include <bits/stdc++.h> 
int solveRec(vector<int> &nums,int n){
    if(n<0){
        return 0;
    }
    if(n==0){
        return nums[0];
    }
    int incl = solveRec(nums, n-2)+nums[n];
    int excl = solveRec(nums, n-1)+0;
    return max(incl,excl);
}
int maximumNonAdjacentSum(vector<int> &nums){
    int n= nums.size()-1;
    int ans = solveRec(nums,n);
    return ans;
}  

// Memoization
#include <bits/stdc++.h>
int solveMem(vector<int> &nums,int n,vector<int> &dp){
    if(n<0){
        return 0;
    }
    if(n==0){
        return nums[0];
    }
    if(dp[n]!=-1) return dp[n];
    int incl = solveMem(nums, n-2,dp)+nums[n];
    int excl = solveMem(nums, n-1,dp)+0;

    dp[n] = max(incl,excl);
    return dp[n];
}
int maximumNonAdjacentSum(vector<int> &nums){
    int n= nums.size();
    vector<int> dp(n,-1);
    int ans = solveMem(nums,n-1,dp);
    return ans;
}

// Tabulation
#include <bits/stdc++.h>
int solveTab(vector<int> &nums){
    int n = nums.size();
    vector<int>dp(n,0);
    dp[0] = nums[0];
    for (int i = 1; i < n; i++) {
      int incl = dp[i - 2] + nums[i];
      int excl = dp[i - 1] + 0;
      dp[i] =max(incl,excl);
    }
    return dp[n-1];
}
int maximumNonAdjacentSum(vector<int> &nums){
    return solveTab(nums);
}

// Space Optimized
#include <bits/stdc++.h>
int solveSpaceOptimise(vector<int> &nums){
    int n = nums.size();
    int prev2 = 0;
    int prev1 = nums[0];
    for (int i = 1; i < n; i++) {
      int incl = prev2 + nums[i];
      int excl = prev1 + 0;
      int ans =max(incl,excl);
      prev2 = prev1;
      prev1 = ans;
    }
    return prev1;
}
int maximumNonAdjacentSum(vector<int> &nums){
    return solveSpaceOptimise(nums);
}

// House Robber

// Recursive + Memoization

class Solution
{
    // Time Complexity : O(n)
    // Space Complexity : O(n) + O(n)
private:
    int solve(int i, vector<int> &nums, vector<int> &dp)
    {
        if (i == 0)
            return nums[0];
        if (i < 0)
            return 0;
        if (dp[i] != -1)
            return dp[i];
        int pick = nums[i] + solve(i - 2, nums, dp);
        int notPick = 0 + solve(i - 1, nums, dp);
        return dp[i] = max(pick, notPick);
    }
public:
    int rob(vector<int> &nums)
    {
        int n = nums.size();
        if (n == 1)
            return nums[0];
        vector<int> dp(n, -1);
        solve(n - 1, nums, dp);
        return dp[n - 1];
    }
};

// Tabulation

class Solution
{

    // Time Complexity : O(n)
    // Space Complexity : O(n)
public:
    int rob(vector<int> &nums)
    {
        int n = nums.size();
        vector<int> dp(n, -1);
        dp[0] = nums[0];
        for (int i = 1; i < n; i++)
        {
            int pick = nums[i];
            if (i > 1)
            {
                pick += dp[i - 2];
            }
            int notPick = 0 + dp[i - 1];
            dp[i] = max(pick, notPick);
        }
        return dp[n - 1];
    }
};

// Space Optimized

class Solution
{
    // Time Complexity : O(n)
    // Space Complexity : O(1)
public:
    int rob(vector<int> &nums)
    {
        int n = nums.size();
        int prev2 = 0, prev = nums[0];
        for (int i = 1; i < n; i++)
        {
            int pick = nums[i] + prev2;
            int notPick = 0 + prev;
            int curr = max(pick, notPick);
            prev2 = prev;
            prev = curr;
        }
        return prev;
    }
};

// House Robber II

// Recursive+Memoization

#include <bits/stdc++.h> 
long long int solve(int index,vector<long long int>& valueInHouse,vector<long long int>& dp){
    //base case
    if(index<0)
        return 0;
    if(index==0)
        return valueInHouse[0];
    if(dp[index]!=-1)
        return dp[index];
    long long int include=valueInHouse[index]+solve(index-2,valueInHouse,dp);
    long long int exclude=solve(index-1,valueInHouse,dp);
    dp[index]=max(include,exclude);
    return max(include,exclude);

}
long long int houseRobber(vector<int>& valueInHouse)
{
    
    int n=valueInHouse.size();
    if(n==1)
        return valueInHouse[0];
    vector<long long int>first,last;
    vector<long long int>dp1(n,-1),dp2(n,-1);
    for(int i=0;i<n;i++){
        //storing a vector without the last element
        if(i!=n-1)
            last.push_back(valueInHouse[i]);
        //storing a vector without the first element
        if(i!=0)
            first.push_back(valueInHouse[i]);
    }
    //checks which one has maximum roberry value
    long long int ans1= solve(n-2,first,dp1);
    long long int ans2= solve(n-2,last,dp2);
    return max(ans1,ans2);
}

// Tabulation

#include <bits/stdc++.h> 
long long int solve(vector<int>& valueInHouse){
    int n=valueInHouse.size();
    vector<int>dp(n,0);
    dp[0]=valueInHouse[0];
    for(int i=1;i<n;i++){
        long long int include=dp[i-2]+valueInHouse[i];
        long long int exclude=dp[i-1];
        dp[i]=max(include,exclude);
    }
    return dp[n-1];
}
long long int houseRobber(vector<int>& valueInHouse)
{
    int n=valueInHouse.size();
    //if there is only 1 house to robber
    if(n==1)
        return valueInHouse[0];
    vector<int>first,last;
    for(int i=0;i<n;i++){
        //vector without 1st element
        if(i!=0)
            first.push_back(valueInHouse[i]);
        //vector without last element
        if(i!=n-1)
            last.push_back(valueInHouse[i]);
    }
    long long int ans1=solve(first);
    long long int ans2=solve(last);
    return max(ans1,ans2);
}

// Space Optimized

#include <bits/stdc++.h> 
long long int solve(vector<int>& valueInHouse){
    int n=valueInHouse.size();
   long long int prev2=0,prev1=valueInHouse[0],sum=0;
    
    for(int i=1;i<n;i++){
        long long int include=prev2+valueInHouse[i];
        long long int exclude=prev1;
        sum=max(include,exclude);
        prev2=prev1;
        prev1=sum;
    }
    return sum;
}
long long int houseRobber(vector<int>& valueInHouse)
{
    int n=valueInHouse.size();
    //if there is only 1 house to robber
    if(n==1)
        return valueInHouse[0];
    vector<int>first,last;
    for(int i=0;i<n;i++){
        //vector without 1st element
        if(i!=0)
            first.push_back(valueInHouse[i]);
        //vector without last element
        if(i!=n-1)
            last.push_back(valueInHouse[i]);
    }
    long long int ans1=solve(first);
    long long int ans2=solve(last);
    return max(ans1,ans2);
}

// Cut rod into segments

// Recursion
#include<bits/stdc++.h>
int Recursion(int n, int x, int y, int z){
	// base case
	if (n == 0) return 0;
	if (n < 0) return INT_MIN;
	// Rest three segment
	int x_segment = Recursion(n-x, x, y, z) + 1;
	int y_segment = Recursion(n-y, x, y, z) + 1;
	int z_segment = Recursion(n-z, x, y, z) + 1;
	return max(x_segment, max(y_segment, z_segment));
}
int cutSegments(int n, int x, int y, int z) {
	int ans = Recursion(n, x, y, z);
	if (ans < 0) return 0;
	return ans;
}

// Recursion + Memoization
#include<bits/stdc++.h>
int RecurMemo(int n, int x, int y, int z, vector<int> &dp){
	// base case
	if (n == 0) return 0;
	if (n < 0) return INT_MIN;
	if (dp[n] != -1) return dp[n];

	// Rest three segment
	int x_segment = RecurMemo(n-x, x, y, z, dp) + 1;
	int y_segment = RecurMemo(n-y, x, y, z, dp) + 1;
	int z_segment = RecurMemo(n-z, x, y, z, dp) + 1;

	dp[n] = max(x_segment, max(y_segment, z_segment));
	return dp[n];
}
int cutSegments(int n, int x, int y, int z) {
	vector<int> dp(n+1, -1);
	int ans = RecurMemo(n, x, y, z, dp);
	if (ans < 0) return 0;
	return ans;
}

// Tabulation
#include<bits/stdc++.h>
int Tabulation(int n, int x, int y, int z){
	vector<int> dp(n+1, INT_MIN);
	dp[0] = 0;
	// 1 to n
	for (int i=1; i<=n; i++){
		if (i-x >= 0){
			dp[i] = max(dp[i], dp[i-x]+1);
		}
		if (i-y >= 0){
			dp[i] = max(dp[i], dp[i-y]+1);
		}
		if (i-z >= 0){
			dp[i] = max(dp[i], dp[i-z]+1);
		}
	}
	if (dp[n] < 0) return 0;
	return dp[n];
}
int cutSegments(int n, int x, int y, int z) {
	return Tabulation(n, x, y, z);
}

// Count dearrangements

// Recursive+Memoization
#include <bits/stdc++.h> 

typedef long long ll;
ll mod=1e9+7;
ll helper(int n,vector<ll>&dp) {
  if(n<=1) {
    return dp[n]=0;
  }
  if(n==2) {
    return dp[n]=1;
  }
  if(dp[n]!=-1) {
    return dp[n];
  }
  if(dp[n-1]==-1) {
    dp[n-1]=helper(n-1,dp)%mod;
  }
  if(dp[n-2]==-1) {
    dp[n-2]=helper(n-2,dp)%mod;
  }
  return dp[n]=((n-1)*((dp[n-1]+dp[n-2])%mod))%mod;
}

ll countDerangement(int n) {
  vector<ll>dp(n+1,-1);
  return helper(n,dp);
}

// Tabulation
#include <bits/stdc++.h> 
long long int countDerangement(int n) 
{
    long long mod=1e9+7;
    vector<int> DP(n + 1);
    DP[1] = 0;
    DP[2] = 1;
    for(int i = 3; i <= n; i++)
      DP[i] = ((i - 1)*((DP[i - 1] + DP[i - 2])%mod))%mod;
    return DP[n];
}

// Ninja and fence

// Recursion
#include <bits/stdc++.h> 
#define MOD 1000000007
int add(int a, int b){
    return ( (a%MOD) + (b%MOD) )%MOD;
}
int mul(int a, int b){
    return ( ( (a%MOD) * 1LL) * ( (b%MOD) * 1LL) )%MOD;
}
int Recursion(int n, int k){
    // base case
    if (n == 1) return k;
    if (n == 2) return add(k, mul(k, k-1));
    int ans = add( (mul(Recursion(n-2, k), k-1) ), ( (mul(Recursion(n-1, k), k-1) ) ) );
    return ans;
}
int numberOfWays(int n, int k) {
    return Recursion(n, k);
}

// Recursive+Memoization
#include <bits/stdc++.h> 
#define MOD 1000000007
int add(int a, int b){
    return ( (a%MOD) + (b%MOD) )%MOD;
}
int mul(int a, int b){
    return ( ( (a%MOD) * 1LL) * ( (b%MOD) * 1LL) )%MOD;
}
int RecurMemo(int n, int k, vector<int> &dp){
    // base case
    if (n == 1) return k;
    if (n == 2) return add(k, mul(k, k-1));
    if (dp[n] != -1) return dp[n];
    dp[n] = add( (mul(RecurMemo(n-2, k, dp), k-1) ), ( (mul(RecurMemo(n-1, k, dp), k-1) ) ) );
    return dp[n];
}
int numberOfWays(int n, int k) {
    vector<int> dp(n+1, -1);
    return RecurMemo(n, k, dp);
}

// Tabulation
#include <bits/stdc++.h> 
#define MOD 1000000007
int add(int a, int b){
    return ( (a%MOD) + (b%MOD) )%MOD;
}
int mul(int a, int b){
    return ( ( (a%MOD) * 1LL) * ( (b%MOD) * 1LL) )%MOD;
}
int Tabulation(int n, int k){
    vector<int> dp(n+1, -1);
    dp[1] = k;
    dp[2] = add(k, mul(k, k-1));
    for (int i=3; i<=n; i++){
        dp[i] = add( (mul(dp[i-2], k-1)), (mul(dp[i-1], k-1)) );
    }
    return dp[n];
}
int numberOfWays(int n, int k) {
    return Tabulation(n, k);
}

// Space Optimized
#include <bits/stdc++.h> 
#define MOD 1000000007
int add(int a, int b){
    return ( (a%MOD) + (b%MOD) )%MOD;
}
int mul(int a, int b){
    return ( ( (a%MOD) * 1LL) * ( (b%MOD) * 1LL) )%MOD;
}
int Space_Optimize(int n, int k){
    int prev2 = k;
    int prev1 = add(k, mul(k, k-1));
    for (int i=3; i<=n; i++){
        int ans = add( (mul(prev2, k-1)), (mul(prev1, k-1)) );
        prev2 = prev1;
        prev1 = ans;
    }
    return prev1;
}
int numberOfWays(int n, int k) {
    return Space_Optimize(n, k);
}

// 0/1 Knapsack Problem

// Recursion
#include <bits/stdc++.h> 
int Rec(vector<int> &weight, vector<int> &value, int n, int W){
    if(n==0){
        if(weight[0]<=W)
            return value[0];
        else
            return 0;
    }
    int incl = 0;
    if(weight[n]<=W)
    incl = value[n] + Rec(weight,value,n-1,W-weight[n]);
    int excl = Rec(weight,value,n-1,W); 
    return max(incl,excl);
}
int knapsack(vector<int>weight, vector<int> value, int n, int maxWeight) 
{
    return Rec(weight,value,n-1,maxWeight);
}

// Recursion+Memoization
#include <bits/stdc++.h> 
int Mem(vector<int> &weight, vector<int> &value, int n, int W,vector<vector<int>>&dp){
    if(n==0){
        if(weight[0]<=W)
            return value[0];
        else
            return 0;
    }
    if(dp[n][W]!=-1) return dp[n][W];
    int incl = 0;
    if(weight[n]<=W)
    incl = value[n] + Mem(weight,value,n-1,W-weight[n],dp);
    int excl = Mem(weight,value,n-1,W,dp);  
    return dp[n][W] = max(incl,excl);
}
int knapsack(vector<int>weight, vector<int> value, int n, int maxWeight) 
{
    vector<vector<int>>dp(n,vector<int>(maxWeight+1,-1));
    return Mem(weight,value,n-1,maxWeight,dp);
}

// Tabulation
#include <bits/stdc++.h> 
int tab(vector<int> &weight, vector<int> &value, int n, int W){
    vector<vector<int>> dp(n,vector<int>(W+1,0));
    for(int j = weight[0];j<=W;j++) dp[0][j] = value[0];
        for (int i = 1; i < n; i++) {
          for (int j = 0; j <= W; j++){
              int in = 0;
                if(weight[i]<=j)
                in = value[i] + dp[i-1][j-weight[i]];
              int ex = dp[i-1][j];
              dp[i][j] = max(in,ex);
          }
        }
    return dp[n-1][W];
}
int knapsack(vector<int>weight, vector<int> value, int n, int maxWeight) 
{
    return tab(weight,value,n,maxWeight);
}

// Space Optimized 1
#include <bits/stdc++.h> 
int SO(vector<int> &weight, vector<int> &value, int n, int W){
    vector<int> prev(W+1,0);
    vector<int> curr(W+1,0);
    for(int j = weight[0];j<=W;j++) prev[j] = value[0];
        for (int i = 1; i < n; i++) {
          for (int j = 0; j <= W; j++){
              int in = 0;
                if(weight[i]<=j)
                in = value[i] +prev[j-weight[i]];
                int ex = prev[j];
                curr[j] = max(in,ex);
            }
            for(int k =0;k<=W;k++)
            prev[k] = curr[k];
        }
    return prev[W];
}
int knapsack(vector<int>weight, vector<int> value, int n, int maxWeight) 
{
    //SPACE OPTIMIZATION --> using two vectors
    return SO(weight,value,n,maxWeight);
}

// Space Optimized 2
int SO2(vector<int> &weight, vector<int> &value, int n, int W){
    vector<int> curr(W+1,0);
    for(int j = weight[0];j<=W;j++) curr[j] = value[0];
        for (int i = 1; i < n; i++) {
          for (int j = W; j >=0 ; j--){
              int in = 0;
                if(weight[i]<=j)
                in = value[i] +curr[j-weight[i]];
                int ex = curr[j];
                curr[j] = max(in,ex);
            }
        }
    return curr[W];
}
int knapsack(vector<int>weight, vector<int> value, int n, int maxWeight) 
{
    //SPACE OPTIMIZATION --> using single vector
    return SO2(weight,value,n,maxWeight);
}

// Combination Sum IV 1D DP

// Recursion
#include <bits/stdc++.h> 
int solve(vector<int> &num, int tar){
    //base case
    if(tar==0)
    return 1;
    if(tar<0)
    return 0;
    int ans=0;
    for(int i=0;i<num.size();i++){
        ans=ans+solve(num,tar-num[i]);
    }
    return ans;
}
int findWays(vector<int> &num, int tar)
{
    return solve(num,tar);
}

// Recursion+memoization
#include <bits/stdc++.h> 
int solve(vector<int> &num, int tar,vector<int>&dp){
    //base case
    if(tar==0)
        return 1;
    if(tar<0)
        return 0;
    if(dp[tar]!=-1)
         return dp[tar];
    int ans=0;
    for(int i=0;i<num.size();i++){
        ans=ans+solve(num,tar-num[i],dp);
    }
    dp[tar]= ans;
    return dp[tar];
}
int findWays(vector<int> &num, int tar)
{
    vector<int>dp(tar+1,-1);
    return solve(num,tar,dp);
}

// Tabulation
#include <bits/stdc++.h> 
int findWays(vector<int> &num, int tar)
{
    vector<int>dp(tar+1,-1);
    dp[0]=1;
    for(int i=1;i<=tar;i++){
        int ans=0;
        for(int j=0;j<num.size();j++){
            if(i-num[j]>=0)
                ans+=dp[i-num[j]];
    }
    dp[i]=ans;
    }
    return dp[tar];
}

// Perfect Squares 1d DP

// RECURSION 
class Solution {
public:
    int solve(int n)
    {
        if (n == 0) return 0;
        
        int mnCount = INT_MAX;
        for (int num = 1; num <= sqrt(n); num++)
        {
            int sqNum = num * num;
            int currCount = 1 + solve(n - sqNum);
            mnCount = min(mnCount, currCount);
        }
        return mnCount;
    }
    int numSquares(int n) 
    {
        return solve(n);
    }
};

// MEMOIZATION 
class Solution {
public:
    int solve(int n, vector<int>&dp)
    {
        if (n == 0) return 0;
        if (dp[n] != -1) return dp[n];
        
        int mnCount = INT_MAX;
        for (int num = 1; num <= sqrt(n); num++)
        {
            int sqNum = num * num;
            int currCount = 1 + solve(n - sqNum, dp);
            mnCount = min(mnCount, currCount);
        }
        return dp[n] = mnCount;
    }
    int numSquares(int n) 
    {
        vector<int>dp(n + 1, -1);
        return solve(n, dp);
    }
};

// DP 
class Solution {
public:
    int solve(int n)
    {
        vector<int>dp(n + 1, INT_MAX);
        dp[0] = 0; 
        for (int target = 1; target <= n; target++)
        {
            int mnCount = INT_MAX;
            for (int num = 1; num <= sqrt(target); num++)
            {
                int sqNum = num * num;
                int currCount = 1 + dp[target - sqNum];
                mnCount = min(mnCount, currCount);
            }
            dp[target] = mnCount;
        }
        return dp[n];
    } 
    int numSquares(int n) 
    {
        return solve(n);
    }
};

// Minimum cost for tickets 1D DP

// RECURSION
class Solution {
public:
    int getNextDaysIdx(vector<int>&days, int daysIdx, int ticketDuration)
    {
        int target = days[daysIdx] + ticketDuration - 1; //Max I can travel upto this 'day Number'
        for (int i = daysIdx + 1; i < days.size(); i++)
        {
            if (days[i] > target) return i;
        }
        return days.size();
    }
    int solve(vector<int>& days, vector<int>& costs, vector<int>& ticketDurations, int daysIdx)
    {
        if (daysIdx == days.size()) return 0;     
        int minTravelCost = INT_MAX;
        for (int i = 0; i < 3; i++)
        {
            int ticketCost = costs[i], ticketDuration = ticketDurations[i];
            int nextDaysIdx = getNextDaysIdx(days, daysIdx, ticketDuration);
            int travelCost = ticketCost + solve(days, costs, ticketDurations, nextDaysIdx);
            minTravelCost = min(minTravelCost, travelCost);
        }
        return minTravelCost;
    }
    int mincostTickets(vector<int>& days, vector<int>& costs) 
    {
        vector<int>ticketDurations = {1, 7, 30};
        int ans = solve(days, costs, ticketDurations, 0);
        return ans;
    }
};

// TOP - DOWN - MEMOIZATION
class Solution {
public:
    int getNextDaysIdx(vector<int>&days, int daysIdx, int ticketDuration)
    {
        int target = days[daysIdx] + ticketDuration - 1;
        for (int i = daysIdx + 1; i < days.size(); i++)
        {
            if (days[i] > target) return i;
        }
        return days.size();
    }
    int solve(vector<int>& days, vector<int>& costs, vector<int>& ticketDurations, vector<int>&dp, int daysIdx)
    {
        if (daysIdx == days.size()) return 0;     
        if (dp[daysIdx] !=  -1) return dp[daysIdx];
        int minTravelCost = INT_MAX;
        for (int i = 0; i < 3; i++)
        {
            int ticketCost = costs[i], ticketDuration = ticketDurations[i];
            int nextDaysIdx = getNextDaysIdx(days, daysIdx, ticketDuration);
            int travelCost = ticketCost + solve(days, costs, ticketDurations, dp, nextDaysIdx);
            minTravelCost = min(minTravelCost, travelCost);
        }
        return dp[daysIdx] = minTravelCost;
    }
    int mincostTickets(vector<int>& days, vector<int>& costs) 
    {
        vector<int>ticketDurations = {1, 7, 30};
        vector<int>dp(days.size(), -1);
        int ans = solve(days, costs, ticketDurations, dp, 0);
        return ans;
    }
};

// BOTTOM UP - TABULATION
class Solution {
public:
    int getNextDaysIdx(vector<int>&days, int daysIdx, int ticketDuration)
    {
        int target = days[daysIdx] + ticketDuration - 1;
        for (int i = daysIdx + 1; i < days.size(); i++)
        {
            if (days[i] > target) return i;
        }
        return days.size();
    }
    int mincostTickets(vector<int>& days, vector<int>& costs) 
    {
        int n = days.size();
        vector<int>ticketDurations = {1, 7, 30};
        vector<int>dp(n);
        // If I start at last day I can pick the min cost ticket instead of taking ticket for '1' day duration
        dp[n - 1] = *min_element(costs.begin(), costs.end()); 
        for (int currDaysIdx = n - 2; currDaysIdx >= 0; currDaysIdx--)
        {
            int minTravelCost = INT_MAX;
            for (int i = 0; i < 3; i++)
            {
                int ticketCost = costs[i], ticketDuration = ticketDurations[i];
                int nextDaysIdx = getNextDaysIdx(days, currDaysIdx, ticketDuration);     
                int nextTravelCost = (nextDaysIdx >= n)? 0 : dp[nextDaysIdx];
                int travelCost = ticketCost + nextTravelCost;
                minTravelCost = min(minTravelCost, travelCost);
            }
            dp[currDaysIdx] = minTravelCost;
        }
        return dp[0];
    }
};

// Ninja's Trip

// Recursion
#include<bits/stdc++.h>
int Recursion(int n, vector<int> &days, vector<int> &cost, int index){
    // base case
    if (index >= n){
        return 0;
    }
    // 1 days pass
    int One_day = cost[0] + Recursion(n, days, cost, index+1);
    // 7 days pass
    int i;
    for (i=index; i<n && days[i]<days[index]+7; i++);
    int Seven_day = cost[1] + Recursion(n, days, cost, i);
    // 30 days pass
    for (i=index; i<n && days[i]<days[index]+30; i++);
    int Thirty_day = cost[2] + Recursion(n,days, cost, i);
    return min(One_day, min(Seven_day, Thirty_day));
}
int minimumCoins(int n, vector<int> days, vector<int> cost)
{
    return Recursion(n, days, cost, 0);
}

// Recursion+Memoization
int RecurMemo(int n, vector<int> &days, vector<int> &cost, int index, vector<int> &dp){
    // base case
    if (index >= n){
        return 0;
    }
    if (dp[index] != -1) return dp[index];
    // 1 days pass
    int One_day = cost[0] + RecurMemo(n, days, cost, index+1, dp);
    // 7 days pass
    int i;
    for (i=index; i<n && days[i]<days[index]+7; i++);
    int Seven_day = cost[1] + RecurMemo(n, days, cost, i, dp);
    // 30 days pass
    for (i=index; i<n && days[i]<days[index]+30; i++);
    int Thirty_day = cost[2] + RecurMemo(n,days, cost, i, dp);
    dp[index] = min(One_day, min(Seven_day, Thirty_day));
    return dp[index];
}
int minimumCoins(int n, vector<int> days, vector<int> cost)
{
    vector<int> dp(n+1, -1);
    return RecurMemo(n, days, cost, 0, dp);
}

// Tabulation
int Tabulation(int n, vector<int> &days, vector<int> &cost){
    vector<int> dp(n+1, INT_MAX);
    dp[n] = 0;
    for (int k=n-1; k>=0; k--) {
        // 1 days pass
        int One_day = cost[0] + dp[k+1];
        // 7 days pass
        int i;
        for (i=k; i<n && days[i]<days[k]+7; i++);
        int Seven_day = cost[1] + dp[i];
        // 30 days pass
        for (i=k; i<n && days[i]<days[k]+30; i++);
        int Thirty_day = cost[2] + dp[i];
        dp[k] = min(One_day, min(Seven_day, Thirty_day));
    }
    return dp[0];
}
int minimumCoins(int n, vector<int> days, vector<int> cost)
{
    return Tabulation(n, days, cost);
}

// Space Optimized
int Space_Optimize(int n, vector<int> &days, vector<int> &cost){
    int ans = 0;
    queue<pair<int, int>> month;
    queue<pair<int, int>> week;
    for (int day: days){
        // Step 1 - remove the expired days from queue
        while(!month.empty() && month.front().first+30 <= day){
            month.pop();
        }
        while(!week.empty() && week.front().first+7 <= day){
            week.pop();
        }
        // Step 2- Add cost for current days
        month.push(make_pair(day, ans+cost[2]));
        week.push(make_pair(day, ans+cost[1]));
        // Step 3 - Store the ans
        ans = min(ans+cost[0], min(month.front().second, week.front().second));
    }
    return ans;
}
int minimumCoins(int n, vector<int> days, vector<int> cost)
{
    return Space_Optimize(n, days, cost);
}

// Maximum Square Area

int maximumAreaSquare(vector<vector<int>>& MAT, int n, int m)
{
    int maxSquareSide = 0;
    for (int i = 0; i < n; i++)
    {
        if (MAT[i][0] == 1)
        {
            maxSquareSide = 1;
            break;
        }
    }
    for (int j = 0; j < m; j++)
    {
        if (MAT[0][j] == 1)
        {
            maxSquareSide = 1;
            break;
        }
    }
    for (int i = 1; i < n; i++)
    {
        for (int j = 1; j < m; j++)
        {
            if (MAT[i][j] == 1)
            {
                MAT[i][j] = 1 + min(MAT[i - 1][j], min(MAT[i][j - 1], MAT[i - 1][j - 1]));
                maxSquareSide = max(maxSquareSide, MAT[i][j]);
            }
        }
    }
    return maxSquareSide * maxSquareSide;
}

// Maximal Square 2D DP

// Brute Force
// To start with brute-force approach, we can simply consider each possible starting cell (row, col) and side length (sideLen) of square starting at that cell.
// For each cell and sideLen, we will check if the corresponding square inside the matrix is valid or not (i.e, all cells are "1" or not). 
// After checking each possible squares, we will return the one with maximum area.
class Solution {
public:
    int maximalSquare(vector<vector<char>>& M) {
        auto isValidSquare = [&](int i, int j, int side) {
            return all_of(begin(M)+i, begin(M)+i+side, [&](auto& R){
                return all_of(begin(R)+j, begin(R)+j+side, [&](auto cell) { return cell == '1'; });
            });
        };
        int m = size(M), n = size(M[0]), ans = 0;
        for(int row = 0; row < m; row++)
            for(int col = 0; col < n; col++)
                for(int sideLen = 1; sideLen <= min(m-row, n-col); sideLen++) 
                    if(isValidSquare(row, col, sideLen))
                        ans = ans = max(ans, sideLen*sideLen);
        return ans;
    }
};

// We can slightly optimize the code by running from sideLen = min(m, n) down to 1 instead of the other way around. 
// This ensures that we can return the area of sqaure as soon as we find the 1st valid square since that square would be the 1st valid square of maximum side length.
class Solution {
public:
    int maximalSquare(vector<vector<char>>& M) {
        auto isValidSquare = [&](int i, int j, int side) {
            return all_of(begin(M)+i, begin(M)+i+side, [&](auto& R){
                return all_of(begin(R)+j, begin(R)+j+side, [&](auto cell) { return cell == '1'; });
            });
        };
        int m = size(M), n = size(M[0]);
        for(int sideLen = min(m, n); sideLen; sideLen--)
            for(int row = 0; row <= m-sideLen; row++)
                for(int col = 0; col <= n-sideLen; col++)
                    if(isValidSquare(row, col, sideLen))
                        return sideLen*sideLen;
        return 0;
    }
};
// Time Complexity : O(M*N*min(M,N)3)
// Space Complexity : O(1), only constant extra space is being used

// Optimized Brute Approach
class Solution {
public:
    int getMaxSquareLen(vector<vector<char>>& M, int row, int col) {
        int allOnesRowLen = min(size(M)-row, size(M[0])-col), sqLen = 0;
        for(int i = 0, j; i < allOnesRowLen; i++) {
            for(j = 0; j < allOnesRowLen && M[i+row][j+col] != '0'; j++);
            allOnesRowLen = j;
            sqLen = min(allOnesRowLen, i+1);
        }
        return sqLen;
    }
    int maximalSquare(vector<vector<char>>& M) {
        int m = size(M), n = size(M[0]), ans = 0;
        for(int row = 0; row < m; row++)
            for(int col = 0; col < n; col++) 
                ans = max(ans, getMaxSquareLen(M, row, col));
        return ans * ans;
    }
};
// Time Complexity : O(MN*min(M,N)2)
// Space Complexity : O(1)

// Dynamic Programming
class Solution {
public:
    int getMaxSquareLen(vector<vector<char>>& M, vector<vector<int>>& ones, int row, int col) {
        int allOnesRowLen = min(size(M)-row, size(M[0])-col), sqLen = 0;
        for(int i = 0, j; i < allOnesRowLen; i++) 
            allOnesRowLen = min(allOnesRowLen, ones[i+row][col]),
            sqLen = min(allOnesRowLen, i+1);
        return sqLen;
    }
    int maximalSquare(vector<vector<char>>& M) {
        int m = size(M), n = size(M[0]), ans = 0;
        vector<vector<int>> ones(m, vector<int>(n+1));
        for(int i = m-1; ~i; i--)
            for(int j = n-1; ~j; j--)
                ones[i][j] = (M[i][j] == '1' ? 1 + ones[i][j+1] : 0);
        
        for(int row = 0; row < m; row++)
            for(int col = 0; col < n; col++) 
                ans = max(ans, getMaxSquareLen(M, ones, row, col));
        return ans * ans;
    }
};
//Time Complexity : O(MN*min(M,N))
// Space Complexity : O(1)

// Dynamic Programming
class Solution {
public:
    int maximalSquare(vector<vector<char>>& M) {
        int m = size(M), n = size(M[0]), ans = 0;
        vector<vector<int>> dp(m+1, vector<int>(n+1));
        for(int i = m-1; ~i; i--)
            for(int j = n-1; ~j; j--) 
                dp[i][j] = (M[i][j] == '1' ? 1 + min({dp[i+1][j], dp[i][j+1], dp[i+1][j+1]}) : 0),
                ans = max(ans, dp[i][j]);

        return ans * ans;
    }
};
// Time Complexity : O(MN)
// Space Complexity : O(MN)

// Optimized
class Solution {
public:
    int maximalSquare(vector<vector<char>>& M) {
        int m = size(M), n = size(M[0]), ans = 0;
        vector<vector<int>> dp(2, vector<int>(n+1));
        for(int i = m-1; ~i; i--)
            for(int j = n-1; ~j; j--) 
                dp[i&1][j] = (M[i][j] == '1' ? 1 + min({dp[(i+1)&1][j], dp[i&1][j+1], dp[(i+1)&1][j+1]}) : 0),
                ans = max(ans, dp[i&1][j]);

        return ans * ans;
    }
};
// Time Complexity : O(MN)
// Space Complexity : O(N), this can be further optimized to O(min(M, N)) as well.

// Minimum square Triangulation 2D DP

// Recursion
#include <bits/stdc++.h>
using namespace std;
int minimumTriangleScoreHelper(vector<int> &vertex, int i, int j)
{
    // if triangle can't be formed
    if (j - i < 2)
    {
        return 0;
    }
    // initialize result as infinite
    int res = INT_MAX;
    // loop over all vertices between i and j
    for (int k = i + 1; k < j; k++)
    {
        res = min(res, minimumTriangleScoreHelper(vertex, i, k) +
                          minimumTriangleScoreHelper(vertex, k, j) +
                          vertex[i] * vertex[k] * vertex[j]);
    }
    return res;
}
int minimumTriangleScore(vector<int> &vertex, int n)
{
    int ans = minimumTriangleScoreHelper(vertex, 0, n - 1);
    return ans;
}
int main()
{
    int n = 5; // number of vertices of polygon
    vector<int> vertex = {2, 4, 2, 5, 1}; // values of the vertices
    cout << "Minimum score triangulation of the polygon is: " << minimumTriangleScore(vertex, n) << endl;
}

// Recursion+Memoization
#include <bits/stdc++.h>
using namespace std;
int minimumTriangleScoreHelper(vector<vector<int>> &memo, vector<int> &vertex, int i, int j)
{
    if (memo[i][j] == 0)
    {
        /* iterate over all the vertices between i and j */
        for (int k = i + 1; k < j; k++)
        {
            int curr_score = vertex[i] * vertex[k] * vertex[j];
            // Left sub polygon
            int left_polygon = minimumTriangleScoreHelper(memo, vertex, i, k);
            // Right subpolygon
            int right_polygon = minimumTriangleScoreHelper(memo, vertex, k, j);
            memo[i][j] = min(memo[i][j] == 0 ? INT_MAX : memo[i][j], left_polygon + curr_score + right_polygon);
        }
    }
    return memo[i][j];
}
int minimumTriangleScore(vector<int> &vertex, int n)
{
    // If array size is zero, then return 0.
    if (vertex.empty())
    {
        return 0;
    }
    // Creating a 2D DP table to store the results
    vector<vector<int>> memo(n, vector<int>(n, 0));
    return minimumTriangleScoreHelper(memo, vertex, 0, n - 1);
}
int main()
{
    int n = 5;                            // number of vertices of polygon
    vector<int> vertex = {2, 4, 2, 5, 1}; // values of the vertices
    cout << "Minimum score triangulation of the polygon is: " << minimumTriangleScore(vertex, n) << endl;
}

// Tabulation
#include <bits/stdc++.h>
using namespace std;
int minimumTriangleScore(vector<int> &vertex, int n)
{
    vector<vector<int>> dp(n, vector<int>(n));
    /*
        each dp[i][j] denotes the minimum score to triangulate the polygon
        from vertex i to vertex j
    */
    for (int j = 2; j < n; ++j)
    {
        for (int i = j - 2; i >= 0; --i)
        {
            dp[i][j] = INT_MAX;
            for (int k = i + 1; k < j; ++k)
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + vertex[i] * vertex[j] * vertex[k]);
        }
    }
    return dp[0][n - 1];
}
int main()
{
    int n = 5;                            // number of vertices of polygon
    vector<int> vertex = {2, 4, 2, 5, 1}; // values of the vertices
    cout << "Minimum score triangulation of the polygon is: " << minimumTriangleScore(vertex, n) << endl;
}

// Minimum sideways jump 2D DP

// Recursion+Memoization
// Time complexity:O(2^n);
// Space complexity:O(4*n);
class Solution {
public:
    int solve(int n,vector<int>&obstacles,int lane,int pos,vector<vector<int>>&dp)
    {
        if(pos == n-1)
        return 0;
        if(dp[lane][pos]!= -1)
            return dp[lane][pos];
        if(obstacles[pos+1]!= lane)
            return solve(n,obstacles,lane,pos+1,dp
        int ans =1e9;
            for(int k = 1;k<=3;k++)
            {
                if(lane != k && obstacles[pos]!=k)
                {
                    ans = min(ans,1+solve(n,obstacles,k,pos,dp));
                }   
            }
            dp[lane][pos] = ans;
            return ans;
    }
    int minSideJumps(vector<int>& obstacles) {
        int n = obstacles.size();
    vector<vector<int>>dp(4,vector<int>(n,-1));
        return solve(n,obstacles,2,0,dp);
    }
};

// Tabulation
// Time Complexity -> O(n)
// Space compllexity -> O(1)
class Solution{
  public:
  int minSideJumps(vector<int>& obstacles) {
        int n = obstacles.size();
        // vector<vector<int>>dp(4,vector<int>(n,1e9));
        vector<int>curr(4,1e9);
        vector<int>next(4,1e9);
        next[0] = 0;
        next[1] = 0;
        next[2] = 0;
        next[3] = 0;
        for(int pos = n-2;pos>=0;pos--)
        {
            for(int lane=1;lane<=3;lane++)
            {
                if(obstacles[pos+1]!= lane)
                    curr[lane] =  next[lane];
                else{
                    int ans =1e9;
                    for(int k = 1;k<=3;k++)
                    {
                        if(lane != k && obstacles[pos]!=k)
                        {
                            ans = min(ans,1+next[k]);
                        }   
                    }
                    curr[lane] = ans;
                }
            }
            next = curr;
        }
        return min(curr[2],min(curr[1]+1,curr[3]+1));
    }
};

// Reducing Dishes 2D DP

// Approach
// The first approach is a brute-force method where we try all possible starting points and calculate the satisfaction of each subarray. This approach is 
// simple and easy to understand, but it is very slow and inefficient for large input arrays.
// The second approach is a recursive algorithm that computes the maximum satisfaction by including or excluding each element of the input array. 
// This approach is more efficient than the brute-force method.
// The third approach uses memoization to optimize the recursive algorithm by caching the results of the computed subproblems. This approach is faster than the 
// second approach because it avoids recomputing the same subproblems multiple times. It is also easier to implement because we only need to add a memoization 
// table to store the results of the computed subproblems.
// Complexity
// Time complexity: O(N^2), for all approaches.
// Space complexity:
// O(1) for iterative approach
// O(N) for recursion
// O(N^2) for Memoization

// Brute Force (iterative)
class Solution {
public:
    int maxSatisfaction(vector<int>& satisfaction) {
        sort(satisfaction.begin(),satisfaction.end());
        int max_sat=0;
        int st=0; // to test all starting points
        while(st<satisfaction.size()){
            int temp=0;
            for(int i=st;i<satisfaction.size();++i){
                temp+=satisfaction[i]*(i-st+1);
            }
            max_sat=max(max_sat,temp);
            ++st;
        }
        return max_sat;
    }
};

// Recursive
class Solution {
public:
    int helper(vector<int>& sat, int curr){
        if(curr==sat.size()) return 0; 
        int coeff=0; // store the results when we include current index
        for(int i=curr;i<sat.size();++i){
            coeff+=sat[i]*(i-curr+1);
        }
        return max(coeff,helper(sat,curr+1)); // recursion to check for next indexes
    }
    int maxSatisfaction(vector<int>& satisfaction) {
        sort(satisfaction.begin(),satisfaction.end());
        return helper(satisfaction,0);
    }
};

// Memoization
class Solution {
public:
    int helper(vector<int>& sat, vector<vector<int>>& memo, int curr,int t){
        if(curr==sat.size()) return 0;
        if(memo[curr][t]!=-1) return memo[curr][t]; // if the value is already computed
        
        int excluded = helper(sat,memo,curr+1,t); // when we don't include the current index
        int included = sat[curr]*t + helper(sat,memo,curr+1,t+1); // when we include the current index
        return memo[curr][t]=max(included,excluded);
    }
    int maxSatisfaction(vector<int>& satisfaction) {
        sort(satisfaction.begin(),satisfaction.end());
        int n=satisfaction.size();
        vector<vector<int>>memo(n+1,vector<int>(n+1,-1));
        return helper(satisfaction,memo,0,1);
    }
};

// Cooking Ninjas

#include <bits/stdc++.h> 
using namespace std;
// to find maximum ranked chef 
int maxiOf(vector<int> &rank){
    int maximum = -1;
    for(int i = 0; i < rank.size(); i++){
        maximum = max(maximum, rank[i]);
    }
    return maximum;
}
// to get maximum time taken by a highest rank chef
int maxTime(vector<int> &rank, int m){    
    int maximum = maxiOf(rank);
    int maximumTimeValue = 0;
    for(int i = 1; i <= m; i++){
        maximumTimeValue += (maximum * i);
    }
    return maximumTimeValue;
}
// to check if it is possible to cook m dishes among n chef in mid time interval
bool isPossible(vector<int> &rank, int m, int mid){
    // maintain chefcount
    int chefCount = 1;
    // maintain time taken by current chef
    int currSum = 0;
    // counter to increase time 
    int counter = 1;
    for(int i = 1; i <= m; i++){
        // if chef can cook curr i dish as well within mid interval then add 
        // to currSum and increase counter
        if(currSum + (counter * rank[chefCount-1]) <= mid){
            currSum += (counter * rank[chefCount-1]);
            counter++;
        }
        // if cook was not able to cook ith dish
        else {
            // check for next rank cook
            chefCount++;
            // if all cooks are checked
            // or if current cook take more time to cook 1st dish > mid interval
            // return false
            if(chefCount > rank.size() || ( i <= m && rank[chefCount-1] > mid)){
                return false;
            }
            // update currSum with time to prepaper 1st dish by cook
            currSum = rank[chefCount-1];
            // to go to second one set counter as 2
            counter = 2;
        }
    }
    // if we exceed the check of the available cook then returnn false
    if(chefCount > rank.size()){
        return false;
    }
    // else we manage to cook all dishes and thus return true
    return true;
}
// to calculate the minimum time require to cook m dishes
int minCookTime(vector<int> &rank, int m)
{
    sort(rank.begin(), rank.end());   
    // minimum time to cook would be 0
    // maximum time to cook would be Time consumed by Highest rank chef
    int start = 0, end = maxTime(rank, m);
    int mid = start + (end - start) / 2;
    int ans = -1;
    while(start <= end){
        // if cooking in mid times interval for each chef
        // make m dishes within n cook then
        if(isPossible(rank, m, mid)){
            // save the mid time interval
            ans = mid;
            // move to find lesser time interval to do the same
            end = mid - 1;
        }
        // if mid time interval is not enough
        else {
            // then move to search for larger interval
            start = mid + 1;
        }
        mid = start + (end - start) / 2;
    }
    return ans;
}

// Lis and Russian Dolls DP + Binary Search

// Intuition - LONGEST INCREASING SUBSEQUENCE SAME
// Approach - 
// Russian dolls hai unko envelops me dalna hai to sort kardia width wise but agar width same hui kisi ki toh kya kre?
// to hmne HIEGHT ko sort krdia but descending order me an descending order me kyu kara ?
// beacuse hum LIS lga sake uspr agar hum normal karenge to mja n aaega..(Complex hoega)
// Complexity
// Time complexity:RECURSION->exponential (TLE)
// MEMOIZATION-> O(N*N) (TLE)
// TOP-DOWN-> O(N*N) (TLE)
// Binary search ->O(N*LOG(N)) (optimised)
// Space complexity:
// MEMOIZATION-> O(N*N)
// TOP-DOWN-> O(N*N)
// Binary search ->O(N)

// Recursion
class Solution {
public:
    int solve(int n, vector<vector<int>>& envelopes,int curr,int prev)
    {
        if(curr == n)
        {
            return 0;
        }
        int include=0;
        if(prev == -1 or (envelopes[prev][0] < envelopes[curr][0] and 
        envelopes[prev][1] < envelopes[curr][1]))
        {
            // check with and heigth both
            include = 1 + solve(n,envelopes,curr+1,curr);
        }
        int exclude = 0 + solve(n,envelopes, curr+1, prev);
        return max(include,exclude);
    }
    int maxEnvelopes(vector<vector<int>>& envelopes) {
        sort(envelopes.begin(),envelopes.end());
        for(int i=0;i<envelopes.size();i++)
        {
          for(int j=0;j<envelopes[0].size();j++)
          {
            cout<<"envelopes[i][j]"<<envelopes[i][j]<<" ";
          }
            cout<<endl;
        }
             return solve(envelopes.size(), envelopes, 0, -1);
    }
};

// Memoization
class Solution{
public:
  int solve_mem(int n, vector<vector<int>>& envelopes,int curr,int prev,vector<vector<int>> &dp)
    {
        if(curr == n)
        {
            return 0;
        }
        if(dp[curr][prev+1] != -1)
            return dp[curr][prev+1];
        int include=0;
        if(prev == -1 or (envelopes[prev][0] < envelopes[curr][0] and 
        envelopes[prev][1] < envelopes[curr][1]))
        {
            include = 1 + solve_mem(n,envelopes,curr+1,curr,dp);
        }
        int exclude = 0 + solve_mem(n,envelopes, curr+1, prev,dp);
        dp[curr][prev+1] = max(include,exclude);
        return dp[curr][prev+1];
    }
    int maxEnvelopes(vector<vector<int>>& envelopes) {
            sort(envelopes.begin(),envelopes.end());
            for(int i=0;i<envelopes.size();i++)
            {
                for(int j=0;j<envelopes[0].size();j++)
                {
                    cout<<"envelopes[i][j]"<<envelopes[i][j]<<" ";
                }
                cout<<endl;
             }
             vector<vector<int>> dp(envelopes.size()+1,vector<int>(envelopes.size()+1,-1));
             return solve_mem(envelopes.size(), envelopes, 0, -1,dp);
        }  
};

// Tabulation
class Solution {
public:
    int maxEnvelopes(vector<vector<int>>& envelopes) {
          sort(envelopes.begin(),envelopes.end());
          for(int i=0;i<envelopes.size();i++)
          {
              for(int j=0;j<envelopes[0].size();j++)
              {
                  cout<<"envelopes[i][j]"<<envelopes[i][j]<<" ";
              }
              cout<<endl;
          }
        vector<vector<int>> dp(envelopes.size()+1,vector<int>(envelopes.size()+1,0));
        int n=envelopes.size();
        for(int curr = n-1; curr>=0; curr--)
        {
            for(int prev= curr-1; prev>=-1; prev--)
            {
                    int include=0;
                    if(prev == -1 or (envelopes[prev][0] < envelopes[curr][0] and 
                    envelopes[prev][1] < envelopes[curr][1]))
                    {
                        include = 1 + dp[curr+1][curr+1];
                    }
                    int exclude = 0 + dp[curr+1][prev+1];
                    dp[curr][prev+1] = max(include,exclude);
            }
        }
        return dp[0][0];
    }
};

// Binary Search
class Solution {
public:
    static bool cmp(const vector<int>& v1, const vector<int>& v2)
    {
      if(v1[0] == v2[0]) return v1[1] > v2[1];
            return v1[0]<v2[0];
    }
    int maxEnvelopes(vector<vector<int>>& envelopes) {
        int n = envelopes.size();
        sort(envelopes.begin(),envelopes.end(),cmp);
        vector<int>arr;
        for(int i =0;i<n;i++)
        {
            if(arr.empty() || arr.back()<envelopes[i][1])
                arr.push_back(envelopes[i][1]);
            else
            {
                int index = lower_bound(arr.begin(),arr.end(),envelopes[i][1]) - arr.begin();
                arr[index] = envelopes[i][1];
            }
        }
        return arr.size();
    }
};

// Max Height By stacking Cuboids lis variant

// T->O(nlogn x 2^n) + S->O(n) [Recursion Stack Space]
class Solution {
public:
	int maxh(int i,int prev,vector<vector<int>>& cubo,int n){
		if(i==n) return 0;
		int pick=INT_MIN;
		if(prev==-1 || (cubo[prev][1]<=cubo[i][1] && cubo[prev][2]<=cubo[i][2])){
			pick=cubo[i][2]+maxh(i+1,i,cubo,n);
		}
		int notpick=maxh(i+1,prev,cubo,n);
		return max(pick,notpick);
	}
	int maxHeight(vector<vector<int>>& cubo) {
		int n=cubo.size();
		for(auto &i:cubo) sort(i.begin(),i.end());
		sort(cubo.begin(),cubo.end());
		return maxh(0,-1,cubo,n);
	}
};

// Method - 2 [Memoization]
// T->O(n^2) + S->O(n^2) + O(n) [Recursion Stack Space]
class Solution {
public:
	int maxh(int i,int prev,vector<vector<int>>& cubo,int n,vector<vector<int>>& dp){
		if(i==n) return 0;
		if(dp[i][prev+1]!=-1) return dp[i][prev+1];
		int pick=INT_MIN;
		if(prev==-1 || (cubo[prev][1]<=cubo[i][1] && cubo[prev][2]<=cubo[i][2])){
			pick=cubo[i][2]+maxh(i+1,i,cubo,n,dp);
		}
		int notpick=maxh(i+1,prev,cubo,n,dp);
		return dp[i][prev+1]=max(pick,notpick);
	}
	int maxHeight(vector<vector<int>>& cubo) {
		int n=cubo.size();
		for(auto &i:cubo) sort(i.begin(),i.end());
		sort(cubo.begin(),cubo.end());
		vector<vector<int>> dp(n,vector<int>(n+1,-1));
		return maxh(0,-1,cubo,n,dp);
	}
};

// Method - 3 [Tabulation]
// T->O(n^2) + S->O(n^2)
class Solution {
public:
	int maxHeight(vector<vector<int>>& cubo) {
		int n=cubo.size();
		for(auto &i:cubo) sort(i.begin(),i.end());
		sort(cubo.begin(),cubo.end());
		vector<vector<int>> dp(n+1,vector<int>(n+1,0));
		for(int i=n-1;i>=0;i--){
			for(int prev=n-1;prev>=-1;prev--){
				int pick=INT_MIN;
				if(prev==-1 || (cubo[prev][1]<=cubo[i][1] && cubo[prev][2]<=cubo[i][2])){
					pick=cubo[i][2]+dp[i+1][i+1];
				}
				int notpick=dp[i+1][prev+1];
				dp[i][prev+1]=max(pick,notpick);
			}
		}
		return dp[0][0];
	}
};

//Method - 4 [SpaceOptimization]
// T->O(n^2) + S->O(n)
class Solution {
public:
	int maxHeight(vector<vector<int>>& cubo) {
		int n=cubo.size();
		for(auto &i:cubo) sort(i.begin(),i.end());
		sort(cubo.begin(),cubo.end());
		vector<int> last(n+1,0),curr(n+1,0);
		for(int i=n-1;i>=0;i--){
			for(int prev=n-1;prev>=-1;prev--){
				int pick=INT_MIN;
				if(prev==-1 || (cubo[prev][1]<=cubo[i][1] && cubo[prev][2]<=cubo[i][2])){
					pick=cubo[i][2]+last[i+1];
				}
				int notpick=last[prev+1];
				curr[prev+1]=max(pick,notpick);
			}
			last=curr;
		}
		return last[0];
	}
};

// Pizza with 3N slices

// Recursion
#include <bits/stdc++.h> 
int solve(int index,int endindex,int noofslices, vector<int> &arr){
    if(index>endindex || noofslices==0)
        return 0;
    int include=arr[index]+solve(index+2,endindex,noofslices-1,arr);
    int exclude=0+solve(index+1,endindex,noofslices,arr);
    return max(include,exclude);

}
int pizzaSharing(int n, vector<int> &arr)
{
    int k=n/3;
    int sol1=solve(0,n-2,k,arr);
    int sol2=solve(1,n-1,k,arr);
    return max(sol1,sol2);
}

// Recursion+Memoization
#include <bits/stdc++.h> 
int solve(int index,int endindex,int noofslices, vector<int> &arr){
    if(index>endindex || noofslices==0)
        return 0;
    int include=arr[index]+solve(index+2,endindex,noofslices-1,arr);
    int exclude=0+solve(index+1,endindex,noofslices,arr);
    return max(include,exclude);

}
int pizzaSharing(int n, vector<int> &arr)
{
    int k=n/3;
    int sol1=solve(0,n-2,k,arr);
    int sol2=solve(1,n-1,k,arr);
    return max(sol1,sol2);
}

// Tabulation
#include <bits/stdc++.h> 
int solve(vector<int> &arr,int k,int n){
    vector<vector<int>>dp(n+2,vector<int>(n+2,0));
    for(int index=n-1;index>=0;index--){
        for(int noofslices=0;noofslices<k;noofslices++){
            int include=arr[index]+dp[index+2][noofslices-1];
            int exclude=0+dp[index+1][noofslices];
            dp[index][noofslices]=max(include,exclude);
        }
    }
    return dp[0][k-1];
}
int pizzaSharing(int n, vector<int> &arr)
{
    vector<int>first,last;
    for(int i=0;i<n;i++){
        if(i!=0){
            last.push_back(arr[i]);
        }
        if(i!=n-1){
            first.push_back(arr[i]);
        }
    }
    int k=n/3;
    int sol1=solve(first,k,n-1);
    int sol2=solve(last,k,n-1);
    return max(sol1,sol2);
}

// Space Optimized
#include <bits/stdc++.h> 
int solve(int n, vector<int> &arr){
    int k=n/3;
    vector<int>curr(k+1,0);
    vector<int>next(k+1,0);
    vector<int>next2(k+1,0);
    for(int index=n-2;index>=0;index--){
        for(int noofslices=0;noofslices<k;noofslices++){
            int include=arr[index]+next2[noofslices-1];
            int exclude=0+next[noofslices];
            curr[noofslices]= max(include,exclude);
        }
        next2=next;
        next=curr;
    }
    return next[k-1];
}
int pizzaSharing(int n, vector<int> &arr)
{
    vector<int>first,last;
    for(int i=0;i<n;i++){
        if(i!=0){
            last.push_back(arr[i]);
        }
        if(i!=n-1){
            first.push_back(arr[i]);
        }
    }
    int sol1=solve(n,first);
    int sol2=solve(n,last);
    return max(sol1,sol2);
}

// Number of dice rolls with target sum ( DP  Distinct Ways Pattern )

// Recursion
#define MOD 1000000007
#include<vector>
int solve(int dice,int target,int faces){
    //base cases
    if(target<0)
        return 0;
    if(dice!=0 && target==0)
        return 0;
    if(target!=0 && dice==0)
        return 0;
    if(dice==0 && target==0)
        return 1;
    
    int ans=0;
    for(int i=1;i<=faces;i++){
        if(target-i>=0)
            ans=(ans+solve(dice-1,target-i,faces))%MOD;
    }
    return ans%MOD;
}
int diceThrows(int d, int f, int s) {
   return solve(d,s,f)%MOD;
}

// Recursion+Memoization
#define MOD 1000000007
#include<vector>
int solve(int dice,int target,int faces,vector<vector<int>>&dp){
    //base cases
    if(target<0)
        return 0;
    if(dice!=0 && target==0)
        return 0;
    if(target!=0 && dice==0)
        return 0;
    if(dice==0 && target==0)
        return 1;
    if(dp[dice][target]!=-1)
        return dp[dice][target]%MOD;
    int ans=0;
    for(int i=1;i<=faces;i++){
        if(target-i>=0)
            ans=(ans+solve(dice-1,target-i,faces,dp))%MOD;
    }
     return dp[dice][target]=ans;
}
int diceThrows(int d, int f, int s) {
   vector<vector<int>>dp(d+1,vector<int>(s+1,-1));
   return solve(d,s,f,dp)%MOD;
}

// Tabulation
#define MOD 1000000007
#include<vector>
int solve(int dice,int target,int faces){
    vector<vector<int>>dp(dice+1,vector<int>(target+1,0));
    dp[0][0]=1;
    for(int d=1;d<=dice;d++){
        for(int t=1;t<=target;t++){
            int ans=0;
            for(int i=1;i<=faces;i++){
                if(t-i>=0)
                    ans=(ans+dp[d-1][t-i])%MOD;
            }
            dp[d][t]=ans;
        }
    }
     return dp[dice][target];
}
int diceThrows(int d, int f, int s) {
  return solve(d,s,f)%MOD;
}

// Space Optimized
#define MOD 1000000007
#include<vector>
int solve(int dice,int target,int faces){
    vector<int>curr(target+1,0);
    vector<int>prev(target+1,0);
    prev[0]=1;
    for(int d=1;d<=dice;d++){
        for(int t=1;t<=target;t++){
            int ans=0;
            for(int i=1;i<=faces;i++){
                if(t-i>=0)
                    ans=(ans+prev[t-i])%MOD;
            }
            curr[t]=ans;
        }
        prev=curr;
    }
     return prev[target];
}
int diceThrows(int d, int f, int s) {
  return solve(d,s,f)%MOD;
}

// Partition equal Subset Sum  ( DP  Distinct Ways Pattern )

// Recursion
bool solve(int index,int n,int half,vector<int>&arr){
	//base case
	if(index>=n)
		return false;
	if(half<0)
		return false;
	if(half==0)
		return true;
	bool include=solve(index+1,n,half-arr[index],arr);
	bool exclude=solve(index+1,n,half,arr);
	return include || exclude;
	
}
bool canPartition(vector<int> &arr, int n)
{
	int total=0;
	for(int i=0;i<n;i++){
		total+=arr[i];
	}
	//if total is odd we cant divide it into eqaul parts
	if(total&1==1)
		return false;
	int half=total/2;
	return solve(0,n,half,arr);
}

// Recursion+Memoization
bool solve(int index,int n,int half,vector<int>&arr,vector<vector<int>>&dp){
	//base case
	if(index>=n)
		return false;
	if(half<0)
		return false;
	if(half==0)
		return true;
	if(dp[index][half]!=-1)
		return dp[index][half];
	bool include=solve(index+1,n,half-arr[index],arr,dp);
	bool exclude=solve(index+1,n,half,arr,dp);
	return dp[index][half]=include || exclude;
	
}
bool canPartition(vector<int> &arr, int n)
{
	int total=0;
	for(int i=0;i<n;i++){
		total+=arr[i];
	}
	//if total is odd we cant divide it into eqaul parts
	if(total&1==1)
		return false;
	int half=total/2;
	vector<vector<int>>dp(n+1,vector<int>(half+1,-1));
	return solve(0,n,half,arr,dp);
}

// Tabulation
bool solve(int n,int half,vector<int>&arr){

	vector<vector<int>>dp(n+1,vector<int>(half+1,0));
	//from base case we found that when half ==0 return true
	//but we dont know at which index so all index's 0 is made true
	for(int i=0;i<=n;i++){
		dp[i][0]=1;
	}

	for(int index=n-1;index>=0;index--){
		for(int h=0;h<=half;h++){
			int include=0;
			if(h-arr[index]>=0)
				include=dp[index+1][h-arr[index]];
			int exclude=dp[index+1][h];
			dp[index][h]=include||exclude;
		}
	}
	return dp[0][half];	
}
bool canPartition(vector<int> &arr, int n)
{
	int total=0;
	for(int i=0;i<n;i++){
		total+=arr[i];
	}
	//if total is odd we cant divide it into eqaul parts
	if(total&1==1)
		return false;
	int half=total/2;
	return solve(n,half,arr);
}

// Space Optimized
bool solve(int n,int half,vector<int>&arr){

	vector<int>curr(half+1,0);
	vector<int>next(half+1,0);
	//from base case we found that when half ==0 return true
	//but we dont know at which index so all index's 0 is made true
	next[0]=curr[0]=1;	

	for(int index=n-1;index>=0;index--){
		for(int h=0;h<=half;h++){
			int include=0;
			if(h-arr[index]>=0)
				include=next[h-arr[index]];
			int exclude=next[h];
			curr[h]=include||exclude;
		}
		next=curr;
	}
	return next[half];	
}
bool canPartition(vector<int> &arr, int n)
{
	int total=0;
	for(int i=0;i<n;i++){
		total+=arr[i];
	}
	//if total is odd we cant divide it into eqaul parts
	if(total&1==1)
		return false;
	int half=total/2;
	return solve(n,half,arr);
}

// Recursion

class Solution {
public:
    int solve(int index, vector<int> &nums1, vector<int> &nums2, bool flag){
        int n = nums1.size();
        // base case
        if(index == n) return 0;
        int ans = INT_MAX;
        int prev1 = nums1[index-1];
        int prev2 = nums2[index-1];
        if(flag) // we flag is true then we swap prev1 and prev2
            swap(prev1,prev2);
        //noswap
        if(prev1< nums1[index] && prev2< nums2[index]){
            ans = solve(index+1,nums1,nums2,0);
        }
        //swap
        if(prev1< nums2[index] && prev2< nums1[index]){
            ans = min(ans, 1+ solve(index+1,nums1,nums2,1));
        }
        return ans;
    }
    int minSwap(vector<int>& nums1, vector<int>& nums2) {
            int n = nums1.size();
            nums1.insert(nums1.begin(),-1);
            nums2.insert(nums2.begin(),-1);
            bool flag = 0;
            return solve(1,nums1,nums2,flag);
    }
};

// Recursion+Memoization
class Solution {
public:
    int solveMem(int index, vector<int> &nums1, vector<int> &nums2, bool flag, vector<vector<int>> &dp){
        int n = nums1.size();
        // base case
        if(index == n) return 0;
        if(dp[index][flag]!= -1) return dp[index][flag];
        int ans = INT_MAX;
        int prev1 = nums1[index-1];
        int prev2 = nums2[index-1];
        if(flag) // we flag is true then we swap prev1 and prev2
            swap(prev1,prev2);
        //noswap
        if(prev1< nums1[index] && prev2< nums2[index]){
            ans = solveMem(index+1,nums1,nums2,0,dp);
        }
        //swap
        if(prev1< nums2[index] && prev2< nums1[index]){
            ans = min(ans, 1+ solveMem(index+1,nums1,nums2,1,dp));
        }
        return dp[index][flag] = ans; 
    }
    int minSwap(vector<int>& nums1, vector<int>& nums2) {
            int n = nums1.size();
            nums1.insert(nums1.begin(),-1);
            nums2.insert(nums2.begin(),-1);
            bool flag = 0;
            vector<vector<int>>  dp(n+1, vector<int>(2,-1));
            return solveMem(1,nums1,nums2,flag,dp);
    }
};

// Tabulation
class Solution {
public:
    int solveTab(vector<int> &nums1,vector<int> &nums2){
        int n = nums1.size();
        vector<vector<int>> dp(n+1,vector<int>(2,0));
        for(int index=n-1;index>=1;index--){
            for(int flag =1;flag>=0;flag--){
                int ans = INT_MAX;
                int prev1 = nums1[index-1];
                int prev2 = nums2[index-1];
                if(flag) // we flag is true then we swap prev1 and prev2
                    swap(prev1,prev2);
                //noswap
                if(prev1< nums1[index] && prev2< nums2[index]){
                    ans = dp[index+1][0];
                }
                //swap
                if(prev1< nums2[index] && prev2< nums1[index]){
                    ans = min(ans, 1+ dp[index+1][1]);
                }
                dp[index][flag]= ans;
            }
        }
        return dp[1][0];
    }
    int minSwap(vector<int>& nums1, vector<int>& nums2) {
            int n = nums1.size();
            nums1.insert(nums1.begin(),-1);
            nums2.insert(nums2.begin(),-1);
            return solveTab(nums1,nums2);
    }
};

// Space Optimized
class Solution {
public:
    int solveSO(vector<int> &nums1, vector<int> &nums2){
        int n = nums1.size();
        vector<int> curr(2,0);
        vector<int> next(2,0);
        for(int index=n-1;index>=1;index--){
            for(int flag =1;flag>=0;flag--){
                int ans = INT_MAX;
                int prev1 = nums1[index-1];
                int prev2 = nums2[index-1];
                if(flag) // we flag is true then we swap prev1 and prev2
                    swap(prev1,prev2);
                //noswap
                if(prev1< nums1[index] && prev2< nums2[index]){
                    ans = next[0];
                }
                //swap
                if(prev1< nums2[index] && prev2< nums1[index]){
                    ans = min(ans, 1+ next[1]);
                }
                curr[flag]= ans;
            }
            next = curr;
        }
        return next[0];
    }
    int minSwap(vector<int>& nums1, vector<int>& nums2) {
            int n = nums1.size();
            nums1.insert(nums1.begin(),-1);
            nums2.insert(nums2.begin(),-1);
            return solveSO(nums1,nums2);
    }
};

// Longest Arithmetic Subsequence ( DP and Hashing )

class Solution{
public:
    int longestArithSeqLength(vector<int>& A) {
        int n = A.size();
        int result = 0;
        vector<unordered_map<int, int>> dp(n);
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                int diff = A[i]-A[j];
                dp[i][diff] = dp[j].count(diff) > 0 ? dp[j][diff] + 1 : 2;
                result = max(result, dp[i][diff]);
            }
        }
        return result;
    }
};

// Longest AP

#include <bits/stdc++.h>
int longestAP(vector<int> &arr, int n) {
  if (n <= 2)
    return n;
  unordered_map<int, int> dp[n + 1];
  int ans = 0;
  for (int i = 1; i < n; i++) {
    for (int j = 0; j < i; j++) {
      int diff = arr[i] - arr[j];
      int cnt = 1;
      if (dp[j].count(diff))
        cnt = dp[j][diff];
      dp[i][diff] = 1 + cnt;
      ans = max(ans, dp[i][diff]);
    }
  }
  return ans;
}

// Longest Arithmetic Subsequence with given difference ( DP and Hashing )

class Solution{   
public:
    int lengthOfLongestAP(int A[], int n) {
       vector<vector<int>>dp(1001,vector<int>(10001,0));
       int mx=0;
       for(int i=1;i<n;i++){
           for(int j=0;j<i;j++){
               dp[i][A[i]-A[j]] = max(dp[i][A[i]-A[j]] , 1 + dp[j][A[i]-A[j]]);
               mx=max(dp[i][A[i]-A[j]],mx);
           }
       }
       return mx+1;
   }
};

// Unique Binary Search Tree ( DP + Merge Interval )

// Let C(i) denote the number of nodes on left side of root
// -> C(n-i-1) denotes the number of nodes on right side of root
// Hence the total number of BST possible will be : C(i) * C(n-i-1) for a given root
// ->Total number of BST possible will be : m * C(i) * C(n-i-1) , where m: number of different root configurations
// So, for example , the various BST for n=3:
// C(0)*C(2) + C(2)*C(0) + C(1)* C(1) --> This is known as Catalan number
// Hence, the given question is asking us to find the Catalan Number C of a number n:
// C(n)= C(i) * C(n-i-1) => i varies from 0 to n-1

1.) Recursion: Worst approach (results in TLE)

class Solution {
public:
    int numTrees(int n) {
        int result=0;
        if(n==1 || n==0)
            return 1;
        for(int i=0;i<n;i++)
            result+=numTrees(i)*numTrees(n-i-1);
        return result;
    }
};
// Time Complexity: O(3^n)

2.) Dynamic Programming: Better than Recursion
// Concept: Instead of doing recursive calls to calculate C(n-2).....C(1) every time, we store the results of previous iteration in an array result . 
// Doing so results in making only one call per function as we already know the value of C(n-1),reducing overall runtime

class Solution {
public:
    int numTrees(int n) {
        vector<int>result(n+1,0); //Initializing vector with 0
        result[1]=result[0]=1;
        for(int i=2;i<=n;i++)
        {
            for(int j=0;j<i;j++)
            {
                result[i]+=result[j]*result[i-j-1]; //Calculating C(i) to use for C(i+1) and storing it in result
            }
        }
        return result[n]; //return answer
    }
};
// Time Complexity : O(n^2)
// Space Complexity : O(n)

3.) Binomial Coefficient: Best approach
// Concept: Instead of doing it again and again like in DP and recursion, there is a well known formula to calculate Catalan Number, which is// 
// C(n)=Ci(2n,n)/n+1
// where Ci: Binomial Coefficient

class Solution {
public:
    long CalculateCoeff(int n,int k) //Function to calculate Ci(n.k)
    {
        long res=1;
        if(k>n-k)
            k=n-k;                    //Since Ci(n,k)=Ci(n,n-k), property of binomial coefficients
        for(int i=0;i<k;i++)
        {
            res*=(n-i);
            res/=(i+1);
        }
        return res;
    }
    int numTrees(int n) {
        return CalculateCoeff(2*n,n)/(n+1);
    }
};
// Time Complexity : O(n)
// Space Complexity : O(n)

// Guess Number Higher or Lower II ( DP + Merge Interval )

Approach-
// Let's try to calculate what will be the maximum amount of money required when our window for guess starts with i and is of length l
// If l = 1, then the number guessed will always be correct. So penalty will be 0.
// If l = 2, let's take i = 3, so the range is [3, 4], the maximum amount will be required when our initial guess is wrong.
// If the ans is 4, and we guessed 3 penalty is 3
// If the ans is 3 and we guessed 4 penalty is 4
// So to minimize penalty we should always guess the lower of two numbers.
// For any other l, we can choose a number j in the range (i, i+l-1) and the cost will be -
// j + maximum of money required for guaranteed win in two subranges - (i, j-1) , (j+1, i+l-1)
// To minimize the maximum money, we need to find the optimal j.
// Note: The number will be in either one of the two subranges, so we need to get only the maximum, not the summation of money in the two subranges.
// Recursion+Memoization
class Solution {
public:
    int getMoneyAmount(int n) {
        vector<vector<int>> dp(n+1, vector<int>(n+1, 0));
        //dp[i][j] - the amount of money needed for guaranteed win, when range is [i, j] (note: both are inclusive)
        for(int l = 1; l <= n; l++)
        {
            for(int i = 0; i+l-1 <= n; i++)
            { 
                if(l==1)
                {
                    // if length = 1, then the only number guessed is correct, no penalty
                    dp[i][i+l-1] = 0; 
                }
                else if(l==2)
                {
                    // if length = 2, guess the lower number, 
		    // if it's not correct then the other number will be the correct one so max amount to guarantee win is the lower of two numbers
                    dp[i][i+l-1] = i; 
                }
                else
                {
                    int ans = INT_MAX;
                    // if you guess a number j between i, i+l-1 then cost will be j + max of the money required to guarantee win on the either side
                    for(int j = i+1; j < i+l-1; j++)
                    {
                         ans = min(ans, j + max(dp[i][j-1], dp[j+1][i+l-1]));
                    }           
                    dp[i][i+l-1] = ans;
                }
            }
        }
        return dp[1][n];
    }
};

// Iterative
class Solution {
public:
    vector<vector<int>> dp;
    int solve(int start, int end)
    {
        if(start>= end)
            return 0;
        if(dp[start][end] != -1)
            return dp[start][end];
        int ans = 0;
        int result = INT_MAX;
        for(int i=start; i<=end; i++)
        {
            int left = solve(start,i-1);
            int right = solve(i+1,end);
            ans = max(left,right) + i;      // this line gurantee to include the money that is needed to win higher values
            result = min(ans,result);
        }   
        return dp[start][end] = result;
    }
    int getMoneyAmount(int n) {
        int ans = 0;
        dp = vector<vector<int>>(n+1,vector<int>(n+1,-1));
        return solve(1,n);
    }
};

// Minimum Cost From Leaf Values ( DP + Merge Interval )

// Recursion
#include<utility>
#include<climits>
/*
	Return the pair of integers
	The first one will be the max value of the leaf node in that subtree
	The second one will be the minimum value of the sum of non-leaf nodes from left to right subtrees.
*/
pair<int, int> treeSum(vector<int>& arr, int st, int end) {
	// Base case when there is a leaf node.
	if (st == end) {
		return {arr[st], 0};
	}
	/*
	   Create a two variables minSum to store the minimum sum of non-leaf nodes
	   and maxLeaf to store the maximum of leaf node
	*/
	int minSum = INT_MAX, maxLeaf = INT_MIN;
	// Split the array at the every ith position.
	for (int i = st; i < end; i++) {
		// Calling on the left subarary.
		pair<int, int> left = treeSum(arr, st, i);
		// Calling on the right subarray.
		pair<int, int> right = treeSum(arr, i + 1, end);
		minSum = min(minSum, left.second + right.second + (left.first * right.first));
		maxLeaf = max(left.first, right.first);
	}
	return {maxLeaf, minSum};
}
int minimumCostTreeFromLeafNodes(vector<int>& arr) {

	// Return the minimum sum as the answer.
	return treeSum(arr, 0, arr.size() - 1).second;
}

// Recursion+Memoization
#include<utility>
#include<climits>
/*
	Create a 2d vector of pairs dp intialise with zero.
	The first one will be the max value of the leaf node in that subtree
	The second one will be the minimum value of the sum of non-leaf nodes from left to right subtrees.
*/
pair<int, int> treeSum(vector<int>& arr, int st, int end , vector<vector<pair<int, int>>>& dp) {
	// Base case to check for leaf node.
	if (st == end) {
		return {arr[st], 0};
	}
	// To check whether we have already calculated the solution of the subproblem.
	if (dp[st][end].second != -1) {
		return dp[st][end];
	}
	/*
	   Create a two variables minSum to store the minimum sum of non-leaf nodes
	   and maxLeaf to store the maximum of leaf node
	*/
	int minSum = INT_MAX, maxLeaf = INT_MIN;
	// Split the array at the every ith position.
	for (int i = st; i < end; i++) {
		// Calling on the left subarary.
		pair<int, int> left = treeSum(arr, st, i , dp);
		// Calling on the right subarray.
		pair<int, int> right = treeSum(arr, i + 1, end , dp);
		minSum = min(minSum, left.second + right.second + (left.first * right.first));
		maxLeaf = max(left.first, right.first);
	}
	// Storing the answer in the dp table before retuning the answer.
	dp[st][end] = {maxLeaf, minSum};
	return dp[st][end];
}
int minimumCostTreeFromLeafNodes(vector<int>& arr) {
	/*
	   Create a 2d Array of pairs 'DP' intialise with zero. The first one will be the
	   max value of the leaf node in that subtree The second one will be the minimum
	   value of the sum of non-leaf nodes from left to right subtrees.
	*/
	vector<vector<pair<int, int>>> dp = vector<vector<pair<int, int>>>(arr.size(), vector<pair<int, int>>(arr.size(), {INT_MIN, -1}));
	// Return the minimum sum as the answer.
	return treeSum(arr, 0, arr.size() - 1 , dp).second;
}

// Tabulation
#include<utility>
#include<climits>
int minimumCostTreeFromLeafNodes(vector<int> &arr) {
	int n = arr.size();
	/*
	  Create a 2d vector of pairs dp intialise with zero.
	  The first one will be the max value of the leaf node in that subtree
	  The second one will be the minimum value of the sum of non-leaf nodes from left to right subtrees.
	*/
	vector<vector<pair<int, int>>> dp(n, vector<pair<int, int>>(n, {0, 0}));
	// Fill the base case when the length of each of the subarray is equal to 1.
	for (int i = 0; i < n; i++){
		dp[i][i].first = arr[i];
		for (int j = i + 1; j < n; j++){
			dp[i][j].first = max(dp[i][j - 1].first, arr[j]);
		}
	}
	// For each of the subarray starting with length 2.
	for (int l = 2; l <= n; l++) {
		// Find the starting index of the subarray.
		for (int i = 0; i < n - l + 1; i++) {
			// Find the ending index of the subarray.
			int j = i + l - 1;
			dp[i][j].second = INT_MAX;
			// Traverse over the subarray.
			for (int k = i; k < j; k++) {
				// Store the minimum sum.
				if (dp[i][j].second > dp[i][k].second + dp[k + 1][j].second + dp[i][k].first * dp[k + 1][j].first) {
					dp[i][j].second = dp[i][k].second + dp[k + 1][j].second + dp[i][k].first * dp[k + 1][j].first;
				}
			}
		}
	}
	// Return the minimum sum.
	return dp[0][n - 1].second;
}

// Space Optimized
#include<stack>
#include<climits>

int minimumCostTreeFromLeafNodes(vector<int> &arr) {
	// Create a variable to store the answer.
	int ans = 0;

	// Create a stack.
	stack<int>st;

	// Push INT_MAX intially in the stack to avoid any boundary value situations.
	st.push(INT_MAX);

	// Now Start travsering over the array.
	for (auto x : arr) {
		/*
		   Till the top of the stack is less than equal to
		   current element of the array do the following.
		*/
		while (st.top() <= x) {
			int temp = st.top();
			st.pop();
			ans += temp * min(st.top() , x);
		}
		st.push(x);
	}

	// If still the size of stack is greater than 2.
	while (st.size() > 2) {
		int temp = st.top();
		st.pop();
		ans += (temp * st.top());
	}
	// Finally return the answer.
	return ans;
}

// Buy and Sell Stock I ( DP + Decision Making )

// Brute Force
class Solution {
public:
    int maxProfit(vector<int>& price) {
        int profit=0;
    for(int i=0;i<price.size();i++){
        if(price[i]-price[i-1]){
            profit+=(price[i]-price[i-1]);
        }
    }
    return profit;
    }
};

// Recursion
class Solution {
public:
    int solve(vector<int>& prices,int index,int buy){
        if(index==prices.size()) return 0;
        int profit=0;
        if(buy){
            int buykaro=(-prices[index])+solve(prices,index+1,0);
            int skipkaro= 0 + solve(prices,index+1,1);
            profit=max(buykaro,skipkaro);
        }else{
            int sellkaro=(prices[index])+solve(prices,index+1,1);
            int skipkaro= 0 + solve(prices,index+1,0);
            profit=max(sellkaro,skipkaro);
        }
        return profit;
    }
	int maxProfit(vector<int>& prices) {
         return solve(prices,0,1);
    }
};
    
// Memoization
class Solution {
public:
    int solveMem(vector<int>&prices,int index,int buy,vector<vector<int>>&dp){
        if(index==prices.size()) return 0;
        if(dp[index][buy]!=-1) return dp[index][buy];
        int profit=0;
        if(buy){
            int buykaro=(-prices[index])+solveMem(prices,index+1,0,dp);
            int skipkaro= 0 + solveMem(prices,index+1,1,dp);
            profit=max(buykaro,skipkaro);
        }else{
            int sellkaro=(prices[index])+solveMem(prices,index+1,1,dp);
            int skipkaro= 0 + solveMem(prices,index+1,0,dp);
            profit=max(sellkaro,skipkaro);
        }
        return dp[index][buy]=profit;
    }
	int maxProfit(vector<int>& prices) {
         int n=prices.size();
         vector<vector<int>>dp(n,vector<int>(2,-1));
         return solveMem(prices,0,1,dp);
    }
};

// Tabulation
class Solution {
public:
    int solveTab(vector<int>&prices){
        int n=prices.size();
        vector<vector<int>>dp(n+1,vector<int>(2,0));
        for(int index=n-1;index>=0;index--){
            for(int buy=0;buy<=1;buy++){
           int profit=0;
           if(buy){
            int buykaro=(-prices[index])+dp[index+1][0];
            int skipkaro= 0 + dp[index+1][1];
            profit=max(buykaro,skipkaro);
           }else{
            int sellkaro=(prices[index])+dp[index+1][1];
            int skipkaro= 0 + dp[index+1][0];
            profit=max(sellkaro,skipkaro);
            }
             dp[index][buy]=profit;
           }
        }
        return dp[0][1];
    }
	int maxProfit(vector<int>& prices) {
        return solveTab(prices);
    }
};

// Space Optimized
class Solution {
public:
    int solveOpt(vector<int>& prices){
        int n=prices.size();
        vector<int>curr(2,0);
        vector<int>next(2,0);
        for(int index=n-1;index>=0;index--){
            for(int buy=0;buy<=1;buy++){
           int profit=0;
           if(buy){
            int buykaro=(-prices[index])+next[0];
            int skipkaro= 0 + next[1];
            profit=max(buykaro,skipkaro);
           }else{
            int sellkaro=(prices[index])+next[1];
            int skipkaro= 0 + next[0];
            profit=max(sellkaro,skipkaro);
            }
             curr[buy]=profit;
           }
           next=curr;
        }
        return next[1];
    }
	int maxProfit(vector<int>& prices) {
        return solveOpt(prices);
    }
};

// Buy and Sell Stock At Most 2 Times III 

// Recursion
class Solution {
public:
    int solve(vector<int>& prices, int index, bool buy, int limit){
        if(index >= prices.size()) return 0;
        int profit = 0;
        if(buy && limit < 2){
            int choose = -prices[index] + solve(prices, index+1, 0, limit+1);
            int skip = 0 + solve(prices, index+1, 1, limit);
            profit = max(choose, skip);
        }
        else if(buy == 0){
            int choose = prices[index] + solve(prices, index+1, 1, limit);
            int skip = 0 + solve(prices, index+1, 0, limit);
            profit = max(choose, skip);
        }
        return profit;
    }
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int index = 0;
        bool buy = 1;
        int limit = 0;
        return solve(prices,index,buy,limit);
    }
};

// Recursion+Memoization
class Solution {
public:
    int solveMem(vector<int>& prices, int index, bool buy, int limit, vector<vector<vector<int>>> &dp){
        if(index >= prices.size()) return 0;
        if(dp[index][buy][limit] != -1){
            return dp[index][buy][limit];
        }
        int profit = 0;
        if(buy && limit < 2){
            int choose = -prices[index] + solveMem(prices, index+1, 0, limit+1, dp);
            int skip = 0 + solveMem(prices, index+1, 1, limit, dp);
            profit = max(choose, skip);
        }
        else if(buy == 0){
            int choose = prices[index] + solveMem(prices, index+1, 1, limit, dp);
            int skip = 0 + solveMem(prices, index+1, 0, limit, dp);
            profit = max(choose, skip);
        }
        return dp[index][buy][limit] = profit;
    }
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int index = 0;
        bool buy = 1;
        int limit = 0;
        vector<vector<vector<int>>> dp(n, vector<vector<int>>(2, vector<int>(3, -1)));
        return solveMem(prices, index, buy, limit, dp);
    }
};

// Tabulation

class Solution {
public:
    int solveTab(vector<int>& prices){
        int n = prices.size();
        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(2, vector<int>(3, 0)));
        for(int index = n-1; index >= 0; index--){
            for(int buy = 0; buy <= 1; buy++){
                for(int limit = 2; limit >= 0; limit--){
                    int profit = 0;
                    if(buy && limit < 2){
                        int choose = -prices[index] + dp[index+1][0][limit+1];
                        int skip = 0 + dp[index+1][1][limit];
                        profit = max(choose, skip);
                    }
                    else if(buy == 0){
                        int choose = prices[index] + dp[index+1][1][limit];
                        int skip = 0 + dp[index+1][0][limit];
                        profit = max(choose, skip);
                    }
                    dp[index][buy][limit] = profit;
                }
            }
        }
        return dp[0][1][0];
    }
    int maxProfit(vector<int>& prices) {
        return solveTab(prices);
    }
};

// Space Optimized
class Solution {
public:
    int solveSO(vector<int> &prices){
        int n = prices.size();
        vector<vector<int>> curr(2, vector<int>(3, 0));
        vector<vector<int>> next(2, vector<int>(3, 0));
        for(int index = n-1; index >= 0; index--){
            for(int buy = 0; buy <= 1; buy++){
                for(int limit = 2; limit >= 0; limit--){
                    int profit = 0;
                    if(buy && limit < 2){
                        int choose = -prices[index] + next[0][limit+1];
                        int skip = 0 + next[1][limit];
                        profit = max(choose, skip);
                    }
                    else if(buy == 0){
                        int choose = prices[index] + next[1][limit];
                        int skip = 0 + next[0][limit];
                        profit = max(choose, skip);
                    }
                    curr[buy][limit] = profit;
                }
            }
            next = curr;
        }
        return curr[1][0];
    }
    int maxProfit(vector<int>& prices) {
        return solveSO(prices);
    }
};

// Buy and Sell Stock K Times IV

// Memoization
class Solution {
    int dfs(int i, int t, int k, int n, vector<int> & p, vector<vector<int>> &dp) {
        if(i == n || t == 2 * k) return 0;
        if(dp[i][t] != -1) return dp[i][t];

        if(t % 2 == 0) {
            return dp[i][t] = max(-p[i] + dfs(i + 1, t + 1, k, n, p, dp), 0 + dfs(i + 1, t, k, n, p, dp));
        }
        return dp[i][t] = max(p[i] + dfs(i + 1, t + 1, k, n, p, dp), 0 + dfs(i + 1, t, k, n, p, dp));
    }
public:
    int maxProfit(int k, vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2 * k, -1));
        
        return dfs(0, 0, k, n, prices, dp);
    }
};

// Tabulation
class Solution {
public:
    int maxProfit(int k, vector<int>& p) {
        int n = p.size();
        vector<vector<int>> dp(n + 1, vector<int>(2 * k + 1));
        
        for(int i=n-1; i>=0; i--) {
            for(int t=0; t<2 * k; t++) {
                if(t % 2 == 0) {
                    dp[i][t] = max(-p[i] + dp[i + 1][t + 1], 0 + dp[i + 1][t]);
                }
                else dp[i][t] = max(p[i] + dp[i + 1][t + 1], 0 + dp[i + 1][t]);
            }
        }
        return dp[0][0];
    }
};

// Space Optimized
class Solution {
public:
    int maxProfit(int k, vector<int>& p) {
        int n = p.size();
        vector<int> dp(2 * k + 1), temp(2 * k + 1);
        
        for(int i=n-1; i>=0; i--) {
            for(int t=0; t<2 * k; t++) {
                if(t % 2 == 0) {
                    temp[t] = max(-p[i] + dp[t + 1], 0 + dp[t]);
                }
                else temp[t] = max(p[i] + dp[t + 1], 0 + dp[t]);
            }
            dp = temp;
        }
        return dp[0];
    }
};

// Buy and Sell Stock With Transaction Fee V

// Memoization
class Solution {
    int dfs(int i, int buy, int n, vector<int> &p, vector<vector<int>> &dp, int fee) {
        if(i == n) return 0;
        if(dp[i][buy] != -1) return dp[i][buy];
        if(buy) {
            return dp[i][buy] = max(-p[i] + dfs(i + 1, 0, n, p, dp, fee), dfs(i + 1, 1, n, p, dp, fee));
        }
        return dp[i][buy] = max(p[i] - fee + dfs(i + 1, 1, n, p, dp, fee), dfs(i + 1, 0, n, p, dp, fee));
    }
public:
    int maxProfit(vector<int>& p, int fee) {
        int n = p.size(), cnt = 0;
        vector<vector<int>> dp(n, vector<int>(2, -1));
        return dfs(0, 1, n, p, dp, fee);
    }
};

// Tabulation
class Solution {
public:
    int maxProfit(vector<int>& p, int fee) {
        int n = p.size();
        vector<vector<int>> dp(n + 1, vector<int>(2));     
        for(int i=n-1; i>=0; i--) {
            for(int buy=0; buy<=1; buy++) {
                if(buy) {
                    dp[i][buy] = max(-p[i] + dp[i + 1][0], dp[i + 1][1]);
                }
                else dp[i][buy] = max(p[i] - fee + dp[i + 1][1], dp[i + 1][0]);
            }
        }
        return dp[0][1];
    }
};

// Space Optimization
class Solution {
public:
    int maxProfit(vector<int>& p, int fee) {
        int n = p.size();
        vector<int> dp(2), temp(2);
        
        for(int i=n-1; i>=0; i--) {
            for(int buy=0; buy<=1; buy++) {
                if(buy) {
                    temp[buy] = max(-p[i] + dp[0], dp[1]);
                }
                else temp[buy] = max(p[i] - fee + dp[1], dp[0]);
            }
            dp = temp;
        }
        return dp[1];
    }
};

// Longest Common Subsequence [LCS] ( DP on Strings )

// 1. Naive Recusive approach 
// Time complexity: O(2^n)
// Space complexity: Stack Space
// (n = Size of strings text1 and text2)

class Solution {
public:
    int helper(string text1, string text2, int m, int n){
        if(m==0 || n==0) return 0;
        else if(text1[m-1]==text2[n-1]) return 1+helper(text1, text2, m-1, n-1);
        else return max(helper(text1, text2, m, n-1), helper(text1, text2, m-1, n));
    }
    int longestCommonSubsequence(string text1, string text2) {
        int m= text1.size();
        int n=text2.size();
        return helper(text1, text2, m, n);
    }
};

// 2. Memoization 
// Time complexity: O(M*N)
// Space complexity: O(M*N) + Stack Space
// (M = Size of text1, N = Size of text2)

class Solution {
public:
    int helper(string text1, string text2, int m, int n, vector<vector<int>>&dp){
        if(m==0 || n==0) return 0;
        else if(dp[m-1][n-1]!=-1) return dp[m-1][n-1];
        else if(text1[m-1]==text2[n-1])
                return dp[m-1][n-1]=1+helper(text1, text2, m-1, n-1, dp);
        else return dp[m-1][n-1]=max(helper(text1, text2, m, n-1, dp), helper(text1, text2, m-1, n, dp));     
    }
    int longestCommonSubsequence(string text1, string text2) {
        int m= text1.size();
        int n=text2.size();
        vector<vector<int>>dp(m, vector<int>(n, -1));
        return helper(text1, text2, m, n, dp);
    }
};

// 3. Tabulation
// Time complexity: O(M*N)
// Space complexity: O(M*N)
// (M = Size of text1, N = Size of text2)

class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m= text1.size();
        int n=text2.size();
        vector<vector<int>>dp(m+1, vector<int>(n+1));
        for(int i=0;i<=n;i++){
            dp[0][i]=0;
        }
        for(int i=0;i<=m;i++){
            dp[i][0]=0;
        }
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(text1[i-1]==text2[j-1]){
                    dp[i][j]=1+dp[i-1][j-1];
                }
                else{
                    dp[i][j]=max(dp[i][j-1], dp[i-1][j]);
                }
            }
        }
        return dp[m][n];
    }
};

// 4. Optimized space (but with 2 array)
// Time complexity: O(M*N)
// Space complexity: O(N) + O(N) = O(N)
// (M = Size of text1, N = Size of text2)

class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m= text1.size();
        int n=text2.size();
        vector<int>prev(n+1, 0);
        vector<int>curr(n+1, 0);
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(text1[i-1]==text2[j-1]){
                    curr[j]=1+prev[j-1];
                }
                else{
                    curr[j]=max(curr[j-1], prev[j]);
                }
            }
            prev=curr;
        }
        return prev[n];
    }
};

// 5. Optimized space (with only one array) 
// Time complexity: O(M*N)
// Space complexity: O(N)
// (M = Size of text1, N = Size of text2)

class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m= text1.size();
        int n=text2.size();
        vector<int>prev(n+1, 0);
        int temp=0, diag=0;
        for(int i=1;i<=m;i++){
            diag=0;
            for(int j=1;j<=n;j++){
                temp=prev[j];
                if(text1[i-1]==text2[j-1]){
                    prev[j]=1+diag;
                }
                else{
                    prev[j]=max(prev[j], prev[j-1]);
                }
                diag=temp;
            }
        }
        return prev[n];
    }
};

// Longest Palindromic Subsequence ( DP on Strings )

//RECURSION [TLE]
class Solution {
public:
    int solve(string& s, int start, int end)
    {
        if (start == end) return 1;
        if (start > end) return 0;
        
        if (s[start] == s[end]) return (2 + solve(s, start + 1, end - 1));
        int leaveLeft = solve(s, start + 1, end);
        int leaveRight = solve(s, start, end - 1);
        return max(leaveLeft, leaveRight);
    }
    int longestPalindromeSubseq(string s) 
    {
        int ans = solve(s, 0, s.size() - 1);
        return ans;
    }
};

// TOP DOWN DP , MEMOIZATION
class Solution {
public:
    int solve(string& s, vector<vector<int>>&dp, int start, int end)
    {
        if (start == end) return 1;
        if (start > end) return 0;
        if (dp[start][end] != -1) return dp[start][end];
        
        if (s[start] == s[end]) return (2 + solve(s, dp, start + 1, end - 1)); //directly return 
        
        int leaveLeft = solve(s, dp, start + 1, end);
        int leaveRight = solve(s, dp, start, end - 1);
        return dp[start][end] = max(leaveLeft, leaveRight); //store the ans
    }
    int longestPalindromeSubseq(string s) 
    {
        int n = s.size();
        vector<vector<int>>dp(n, vector<int>(n, -1));
        int ans = solve(s, dp, 0, n - 1);
        return ans;
    }
};

// BOTTOM UP DP 
class Solution {
public:
    int longestPalindromeSubseq(string s) 
    {
        int n = s.size();
        vector<vector<int>>dp(n, vector<int>(n, 0));
        //for n length string we need LPS for string with length (n - 1) or (n - 2)
        //We need to already have LPS for smaller lengths before moving to greater lengths
        //so we need to go bottom up 
        //Calculating LPS for all strings of length = 1 to length = n
        for (int len = 1; len <= n; len++)
        {
            for (int start = 0; start <= (n - len); start++)
            {
                int end = start + len - 1; //[start, end] denotes the string under consideration
                if (len == 1) { dp[start][end] = 1; continue; }
                
                if (s[start] == s[end]) dp[start][end] = 2 + dp[start + 1][end - 1];
                else dp[start][end] = max(dp[start + 1][end], dp[start][end - 1]); 
            }
        }
        return dp[0][n - 1];
    }
};

// Edit distance ( DP on Strings )

// 1. Naive Recursive approach (TLE)
// Time complexity: O(2^N)
// Space complexity: Stack Space
class Solution {
public:
    int count(string word1, string word2, int m, int n){
        if(m==0) return n;
        if(n==0) return m;
        if(word1[m-1]==word2[n-1]) return count(word1, word2, m-1, n-1);
        else{
            //preform operations on word2
            int del= count(word1, word2, m, n-1);
            int insert= count(word1, word2, m-1, n);
            int replace= count(word1, word2, m-1, n-1);
            int res=min(del, insert);
            res=min(res, replace);
            return 1+res;
        }
    }
    int minDistance(string word1, string word2) {
        int m=word1.size();
        int n=word2.size();
        return count(word1, word2, m, n);
    }
};

// 2. Memoization(DP)
// Time complexity: O(m*n)
// Space complexity: O(m*n)+Stack Space
class Solution {
public:
    int count(string word1, string word2, int m, int n, vector<vector<int>>&dp){
        if(m==0) return n;
        if(n==0) return m;
        if(dp[m][n]!=-1) return dp[m][n];
        if(word1[m-1]==word2[n-1]) return count(word1, word2, m-1, n-1, dp);
        else{
            //perform operations on word2
            int del= count(word1, word2, m, n-1, dp);
            int insert= count(word1, word2, m-1, n, dp);
            int replace= count(word1, word2, m-1, n-1, dp);
            int res=min(del, insert);
            res=min(res, replace);
            return dp[m][n]= 1+res;
        }
    }
    int minDistance(string word1, string word2) {
        int m=word1.size();
        int n=word2.size();
        vector<vector<int>>dp(m+1, vector<int>(n+1, -1));
        return count(word1, word2, m, n, dp);
    }
};

// 3. Tabulation(DP)
// Time complexity: O(m*n)
// Space complexity: O(m*n)
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m=word1.size();
        int n=word2.size();
        vector<vector<int>>dp(m+1, vector<int>(n+1));
        for(int i=0;i<=n;i++){
            dp[0][i]=i;
        }
        for(int i=0;i<=m;i++){
            dp[i][0]=i;
        }
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(word1[i-1]==word2[j-1]) dp[i][j]=dp[i-1][j-1];
                else{
                    dp[i][j]=min(dp[i][j-1], dp[i-1][j]);
                    dp[i][j]=1+min(dp[i][j], dp[i-1][j-1]);
                }
            }
        }
        return dp[m][n];
    }
};

// 4. Optimized Space (Using 2 arrays)
// Time complexity: O(m*n)
// Space complexity: O(n)
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m=word1.size();
        int n=word2.size();
        vector<int>curr(n+1), prev(n+1);
        for(int i=0;i<=n;i++){
            prev[i]=i;
        }
        for(int i=1;i<=m;i++){
            curr[0]=i;
            for(int j=1;j<=n;j++){
                if(word1[i-1]==word2[j-1]) curr[j]=prev[j-1];
                else{
                    curr[j]=min(curr[j-1], prev[j]);
                    curr[j]=1+min(curr[j], prev[j-1]);
                }
            }
            prev=curr;
        }
        return prev[n];
    }
};

// 5. Optimized Space (Using only 1 array- BEST Approach)
// Time complexity: O(m*n)
// Space complexity: O(n)
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m=word1.size();
        int n=word2.size();
        vector<int>dp(n+1);
        for(int i=0;i<=n;i++){
            dp[i]=i;
        }
        for(int i=1;i<=m;i++){
            int prev=dp[0];
            dp[0]=i;
            for(int j=1;j<=n;j++){
                int curr=dp[j];
                if(word1[i-1]==word2[j-1]) dp[j]=prev;
                else{
                    dp[j]=min(dp[j-1], prev);
                    dp[j]=1+min(dp[j], curr);
                }
                prev=curr;
            }
        }
        return dp[n];
    }
};

// Max Rectangle with all 1's

class Solution {
public:
    int area_under_histogram(int histogram[], int cols) {
        if (cols == 0) {
            return 0;
        }
        stack<int>st;
        st.push(0);
        int area, res = 0, i;
        for (i = 1; i<cols; i++) {
            if (histogram[i] >= histogram[st.top()]) {
                st.push(i);
                continue;
            }
            
            while(!st.empty() and histogram[i] < histogram[st.top()]) {
                int current_bar = st.top();
                st.pop();
                if (st.empty()) {
                    area = histogram[current_bar] * i;
                }
                else {
                    area = histogram[current_bar] * (i - st.top() - 1);
                 }
                res = max(res, area);
            }
            st.push(i);
        }
        while(!st.empty()) {
             int current_bar = st.top();
                st.pop();
                if (st.empty()) {
                    area = histogram[current_bar] * i;
                }
                else {
                    area = histogram[current_bar] * (i - st.top() - 1);
                }
            res = max(res, area);
        }
        return max(area, res);
    }
    int maximalRectangle(vector<vector<char>>& matrix) {
        int rows = matrix.size();
        if (rows == 0) {
            return 0;
        }
        int cols = matrix[0].size();
        if (cols == 0) {
            return 0;
        }
        int histogram[cols];
        memset(histogram, 0, sizeof(histogram));
        int res = 0;
        for (int i = 0; i<rows; i++) {
            for (int j = 0; j<cols; j++) {
                if (matrix[i][j] == '0') {
                    histogram[j] = 0;
                }
                else {
                    histogram[j] += (matrix[i][j] - '0');
                }
            }
            int area = area_under_histogram(histogram, cols);
            res = max(area, res);
        }
        return res;
    }
};

// Wildcard Pattern Matching

// RECURSION (TLE)
class Solution {
public:
    bool f(int i,int j, string &s,string &p)
    {
        if(i<0 && j<0) return true;
        if(j<0 && i>=0) return false;
        if(i<0 && j>=0)
        {
            while(j>=0)
            {
                if(p[j]=='*') j--;
                else return false;
            }
            return true;
        }
        if(s[i]==p[j] || p[j]=='?') return f(i-1,j-1,s,p);
        if(p[j]=='*')
        {
            return f(i-1,j,s,p) || f(i,j-1,s,p);
            //Two cases
            //Consider * as len=0
            //Give one charcter to * and remain at *
            //at next step it will again be decided from both these cases
        }
        return false;   
    }
    bool isMatch(string s, string p) {
        int n=s.length(),m=p.length();
        return f(n-1,m-1,s,p);
    }
};

// Memoization
class Solution {
public:
    int f(int i,int j, string &s,string &p,vector<vector<int>> &dp)
    {
        if(dp[i][j]!=-1) return dp[i][j];
        if(i==0 && j==0) return dp[i][j]=1;
        if(j==0 && i>0) return dp[i][j]=0;
        if(i==0 && j>0)
        {
            while(j>0)
            {
                if(p[j-1]=='*') j--;
                else return dp[i][j]=0;
            }
            return dp[i][j]=1;
        }
        
        if(s[i-1]==p[j-1] || p[j-1]=='?') return dp[i][j]=f(i-1,j-1,s,p,dp);
        
        if(p[j-1]=='*')
        {
            return dp[i][j] = f(i-1,j,s,p,dp) || f(i,j-1,s,p,dp) ? 1:0;
            //Two cases
            //Consider * as len=0
            //Give one charcter to * and remain at *
            //at next step it will again be decided from both these cases
        }
        return dp[i][j]=0;
        
    }
    
    bool isMatch(string s, string p) {
        int n=s.length(),m=p.length();
        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));
        return f(n,m,s,p,dp);
    }
};

// Tabulation
class Solution {
public:
    bool isMatch(string s, string p) {
        int n=s.length(),m=p.length();
        vector<vector<bool>> dp(n+1,vector<bool>(m+1));
        dp[0][0]=true;
        for(int i=1;i<=n;i++) dp[i][0]=false;
        
        bool flag=true;
        for(int i=1;i<=m;i++)
        {
            if(p[i-1]!='*')
                flag=false;
            dp[0][i]=flag;
        }
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=m;j++)
            {
                if(s[i-1]==p[j-1] || p[j-1]=='?')
                    dp[i][j]=dp[i-1][j-1];
                else if(p[j-1]=='*')
                    dp[i][j] = dp[i-1][j] || dp[i][j-1];
                else dp[i][j]=false;
            }
        }
        return dp[n][m];
    }
};

// Space Optimized
class Solution {
public:
    bool isMatch(string s, string p) {
        int n=s.length(),m=p.length();
        // vector<vector<bool>> dp(n+1,vector<bool>(m+1));
        
        vector<bool> prev(m+1);
        //Initially prev is for n=0
        prev[0]=true;
        
        bool flag=true;
        for(int i=1;i<=m;i++)
        {
            if(p[i-1]!='*')
                flag=false;
            prev[i]=flag;
        }
        vector<bool> curr(m+1);
        
        
        for(int i=1;i<=n;i++)
        {
            curr[0]=false;
            for(int j=1;j<=m;j++)
            {
                if(s[i-1]==p[j-1] || p[j-1]=='?')
                    curr[j]=prev[j-1];
                else if(p[j-1]=='*')
                    curr[j] = prev[j] || curr[j-1];
                else curr[j]=false;
            }
            prev=curr;
        }
        return prev[m];
    }
};

// Greedy Algorithms

// N-meetings in one room

class Solution
{
    public:
    static bool cmp(pair<int,int>a, pair<int,int>b){
        return a.second < b.second;
    }
    int maxMeetings(int start[], int end[], int n)
    {
        vector<pair<int,int>>v;
        for(int i=0; i<n; i++){
            pair<int,int>p = make_pair(start[i],end[i]);
            v.push_back(p);
        }
        sort(v.begin(), v.end(), cmp);
        int cnt = 1;
        int ansEnd = v[0].second;
        for(int i=1; i<n; i++){
            if(v[i].first > ansEnd){
                cnt++;
                ansEnd = v[i].second;
            }
        }
        return cnt;
    }
};

// Shop in candy store

class Solution
{
public:
    vector<int> candyStore(int candies[], int N, int K)
    {
        sort(candies, candies + N);
        int buyCandy = 0;
        int freeCandy = N-1;
        int minAmount = 0;
        while(buyCandy <= freeCandy)
        {
            minAmount = minAmount + candies[buyCandy++];
            freeCandy = freeCandy - K; 
        }
        int maxAmount = 0;
        buyCandy = N-1;
        freeCandy = 0;
        while(freeCandy <= buyCandy)
        {
            maxAmount = maxAmount + candies[buyCandy--];
            freeCandy = freeCandy + K;
        }
        return {minAmount, maxAmount};
    }
};

// Check if it is possible to survive on island


